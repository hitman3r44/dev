!SESSION 2015-03-27 09:30:54.573 -----------------------------------------------
eclipse.buildId=M20110210-1200
java.version=1.7.0_17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\dev\WORKSPACE\.metadata\.bak_0.log
Created Time: 2015-03-31 13:15:52.986

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:15:52.986
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:52.986
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:52.986
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:15:52.987
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:52.987
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:15:57.479
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpSession;

import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.web.struts.action.LoyautyAction;
import com.sun.xml.internal.ws.api.ha.StickyFeature;

public class GetOrdersByPOSumit extends LoyautyAction {
	private static final long serialVersionUID = 2352657794009174955L;

	private static OrdersService orderService;
	
	@Getter @Setter
	private Integer sumit;
	
	
	@Getter @Setter
	private List<OrdersDTO> ordersListSumit;
	
	@Getter @Setter
	private OrdersDTO ordersDTO;
	@Getter @Setter
	private String productOrderNumber;
	
	public  GetOrdersByPOSumit() throws ServiceLocatorException {
		super();	
		orderService = getServiceLocator().getOrderService();
		ordersListSumit=new ArrayList<OrdersDTO>();
		ordersDTO=new OrdersDTO();

	}
	/*=========================================================================================
											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		
		System.out.println("I am at GetOrdersByPOSumit Action:Execute Method");

		try {
			ordersDTO.setProductOrderNumber(productOrderNumber);
			ordersListSumit=orderService.getOrdersByProductOrderNumberSumit(ordersDTO);
//			ordersListSumit = orderService.getAllOrders();
			HttpSession session = request.getSession(true);

		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}


}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:15:57.480
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.483
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.483
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:15:57.484
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.485
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:15:57.515
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.CityDTO;
import com.loyauty.service.core.dto.CurrencyDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;


public class CreateOrdersManual extends LoyautyAction {
	private static final long serialVersionUID = -1238269595572206024L;

	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	@Getter @Setter
	private String userLogin;
	@Getter @Setter
	private Long userId;
	@Getter @Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter @Setter
	private File orderFile;
	@Getter @Setter
	List<OrdersDTO>listOrdersDTO;
	Hashtable<String, OrdersDTO>hashOrders;
	@Getter @Setter
	private String orderSelected;
	@Getter @Setter
	private Long saveOrdersSignal;
	@Getter @Setter
	private Long confirmSaveOrdersSignal;
	@Getter @Setter
	private String lsOrderId;
	@Getter @Setter
	private String message;
	@Getter @Setter
	Integer indexOrder;
	@Getter @Setter
	Integer indexRow;
	@Getter @Setter
	private Long checkBoxPrintSignal;
	@Getter @Setter
	private Boolean checkBoxPrintEtem;
	@Getter @Setter
	private Boolean checkBoxPrint;
	@Getter @Setter
	private Long pageTop=0L;
	@Getter @Setter
	private Long saved;
	@Getter @Setter
	private String showNotificationPop="visibility:hidden;display:none;";
	@Getter @Setter
	private Long addOrderSignal;
	@Getter @Setter
	private Long addSimilarOrderSignal;
	@Getter @Setter
	private Long deleteOrderSignal;
	@Getter @Setter
	private Long deleteRowSignal;
	@Getter @Setter
	private Long userLoginChangedSignal;
	@Getter @Setter
	private Long saveTemporarySignal;
	@Getter @Setter
	private Long addSimilarRowSignal;
	@Getter @Setter
	private Long saveTemporaryRowSignal;
	@Getter @Setter
	private Long checkProductPriceSignal;
	@Getter @Setter
	private Long userIdFindedSignal;
	@Getter @Setter
	private String userLogo;
	//recovery Data Order
	@Getter @Setter
	private String clientLastName;
	@Getter @Setter
	private String clientFirstName;
	@Getter @Setter
	private String clientOtherNames;
	@Getter @Setter
	private String clientStreet;
	@Getter @Setter
	private String  clientOtherStreet;
	@Getter @Setter
	private String  clientCity;
	@Getter @Setter
	private String  clientProvince;
	@Getter @Setter
	private String  clientPostalCode;
	@Getter @Setter
	private String  clientPhone;
	@Getter @Setter
	private String  clientEmail;
	@Getter @Setter
	private String productOrderNumber;
	@Getter @Setter
	private String strProductOrderDate;
	@Getter @Setter
	private String strRequiredDate;
	
	//recovery data row
	@Getter @Setter
	private Double quantity ;
	@Getter @Setter
	private String lsProductID;
	@Getter @Setter
	private Double stock;
	@Getter @Setter
	private String productDescription;
	@Getter @Setter
	private Double unitPrice;
	@Getter @Setter
	private Double shippingFee;
	@Getter @Setter
	private String shippingCompany;
	@Getter @Setter
	private String trackingNumber;
	@Getter @Setter
	private String strCreationOrderDate;
	@Getter @Setter
	private Date creationOrderDate; 
	@Getter @Setter
	private String showSaveSuccessPop="visibility:hidden;display:none;";
	//showSaveSuccessPop="display:block;visibility:visible;";
	//showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter @Setter
	private Long okSaveSuccessPopSignal;
	@Getter @Setter
	private Long requirdFieldError;
	@Getter @Setter
	private Long newLsOrderIdSignal;
	@Getter @Setter
	private List<ProvinceDTO>listProvinces;
	@Getter @Setter 
	private String  code;
	//@Getter @Setter
	//private List<CityDTO>listCities;
	private Hashtable<String, ProvinceDTO>hashProvinces;
	//private Hashtable<String, CityDTO>hashCities;
	//@Getter @Setter
	//private Long provinceChangedSignal;
	private Date today ;
	
	@Getter @Setter
	private Long currencyAlertPopSignal;
	
	@Getter @Setter
	private String currencySymbol;
	
	public  CreateOrdersManual() throws ServiceLocatorException {
		super();	
		productService = getServiceLocator().getProductService();   
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		hashOrders=new Hashtable<String, OrdersDTO>();
		//listProvinces=new ArrayList<ProvinceDTO>();
		today=new Date();
	}

	/*=========================================================================================
	 											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked", "unused" })
	@Override
	public String execute() throws Exception {
		HttpSession session = request.getSession(true);
		OrdersDTO orderDTOToAdd;
		userLogo=(String)session.getAttribute("userLogo");
		requirdFieldError=(Long)session.getAttribute("requirdFieldError");
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		SimpleDateFormat frmForLsOrderId = new SimpleDateFormat("yyyyMMdd");
		OrdersDTO orderDTOToUpdate;
		String initalClient="";
		try {
			//recovery provinces
			listProvinces=(List<ProvinceDTO>)session.getAttribute("listProvinces");
			if(listProvinces==null){
				listProvinces=productService.getAllProvinces();
				session.setAttribute("listProvinces",listProvinces);
			}
			if (((strCreationOrderDate)!=null)&&(!"".equals(strCreationOrderDate))){
				try {
					creationOrderDate = frm.parse(strCreationOrderDate);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession=(List<User>)session.getAttribute("usersListSession");
			if(usersListSession==null){
				List<UserSessionDTO> listAllUsers= userService.getAllUsers(basicUserDTO);
				usersList=new ArrayList<User>();
				for(UserSessionDTO userDTO:listAllUsers){
					User user=new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession",usersList);
			}else usersList=usersListSession;


			/*-------------------- recovery orders list ------------------------------------
						displaying at least one item in the orders list if it is empty
			  -----------------------------------------------------------------------------*/
			
			if(userIdFindedSignal==null || userIdFindedSignal==0L){
				userId=(Long)session.getAttribute("userId");
				if(userId!=null){
					UserDTO userFind=userService.getUserInformation(userId);
					userLogin=userFind.getLogin();
				}
			}
			
			listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
			if(listOrdersDTO==null)listOrdersDTO =new ArrayList<OrdersDTO>();
			if(listOrdersDTO.size()==0){
				//String lsOrderIdFirstPart="Man"+frm.format(today);
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				OrdersDTO orderDTO=new OrdersDTO();
				orderDTO.setLsOrderId(manLsOrderId);
				orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
				OrdersRows orderRow=new OrdersRows();
				orderRow.setIcon("images/orders/itemNotValidated.png");
				orderDTO.getRowsList().add(orderRow);
				listOrdersDTO.add(orderDTO);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
			}else{
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				OrdersDTO ordDTO=listOrdersDTO.get(0);
				ordDTO.setLsOrderId(manLsOrderId);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			//if(provinceChangedSignal!=null && provinceChangedSignal!=0L){
				hashProvinces=(Hashtable<String, ProvinceDTO>)session.getAttribute("hashProvinces");
				if(code!=null && !code.equals("")){
					ProvinceDTO provinceDTO=hashProvinces.get(code);
					if(provinceDTO!=null){
						clientProvince=provinceDTO.getCode();
						//listCities=provinceDTO.getListCities();
					}
				}//else listCities=new ArrayList<CityDTO>();
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				orderDTOToUpdate.setClientCity(clientCity);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				//return SUCCESS;
			//}

			/*-------------------- When Admin Find User Login ---------------------------
						change all value of userid list of orders
			 -----------------------------------------------------------------------------*/
			if(userIdFindedSignal!=null && userIdFindedSignal!=0L){
				User user=userService.getUserByLogin(userLogin);
				OrdersDTO orderDTO=listOrdersDTO.get(0);
				orderDTO=fillDataOrderDTO(orderDTO);
				userLogo=null;
				userId=null;
				if(user!=null){
					orderDTO.setUserId(user.getId());
					userId=user.getId();
					currencySymbol = "CAD";
					CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
					if(currencyDTO!=null && currencyDTO.getId()!=1) {
						currencyAlertPopSignal = 1L;
						if(currencyDTO.getSymbol()!=null) currencySymbol = currencyDTO.getSymbol();
					} else currencyAlertPopSignal=0L;
					for(OrdersDTO ord:listOrdersDTO){
						ord.setUserId(user.getId());
						ord.setUserLogin(userLogin);
					}
	    			//show user logo
	    			userLogo="./images/orders/usersLogos/"+userLogin+".png";
				}else userLogin=null;

				String filePath = session.getServletContext().getRealPath("/");
				//String LogoDestination = filePath + "images/orders/usersLogos/"+userLogin+".png";
				//File f=new File(LogoDestination);
				//if(!f.exists())userId=null;

    			//if userLogo dosn't exist give him a blank logo
    			createUserLogo(filePath +"images/orders/usersLogos/BLANK.png", filePath +"images/orders/usersLogos/"+userLogin+".png");
    			
    			session.setAttribute("userLogo",userLogo);
				session.setAttribute("userId",userId);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			if(userId==null)userLogin="";

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			/*if(provinceChangedSignal!=null && provinceChangedSignal!=0L){
				hashProvinces=(Hashtable<String, ProvinceDTO>)session.getAttribute("hashProvinces");
				if(code!=null){
					listCities=hashProvinces.get(code).getListCities();
				}else listCities=new ArrayList<CityDTO>();
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				//orderDTOToUpdate.setClientCity(clientCity)
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				//return SUCCESS;
			//}*/
			
			/*----------------- When Admin check on Add Similar order Icon or save Temporary -------
									Create a copy of order selected
			 ---------------------------------------------------------------------------------------*/
			if(((addSimilarOrderSignal!=null && addSimilarOrderSignal!=0L)||(saveTemporarySignal!=null && saveTemporarySignal!=0L)) && indexOrder>=0){
				orderDTOToAdd=listOrdersDTO.get(indexOrder);
				if(orderDTOToAdd==null)orderDTOToAdd=new OrdersDTO();
				if((saveTemporarySignal!=null && saveTemporarySignal!=0L))orderDTOToAdd.setLsOrderId(lsOrderId);
				orderDTOToAdd.setCreationDate(creationOrderDate); 
				orderDTOToAdd.setClientLastName(clientLastName);
				orderDTOToAdd.setClientFirstName(clientFirstName);
				orderDTOToAdd.setClientOtherNames(clientOtherNames); 
				orderDTOToAdd.setClientStreet(clientStreet);
				orderDTOToAdd.setClientOtherStreet(clientOtherStreet);
				orderDTOToAdd.setClientCity(clientCity);
				orderDTOToAdd.setClientProvince(clientProvince);
				orderDTOToAdd.setClientProvince(clientProvince);
				orderDTOToAdd.setClientPostalCode(clientPostalCode);
				orderDTOToAdd.setClientPhone(clientPhone);
				orderDTOToAdd.setClientEmail(clientEmail);			
				orderDTOToAdd.setProductOrderNumber(productOrderNumber);
				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToAdd.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToAdd.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				User user=userService.getUserByLogin(userLogin);
				if(user!=null){
					UserDTO userDTO=userService.getUserInformation(user.getId());
					orderDTOToAdd.setUserLogin(userLogin);
					orderDTOToAdd.setUserId(userDTO.getId());
				}
				if(addSimilarOrderSignal!=null && addSimilarOrderSignal!=0L){ 
					OrdersDTO orderDTOClone = DTOFactory.getOrderDTOClone(orderDTOToAdd);
					orderDTOClone.setCssStyle("background-color:white;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					listOrdersDTO.add(orderDTOClone);
				}
				int indexOrder=0;
				for(OrdersDTO orderDTO:listOrdersDTO){
					orderDTO.setIndex(indexOrder);
					indexOrder++;
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			
			/*----------------- When Admin click on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if(saveTemporaryRowSignal!=null && saveTemporaryRowSignal!=0L){
				
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				/*
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);
				orderDTOToUpdate.setCreationDate(creationOrderDate);
				orderDTOToUpdate.setClientLastName(clientLastName);
				orderDTOToUpdate.setClientFirstName(clientFirstName);
				orderDTOToUpdate.setClientOtherNames(clientOtherNames); 
				orderDTOToUpdate.setClientStreet(clientStreet);
				orderDTOToUpdate.setClientOtherStreet(clientOtherStreet);
				orderDTOToUpdate.setClientCity(clientCity);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientPostalCode(clientPostalCode);
				orderDTOToUpdate.setClientPhone(clientPhone);
				orderDTOToUpdate.setClientEmail(clientEmail);			
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);

				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToUpdate.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToUpdate.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				*/
				OrdersRows orderRowToSaveMemory=orderDTOToUpdate.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if(orderRowToSaveMemory!=null){
					orderRowToSaveMemory.setQuantity(quantity); 
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory.setCssPrice("background-color:red;");
					if(unitPrice!=null && orderRowToSaveMemory.getLsPrice()!=null
					  && unitPrice>=orderRowToSaveMemory.getLsPrice())
					  orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trackingNumber);	
					int indexOrder=0;
					int indexRow=0;
					for(OrdersDTO orderDTO:listOrdersDTO){
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow=0;
						for(OrdersRows orderRows:orderDTO.getRowsList()){
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				}

				return SUCCESS;
			}
			
			/*-------------------- When Admin click on addSimilarRow Icon -----------------
										Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if(addSimilarRowSignal!=null && addSimilarRowSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone=orderDTOToUpdate.getRowsList().get(indexRow);
				if(orderRowToClone!=null){
					if(!orderRowToClone.getIcon().equals("images/orders/itemValidated.png")){
						orderRowToClone.setQuantity(quantity); 
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingPrice(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trackingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd=DTOFactory.getOrderRowClone(orderRowToClone);
					orderDTOToUpdate.getRowsList().add(indexRow+1,orderRowToAdd);
					int indexOrder=0;
					int indexRow=0;
					for(OrdersDTO orderDTO:listOrdersDTO){
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow=0;
						for(OrdersRows orderRows:orderDTO.getRowsList()){
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				}
				return SUCCESS;
			}

			/*-------------------- When Admin click on Delete order Icon -------------
									Delete this order using index
			 -----------------------------------------------------------------------------*/
			
			if(deleteOrderSignal!=null && deleteOrderSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				List<OrdersDTO> listOrdersDTOAfterDelete=new ArrayList<OrdersDTO>();
				for(int i=0 ;i<listOrdersDTO.size();i++){
					if(i!=indexOrder || indexOrder==0)listOrdersDTOAfterDelete.add(listOrdersDTO.get(i));
				}
				int index=0;
				for(int i=0 ;i<listOrdersDTOAfterDelete.size();i++){
					listOrdersDTOAfterDelete.get(i).setIndex(index);
					index++;
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTOAfterDelete);
				listOrdersDTO=listOrdersDTOAfterDelete;
				return SUCCESS;
			}

			/*-------------------- When Admin check on Delete Row Icon -------------------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if(deleteRowSignal!=null && deleteRowSignal!=0L){
				ArrayList<OrdersRows>listRowsAfterDelete=new ArrayList<OrdersRows>();
				OrdersDTO orderDTO=listOrdersDTO.get(indexOrder);
				orderDTO=fillDataOrderDTO(orderDTO);
				if(orderDTO!=null && orderDTO.getRowsList().size()>1){
					for(int i=0 ;i<orderDTO.getRowsList().size();i++){
						if(i!=indexRow)listRowsAfterDelete.add(orderDTO.getRowsList().get(i));
					}
					int index=0;
					for(int i=0 ;i<listRowsAfterDelete.size();i++){
						listRowsAfterDelete.get(i).setIndex(index);
						index++;
					}
					orderDTO.setRowsList(listRowsAfterDelete);
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			

			/*-------------------- When Admin check left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if(checkProductPriceSignal!=null && checkProductPriceSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				/*
				orderDTOToUpdate.setClientLastName(clientLastName);
				orderDTOToUpdate.setClientFirstName(clientFirstName);
				orderDTOToUpdate.setClientOtherNames(clientOtherNames); 
				orderDTOToUpdate.setClientStreet(clientStreet);
				orderDTOToUpdate.setClientOtherStreet(clientOtherStreet);
				orderDTOToUpdate.setClientCity(clientCity);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientPostalCode(clientPostalCode);
				orderDTOToUpdate.setClientPhone(clientPhone);
				orderDTOToUpdate.setClientEmail(clientEmail);			
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);
				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToUpdate.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToUpdate.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				*/
				OrdersRows orderRowToUpadate=orderDTOToUpdate.getRowsList().get(indexRow);
				UserProductPriceDTO userProductPrice=productService.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if(userProductPrice==null){
					lsProductID=null;
					orderRowToUpadate.setCss("background-color:red;");
					addActionError(getText("loyauty.error.common.requiredLsProductOrder"));
					orderRowToUpadate.setProductDescription(""); 
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				}else{
					Double usrPrice=orderRowToUpadate.getUnitPrice();
					if(usrPrice==null)usrPrice=0D;
					if(usrPrice < userProductPrice.getPriceNum()){
						orderRowToUpadate.setCssPrice("background-color:red;");	
					}
					orderRowToUpadate.setProductDescription(userProductPrice.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice.getLsProductId());
					orderRowToUpadate.setLsPrice(userProductPrice.getPriceNum());
					if(userProductPrice.getUserId()!=null) {
						//currency
						Long userId = userProductPrice.getUserId();
						Long currencyId = 1L;
						Double currencyRate = 1D;
						Double currencyPrice = 0D;
						CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
						if(currencyDTO!=null && currencyDTO.getRate()!=null) {
							currencyId = currencyDTO.getId();
							if(currencyId!=1) {
								currencyRate = currencyDTO.getRate();
								currencyPrice = (double) Math.round((orderRowToUpadate.getLsPrice()*currencyRate)*100) / 100;
								orderRowToUpadate.setLsPrice(currencyPrice);
							}
						}
					}
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				return SUCCESS;
			}
			
			/*-------------------------------- SAVE ORDERS -------------------------------
						save in data bases just orders witch has print checked 
	 		 -----------------------------------------------------------------------------*/
			if(saveOrdersSignal!=null && saveOrdersSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				User user=userService.getUserByLogin(userLogin);
				OrdersDTO order=listOrdersDTO.get(0);
				order.setManOrder(true);
				order=fillDataOrderDTO(order);
				if(user!=null)order.setUserId(user.getId());
				boolean productNotFond=false;
				for(OrdersRows row:order.getRowsList()){
					if(row.getLsProductID()==null || row.getLsProductID().equals("")){
						productNotFond=true;
						break;
					}
				}
				requirdFieldError=null;
				session.setAttribute("requirdFieldError",null);
				productOrderNumber=order.getProductOrderNumber().replaceAll("^ +| +$|( )+", "$1");
				clientFirstName=order.getClientFirstName().replaceAll("^ +| +$|( )+", "$1");
				clientLastName=order.getClientLastName().replaceAll("^ +| +$|( )+", "$1");
				clientStreet=order.getClientStreet().replaceAll("^ +| +$|( )+", "$1");
				clientCity=order.getClientCity().replaceAll("^ +| +$|( )+", "$1");
				clientProvince=order.getClientProvince().replaceAll("^ +| +$|( )+", "$1");
				clientPostalCode=order.getClientPostalCode().replaceAll("^ +| +$|( )+", "$1");
				
				order.setProductOrderNumber(productOrderNumber);
				order.setClientFirstName(clientFirstName);
				order.setClientLastName(clientLastName);
				order.setClientStreet(clientStreet);
				order.setClientCity(clientCity);
				order.setClientProvince(clientProvince);
				order.setClientPostalCode(clientPostalCode);
				
				if(order.getProductOrderNumber()==null || order.getProductOrderNumber().equals("")||
						   order.getLsOrderId()==null || order.getLsOrderId().equals("") ||
						   order.getCreationDate()==null || productNotFond ||
						   order.getClientFirstName()==null || order.getClientFirstName().equals("")||
						   order.getClientLastName()==null || order.getClientLastName().equals("") ||
						   order.getClientStreet()==null || order.getClientStreet().equals("") ||
						   order.getClientCity()==null || order.getClientCity().equals("") || 
						   order.getClientProvince()==null || order.getClientProvince().equals("") ||
						   order.getClientPostalCode()==null || order.getClientPostalCode().equals("")){
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					addActionError(getText("loyauty.error.common.requiredFieldOrders"));
					requirdFieldError=1L;
					session.setAttribute("requirdFieldError",1L);
					return SUCCESS;
				}
				
				for(OrdersRows row:order.getRowsList()){
					if(row.getLsProductID()==null || row.getLsProductID().equals("")||
					   row.getQuantity()==null || row.getQuantity()==0D){
						requirdFieldError=1L;
					   session.setAttribute("requirdFieldError",1L);
					   addActionError(getText("loyauty.error.common.requiredFieldOrders"));
					   return SUCCESS;
					}
				}
				//add special handling shipping	+ currency
				for(OrdersDTO orDTO:listOrdersDTO){
					if(user!=null){
						//currency
						Long userId = user.getId();
						Long currencyId = 1L;
						String currencySymbol = "CAD";
						Double currencyRate = 1D;
						Double currencyUnitPrice = 0D;
						Double currencyTotalPrice = null;
						//Double currencyShippingPrice = null;
						Double unitPrice = null;
						CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
						if(currencyDTO!=null) {
							currencyId = currencyDTO.getId();
							if(currencyDTO.getSymbol()!=null) currencySymbol = currencyDTO.getSymbol();
							if(currencyDTO.getRate()!=null) currencyRate = currencyDTO.getRate();
						}
						
						Double totalPrice=null;
						orDTO.setSpecialHandlingName(user.getSpecialHandlingName());
						orDTO.setSpecialHandlingFee(user.getSpecialHandlingFee());
						if(orDTO.getRowsList().get(0).getQuantity()!=null && orDTO.getRowsList().get(0).getUnitPrice()!=null){
							unitPrice = orDTO.getRowsList().get(0).getUnitPrice();
							totalPrice= orDTO.getRowsList().get(0).getQuantity()*unitPrice;
							totalPrice = (double) Math.round(totalPrice * 100) / 100;
							if(currencyId!=1) {
								currencyUnitPrice = unitPrice;
								unitPrice = (double) Math.round((unitPrice/currencyRate)*100) / 100;
								orDTO.setUnitPrice(unitPrice);
								orDTO.getRowsList().get(0).setUnitPrice(unitPrice);
								currencyTotalPrice = totalPrice;
								totalPrice = (double) Math.round((totalPrice/currencyRate)*100) / 100;
								/*
								if(orDTO.getRowsList().get(0).getShippingPrice()!=null) {
									currencyShippingPrice = orDTO.getRowsList().get(0).getShippingPrice();
									Double shippingPrice = (double) Math.round((currencyShippingPrice/currencyRate)*100) / 100;
									orDTO.setShippingPrice(shippingPrice);
									orDTO.setShippingFee(shippingPrice);
									orDTO.setCurrencyShippingPrice(currencyShippingPrice);
									orDTO.getRowsList().get(0).setShippingPrice(shippingPrice);
									orDTO.getRowsList().get(0).setShippingFee(shippingPrice);
									orDTO.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
								}
								*/
							}
						}
						orDTO.setTotalPrice(totalPrice);
						orDTO.setCurrencyId(currencyId);
						orDTO.setCurrencySymbol(currencySymbol);
						orDTO.setCurrencyRate(currencyRate);
						orDTO.setCurrencyUnitPrice(currencyUnitPrice);
						orDTO.setCurrencyTotalPrice(currencyTotalPrice);
						
						for(OrdersRows row: orDTO.getRowsList()){
							row.setCurrencyId(currencyId);
							row.setCurrencySymbol(currencySymbol);
							row.setCurrencyRate(currencyRate);
							row.setCurrencyUnitPrice(currencyUnitPrice);
						}
					}	
				}
				listOrdersDTO=orderService.insertListOrders(listOrdersDTO);
				listOrdersDTO=new ArrayList<OrdersDTO>();
				if(listOrdersDTO.size()==0){
					frm = new SimpleDateFormat("yyyyMMdd");
					if(userLogin!=null && userLogin.length()>=2){
						initalClient=userLogin.substring(0, 2);
						initalClient=initalClient.toUpperCase();
					}
					//String lsOrderIdFirstPart="Man"+frm.format(today);
					String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
					String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
					OrdersDTO orderDTO=new OrdersDTO();
					//recovery userId
					if(user!=null)orderDTO.setUserId(user.getId());
					orderDTO.setLsOrderId(manLsOrderId);
					orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					OrdersRows orderRow=new OrdersRows();
					orderRow.setIcon("images/orders/itemNotValidated.png");
					orderDTO.getRowsList().add(orderRow);
					listOrdersDTO.add(orderDTO);
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				}
				message="Saving has completed successfuly";
				showSaveSuccessPop="display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
	 		 -----------------------------------------------------------------------------*/
			if(checkBoxPrintSignal!=null && checkBoxPrintSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				OrdersDTO orderDTOInList=listOrdersDTO.get(indexOrder);
				orderDTOInList=fillDataOrderDTO(orderDTOInList);
				orderDTOInList.setPrint(checkBoxPrint);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}


			/*-------------- When user click on the button OK of showSaveSuccessPop -------
						just hide dialogue popup: showSaveSuccessPop
	 		 ------------------------------------------------------------------------------*/
			if(okSaveSuccessPopSignal!=null && okSaveSuccessPopSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				showSaveSuccessPop="visibility:hidden;display:none;";
				return SUCCESS;
			}



			/*-------------- When user click on the image imgNewLsOrderId -----------------
								generate other LsOrderId
	 		 ------------------------------------------------------------------------------*/
			if(newLsOrderIdSignal!=null && newLsOrderIdSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				OrdersDTO orderDTO=listOrdersDTO.get(0);
				frm = new SimpleDateFormat("yyyyMMdd");
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				//String lsOrderIdFirstPart="Man"+frm.format(today);
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				orderDTO.setLsOrderId(manLsOrderId);
				return SUCCESS;
			}

		} catch (Exception e) {
			addActionError(getText("loyauty.error.common.userNotSelected"));
			e.printStackTrace();
			return "input";
		}
	return SUCCESS;
	}
	

	   /*=========================================================================================
								fill all fields of order without rows
		 =========================================================================================*/
		public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO){
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			//orderToEdit=listOrdersDTO.get(indexOrder);
			orderDTO.setClientLastName(clientLastName);
			orderDTO.setClientFirstName(clientFirstName);
			orderDTO.setClientOtherNames(clientOtherNames); 
			orderDTO.setClientStreet(clientStreet);
			orderDTO.setClientOtherStreet(clientOtherStreet);
			orderDTO.setClientCity(clientCity);
			orderDTO.setClientProvince(clientProvince);
			orderDTO.setClientProvince(clientProvince);
			orderDTO.setClientPostalCode(clientPostalCode);
			orderDTO.setClientPhone(clientPhone);
			orderDTO.setClientEmail(clientEmail);			
			orderDTO.setProductOrderNumber(productOrderNumber);
			
			
			if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strProductOrderDate);
					orderDTO.setProductOrderDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			
			if (((strCreationOrderDate)!=null)&&(!"".equals(strCreationOrderDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationOrderDate);
					orderDTO.setCreationDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			
			if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strRequiredDate);
					orderDTO.setRequiredDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			return orderDTO;
		}


		/*=========================  createUserLogo ===========================
		 				Create  Blank User Logo if not Exist
		  =================================================================*/
		public void createUserLogo(String source, String destination) throws IOException{
			File fileLogo=new File(destination);
			if(!fileLogo.exists()){
				InputStream in = new FileInputStream(source);
				OutputStream out = new FileOutputStream(destination);
				byte[] buf = new byte[1024];
				int len;
				while ((len = in.read(buf)) > 0) {
					out.write(buf, 0, len);
				}
				in.close();
				out.close();	
			}
		}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:15:57.516
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.516
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.517
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:15:57.517
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.518
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:15:57.527
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class GoToOrders extends LoyautyAction {
	private static final long serialVersionUID = 2352657794009174955L;

	private UserService userService;
	private static ProductService productService;
	private static OrdersService orderService;
	private Date today;
	@Getter @Setter
	private List<OrdersDTO>listOrdersDTO;
	@Getter @Setter
	private List<User> usersList;
	@Getter @Setter
	private Long init;
	@Getter @Setter
	private Date creationDate ;
	@Getter @Setter
	private Date creationDateStart ;
	@Getter @Setter
	List<ProvinceDTO>listProvinces;
	@Getter @Setter
	private Integer reportDateBetween;
	@Getter @Setter
	private Integer invoicingDateBetween;
	@Getter @Setter 
	private String  code;

	private static int USER_TYPE = 2;

	public  GoToOrders() throws ServiceLocatorException {
		super();	
		userService = getServiceLocator().getUserService();
		productService = getServiceLocator().getProductService();
		orderService = getServiceLocator().getOrderService();
		today=new Date();
		usersList=new ArrayList<User>();
		listOrdersDTO=new ArrayList<OrdersDTO>();
	}
	/*=========================================================================================
											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		
		System.out.println("I am at Handeling Page");

		try {
			HttpSession session = request.getSession(true);
			listProvinces=productService.getAllProvinces();
			session.setAttribute("reportDateBetween",0);
			session.setAttribute("invoicingDateBetween",0);
			session.setAttribute("indexSet",0);  
			session.setAttribute("nextListPages",0);
			session.setAttribute("checkBoxItem",false);
			session.setAttribute("invoicedOrdersRefresh",0L);
			new ReportOrders().initalizeListIndexSet(session, orderService);
			session.setAttribute("totalInvoicedOrders",0L);
			session.setAttribute("totalOrders",0L);
			Hashtable<String, ProvinceDTO> hashProvinces=new Hashtable<String, ProvinceDTO>();
			for(ProvinceDTO prov:listProvinces){
				hashProvinces.put(prov.getCode(), prov);
			}
			session.setAttribute("hashProvinces",hashProvinces);
			//------------------ recovery users list ---------------------------
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession=(List<User>)session.getAttribute("usersListSession");
			if(usersListSession==null){
				List<UserSessionDTO> listAllUsers= userService.getAllUsers(basicUserDTO);
				for(UserSessionDTO userDTO:listAllUsers){
					User user=new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession",usersList);
			}else usersList=usersListSession;
			session.setAttribute("listOrdersDTOMan",null);
			session.setAttribute("listOrdersDTOAuto",null);
			if(init!=null && init!=0){
				int call=Integer.parseInt(init.toString());
				switch (call) {
				case 1:
					SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
					String lsOrderIdFirstPart="Man"+sdf.format(today);
					String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
					OrdersDTO orderDTO=new OrdersDTO();
					orderDTO.setLsOrderId(manLsOrderId);
					orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					OrdersRows orderRow=new OrdersRows();
					orderRow.setIcon("images/orders/itemNotValidated.png");
					orderDTO.getRowsList().add(orderRow);
					listOrdersDTO.add(orderDTO);
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					break;
				case 2:
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}


}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:15:57.527
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.528
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.528
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:15:57.528
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.529
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:15:57.548
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;

import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceException;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OperationsDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.core.dto.UsersPrivilegesDTO;
import com.loyauty.service.operations.OperationsService;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class ReportOrders extends LoyautyAction {
	private static final long serialVersionUID = -3811760851445730062L;
	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	private OperationsService operationsService;
	@Getter
	@Setter
	private String userLogin;
	@Getter
	@Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter
	@Setter
	List<OrdersDTO> listOrdersDTO;
	@Getter
	@Setter
	List<OrdersDTO> listStatus;
	@Getter
	@Setter
	private String lsOrderId;
	@Getter
	@Setter
	Long poYpop;
	@Getter
	@Setter
	Long poXpop;
	@Getter
	@Setter
	private Long pageTop = 0L;
	@Getter
	@Setter
	private Date creationDate;
	@Getter
	@Setter
	private Long findOrdersSignal;
	private String status;
	@Getter
	@Setter
	private Long sizeResult = 0L;
	@Getter
	@Setter
	private Long sorting;
	@Getter
	@Setter
	private Long sortingOrdersSignal;
	@Getter
	@Setter
	private Integer fieldForSorting;
	@Getter
	@Setter
	private Integer asc;
	@Getter
	@Setter
	private Integer scrollDivRowsLeft;
	@Getter
	@Setter
	private Integer scrollPageLeft;
	@Getter
	@Setter
	private Integer scrollDivRowsTop;
	@Getter
	@Setter
	private String strCreationDateStart;
	@Getter
	@Setter
	private String strCreationDateEnd;
	@Getter
	@Setter
	private Date creationDateStart;
	@Getter
	@Setter
	private Date creationDateEnd;
	private Date creationDateStartArg;
	private Date creationDateEndArg;
	@Getter
	@Setter
	private Integer selectedStatus;
	@Getter
	@Setter
	private Long editOrderSignal;
	@Getter
	@Setter
	private Long cancelSignal;
	@Getter
	@Setter
	private Integer indexOrder;
	@Getter
	@Setter
	private OrdersDTO orderToEdit;
	@Getter
	@Setter
	private String strProductOrderDate;
	@Getter
	@Setter
	private String lsProductID;
	@Getter
	@Setter
	Integer indexRow;
	@Getter
	@Setter
	private String showOrderDetailPop;
	@Getter
	@Setter
	private Long userId;
	@Getter
	@Setter
	private Long checkProductPriceSignal;
	@Getter
	@Setter
	private Long saveTemporaryRowSignal;
	@Getter
	@Setter
	private Long addSimilarRowSignal;
	@Getter
	@Setter
	private Long deleteRowSignal;
	@Getter
	@Setter
	private Long saveOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxPrint;

	// recovery Data Order
	@Getter
	@Setter
	private String clientLastName;
	@Getter
	@Setter
	private String clientFirstName;
	@Getter
	@Setter
	private String clientOtherNames;
	@Getter
	@Setter
	private String clientStreet;
	@Getter
	@Setter
	private String clientOtherStreet;
	@Getter
	@Setter
	private String clientCity;
	@Getter
	@Setter
	private String clientProvince;
	@Getter
	@Setter
	private String clientPostalCode;
	@Getter
	@Setter
	private String clientPhone;
	@Getter
	@Setter
	private String clientEmail;
//	@Getter
//	@Setter
//	private String productOrderNumber;
	@Getter
	@Setter
	private String strRequiredDate;

	// recovery data row
	@Getter
	@Setter
	private Double quantity;
	@Getter
	@Setter
	private String notes;
	@Getter
	@Setter
	private Double quantityToChange;
	@Getter
	@Setter
	private Double stock;
	@Getter
	@Setter
	private String productDescription;
	@Getter
	@Setter
	private Double unitPrice;
	@Getter
	@Setter
	private Double shippingFee;
	@Getter
	@Setter
	private String shippingCompany;
	@Getter
	@Setter
	private String companyHeader;

	@Getter
	@Setter
	private Long quantityToChangeSignal;
	@Getter
	@Setter
	private Long duplicateOrderSignal;
	@Getter
	@Setter
	private String strCreationDate;
	@Getter
	@Setter
	private String strCreationOrderDate;
	@Getter
	@Setter
	private User usr;
	@Getter
	@Setter
	private String showSaveSuccessPop;
	// showSaveSuccessPop="display:block;visibility:visible;";
	// showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter
	@Setter
	private String message;
	@Getter
	@Setter
	private Long okSaveSuccessPopSignal;
	@Getter
	@Setter
	private Long showRowShipping;
	@Getter
	@Setter
	private Long showOnlyEditNote;
	@Getter
	@Setter
	private Long saveShippingSignal;
	@Getter
	@Setter
	private Long saveOnlyNoteSignal;
	@Getter
	@Setter
	private String code;
	@Getter
	@Setter
	private Long cityId;
	@Getter
	@Setter
	private List<ProvinceDTO> listProvinces;
	private Hashtable<String, ProvinceDTO> hashProvinces;
	@Getter
	@Setter
	private Boolean orderNotSavedAtFirst;
	@Getter
	@Setter
	private String strShippedDate;
	@Getter
	@Setter
	private String strShippingPrice;
	@Getter
	@Setter
	private String showConfirmDeleteOrderPop;
	@Getter
	@Setter
	private Long deleteOrderSignal;
	@Getter
	@Setter
	private Long confirmDeleteSignal;
	@Getter
	@Setter
	private UsersPrivilegesDTO userPrivileges;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivShippedToInvoiced;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivChangeShippedStatus;
	@Getter
	@Setter
	private HashMap<Integer, String> hashStatus;
	@Getter
	@Setter
	private Long statusId;
	@Getter
	@Setter
	private String strPrint;
	@Getter
	@Setter
	private Integer testSignal;
	@Getter
	@Setter
	private String newStatus;
	Long invoicedOrdersRefresh;
	@Getter
	@Setter
	private Integer reportDateBetween;
	@Getter
	@Setter
	private Long dateBetweenSignal;
	@Getter
	@Setter
	private Long selectAllOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxItem;
	// ------Pagination
	@Getter
	@Setter
	Long pageIndexSignal;
	@Getter
	@Setter
	Long prevListPagesSignal;
	@Getter
	@Setter
	Long nextListPagesSignal;
	@Getter
	@Setter
	Long totalOrders;
	@Getter
	@Setter
	Integer nextListPages;
	@Getter
	@Setter
	Integer prevListPages;
	@Getter
	@Setter
	Integer indexSet = 0;
	@Getter
	@Setter
	Integer indexList;
	@Getter
	@Setter
	List<OrdersDTO> listIndexSet;
	@Getter
	@Setter
	Integer PAGE_ITEMS_COUNT = 100;
	
	//New Added Field in the search option as toggle functionality
	@Getter
	@Setter
	private String productOrderNumberSearch;
	@Getter
	@Setter
	private String trakingNumber;
	@Getter
	@Setter
	private String  clientOther;
	@Getter
	@Setter
	private String	 clientOrderNumber;
	//New Added Field in the search option as toggle functionality

	// ------Pagination

	/*
	 * ==========================================================================
	 * =============== Default constructor
	 * ======================================
	 * ===================================================
	 */
	public ReportOrders() throws ServiceLocatorException {
		super();
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		productService = getServiceLocator().getProductService();
		operationsService = getServiceLocator().getOperationsService();
	}

	/*
	 * ==========================================================================
	 * =============== method execute
	 * ============================================
	 * =============================================
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		System.out.println("Product Order Number: "+ productOrderNumberSearch);
		System.out.println("Tracking Number: "+ trakingNumber);
		System.out.println("Client Order ID: "+ clientOrderNumber);
		System.out.println("Client Other ID: "+ clientOther);
		
		HttpSession session = request.getSession(true);

		if (showOrderDetailPop == null)
			showOrderDetailPop = "visibility:hidden;display:none;";
		if (showConfirmDeleteOrderPop == null)
			showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
		if (showSaveSuccessPop == null)
			showSaveSuccessPop = "visibility:hidden;display:none;";
		if (poYpop == null)
			poYpop = 100L;
		if (poXpop == null)
			poXpop = 100L;
		Hashtable<String, OrdersDTO> hashOrders;
		if (selectedStatus == null)
			selectedStatus = -1;
		sizeResult = (Long) session.getAttribute("sizeResult");
		totalOrders = (Long) session.getAttribute("totalOrders");
		if (totalOrders == null)
			totalOrders = 0L;
		asc = (Integer) session.getAttribute("asc");
		if (asc == null)
			asc = 0;
		if (sizeResult == null)
			sizeResult = 0L;
		if (indexOrder == null)
			indexOrder = 0;
		userPrivileges = (UsersPrivilegesDTO) session.getAttribute("userPrivileges");
		usersPrivShippedToInvoiced = (UsersPrivilegesDTO) session.getAttribute("usersPrivShippedToInvoiced");
		usersPrivChangeShippedStatus = (UsersPrivilegesDTO) session
				.getAttribute("usersPrivChangeShippedStatus");
		hashStatus = (HashMap<Integer, String>) session
				.getAttribute("hashStatus");
		if (hashStatus == null) {
			hashStatus = new HashMap<Integer, String>();
			hashStatus.put(0, "");
			hashStatus.put(1, "open");
			hashStatus.put(2, "progress");
		}
		List<Integer> listIndexColumn = new ArrayList<Integer>();
		// fill list status
		listStatus = (ArrayList<OrdersDTO>) session.getAttribute("listStatus");
		if (listStatus == null) {
			listStatus = new ArrayList<OrdersDTO>();
			OrdersDTO orderDTOOpen = new OrdersDTO();
			orderDTOOpen.setStatus("open");
			orderDTOOpen.setId(0L);
			listStatus.add(orderDTOOpen);
			OrdersDTO orderDTOProgress = new OrdersDTO();
			orderDTOProgress.setStatus("progress");
			orderDTOProgress.setId(1L);
			listStatus.add(orderDTOProgress);
			if (usersPrivChangeShippedStatus != null) {
				OrdersDTO orderDTOShipped = new OrdersDTO();
				orderDTOShipped.setStatus("shipped");
				orderDTOShipped.setId(2L);
				listStatus.add(orderDTOShipped);
			}

		}

		try {

			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			// recovery provinces
			listProvinces = (List<ProvinceDTO>) session
					.getAttribute("listProvinces");
			if (listProvinces == null)
				listProvinces = productService.getAllProvinces();
			orderNotSavedAtFirst = (Boolean) session
					.getAttribute("listNotSavedAtFirst");
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession = (List<User>) session
					.getAttribute("usersListSession");
			if (usersListSession == null) {
				List<UserSessionDTO> listAllUsers = userService
						.getAllUsers(basicUserDTO);
				usersList = new ArrayList<User>();
				for (UserSessionDTO userDTO : listAllUsers) {
					User user = new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession", usersList);
			} else
				usersList = usersListSession;
			listOrdersDTO = (ArrayList<OrdersDTO>) session
					.getAttribute("listOrdersDTOReport");
			reportDateBetween = (Integer) session
					.getAttribute("reportDateBetween");
			if (reportDateBetween == null) {
				reportDateBetween = 0;
				session.setAttribute("reportDateBetween", reportDateBetween);
			}

			/*------ always check if the Admin select all orders ------------
					if The Admin select all orders change checkBoxItem value 
			  ---------------------------------------------------------------*/
			if (selectAllOrdersSignal != null && selectAllOrdersSignal != 0L) {
				if (checkBoxItem != null) {
					session.setAttribute("checkBoxItem", checkBoxItem);
					session.setAttribute("allOrdersSelectedSignal", 0L);
					if (checkBoxItem)
						session.setAttribute("allOrdersSelectedSignal", 1L);
				}
			}
			checkBoxItem = (Boolean) session.getAttribute("checkBoxItem");
			if (checkBoxItem == null)
				checkBoxItem = false;
			/*------ always recovery creationDate from strCreationDate ------
						always keep the user search options
			  ---------------------------------------------------------------*/
			creationDateStart = null;
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			if (((strCreationDateStart) != null)
					&& (!"".equals(strCreationDateStart))) {
				try {
					Date date = frm.parse(strCreationDateStart);
					creationDateStart = date;
					creationDateStartArg = date;
				} catch (Exception pe) {
					creationDateStart = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateStart == null) {
				Date date = frm.parse("01/01/1900");
				creationDateStartArg = date;
			}
			creationDateEnd = null;
			if (((strCreationDateEnd) != null)
					&& (!"".equals(strCreationDateEnd))) {
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationDateEnd);
					creationDateEnd = date;
					creationDateEndArg = date;
				} catch (Exception pe) {
					creationDateEnd = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateEnd == null) {
				creationDateEndArg = new Date();
			}

			/*------ always recovery Status from selectedStatus key ------
						always keep the status search options
			  ---------------------------------------------------------------*/
			status = getStatusSelected(selectedStatus);

			/*----------- always initialized listPages if not done ----------
				   		    and check if is there next listPages
			  ---------------------------------------------------------------*/
			nextListPages = (Integer) session.getAttribute("nextListPages");
			if (nextListPages == null)
				nextListPages = 0;
			if (indexSet == null || indexSet == -1) {
				indexSet = (Integer) session.getAttribute("indexSet");
				if (indexSet == null)
					indexSet = 0;
			}
			listIndexSet = (List<OrdersDTO>) session
					.getAttribute("listIndexSet");
			if (listIndexSet == null)
				initalizeListIndexSet(session, orderService);

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/

			if (dateBetweenSignal != null && dateBetweenSignal != 0L) {
				reportDateBetween = ((reportDateBetween == null || reportDateBetween == 0) ? 1
						: 0);
				listOrdersDTO = new ArrayList<OrdersDTO>();
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("reportDateBetween", reportDateBetween);
				return SUCCESS;
			}

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/
			if (pageIndexSignal != null && pageIndexSignal != 0L) {
				OrdersDTO orderDTO = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTO != null)
					orderDTO.setCssStyle("");
				OrdersDTO orderPageSelected = listIndexSet.get(indexList);
				orderPageSelected
						.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
				indexSet = orderPageSelected.getIndex() - 1;
				indexSet = indexSet * PAGE_ITEMS_COUNT;
				session.setAttribute("indexSet", indexSet);
				session.setAttribute("listIndexSet", listIndexSet);
				session.setAttribute("orderPageSelected", orderPageSelected);
			}

			/*----------------- When Admin Click on the nextListPages ------------------------------
						recreate listIndexSet started with index>index+10 and indexSet>indexSet+10
			 ---------------------------------------------------------------------------------------*/
			if (nextListPagesSignal != null && nextListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				OrdersDTO orderDTO = listIndexSet.get(listIndexSet.size() - 1);
				if (orderDTO != null)
					nextListPages = orderDTO.getIndex() + 1;
				Long totalOrders = orderService.getCountOrders(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status);
				String strcount = totalOrders.toString();
				Integer sizeList = Integer.parseInt(strcount)
						/ PAGE_ITEMS_COUNT;
				if (nextListPages <= sizeList + 1) {
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = nextListPages; i <= sizeList + 1
							&& i <= nextListPages + 10; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					if (nextListPages <= sizeList + 1) {
						indexSet = nextListPages - 1;
						OrdersDTO orderPageSelected = listIndexSet.get(0);
						orderPageSelected
								.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
						indexSet = indexSet * PAGE_ITEMS_COUNT;
						session.setAttribute("indexSet", indexSet);
						session.setAttribute("nextListPages", nextListPages);
						session.setAttribute("listIndexSet", listIndexSet);
						session.setAttribute("orderPageSelected",
								orderPageSelected);
					}
				}
			}

			/*----------------- When Admin Click on the previousListPages --------------------------
					recreate listIndexSet started with index< index-10 and indexSet<indexSet-10
			 ---------------------------------------------------------------------------------------*/
			if (prevListPagesSignal != null && prevListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				nextListPages = (Integer) session.getAttribute("nextListPages");
				if (nextListPages != null && nextListPages >= 11) {
					prevListPages = nextListPages - 11;
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = prevListPages; i < nextListPages; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					indexSet = prevListPages - 1;
					OrdersDTO orderPageSelected = listIndexSet.get(0);
					orderPageSelected
							.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
					indexSet = indexSet * PAGE_ITEMS_COUNT;
					nextListPages = prevListPages;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("indexSet", indexSet);
					session.setAttribute("listIndexSet", listIndexSet);
					session.setAttribute("orderPageSelected", orderPageSelected);
				}
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			hashProvinces = (Hashtable<String, ProvinceDTO>) session
					.getAttribute("hashProvinces");
			if (hashProvinces == null) {
				listProvinces = productService.getAllProvinces();
				Hashtable<String, ProvinceDTO> hashProvinces = new Hashtable<String, ProvinceDTO>();
				for (ProvinceDTO prov : listProvinces) {
					hashProvinces.put(prov.getCode(), prov);
				}
				session.setAttribute("hashProvinces", hashProvinces);
			}
			if (code != null && !code.equals("") && listOrdersDTO != null) {
				ProvinceDTO provinceDTO = hashProvinces.get(code);
				if (provinceDTO != null) {
					clientProvince = provinceDTO.getCode();
				}
			}// else listCities=new ArrayList<CityDTO>();
			if (listOrdersDTO != null && indexOrder != -1) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit != null) {
					orderToEdit.setClientProvince(code);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				}
			}

			/*------------------------------- Refresh listOrdersDTO------------------------------------
						Refresh listOrders before generation of invoiced orders XLS file 
				 ------------------------------------------------------------------------------------------*/
			invoicedOrdersRefresh = (Long) session
					.getAttribute("invoicedOrdersRefresh");
			if (invoicedOrdersRefresh != null && invoicedOrdersRefresh != 0L) {
				listIndexColumn = (ArrayList<Integer>) session
						.getAttribute("listIndexColumn");
				if (listIndexColumn == null)
					listIndexColumn = getNewListIndexColumn();
				lsOrderId = lsOrderId.toUpperCase();
				//Searching Functionality 
				
				//Create new object or Order to modify the search functinality
				OrdersDTO orderDTO=new OrdersDTO();
				orderDTO.setLsOrderId(lsOrderId);
				orderDTO.setUserLogin(userLogin);
				orderDTO.setStatus(newStatus);
				orderDTO.setProductOrderNumber(productOrderNumberSearch);
				orderDTO.setClientOrderNumber(clientOrderNumber);
				orderDTO.setClientOtherId(clientOther);
				
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween,orderDTO,listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				indexSet = 0;
				session.setAttribute("indexSet", indexSet);
				nextListPages = 0;
				session.setAttribute("nextListPages", nextListPages);
				session.setAttribute("selectedStatus", selectedStatus);
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("invoicedOrdersRefresh", 0L);
				return SUCCESS;
			}

			/*------------ When Admin click on the Button "Delete Order" in The OrderDtailPop --------------
								show other pop to confirm Order Delete
			  ----------------------------------------------------------------------------------------------*/
			if (deleteOrderSignal != null && deleteOrderSignal != 0L) {
				message = "Attention! if you click on \"Delete Order\" you can not restore it.";
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (confirmDeleteSignal != null && confirmDeleteSignal == 0L) { // Delete
																				// Order
																				// Request
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "display:block;visibility:visible;";
				} else if (confirmDeleteSignal == 1L) { // Delete Order
														// Confirmed
					orderService.deleteOrderByLsOrderId(orderToEdit);
					// Save this operation in table operation
					OperationsDTO operationDTO = new OperationsDTO();
					User userAdmin = (User) session.getAttribute("userAdmin");
					if (userAdmin != null)
						operationDTO.setUserId(userAdmin.getId());
					operationDTO.setOperationDate(new Date());
					operationDTO.setOperationType("Delete Order");
					String dataBefore = "[PARTNER NAME:"
							+ orderToEdit.getUserLogin() + "];";
					dataBefore += " [LS_ORDER_ID:" + orderToEdit.getLsOrderId()
							+ "];";
					dataBefore += " [PRODUCT_ORDER_NUMBER:"
							+ orderToEdit.getProductOrderNumber() + "];";
					dataBefore += " [CLIENT_FIRST_NAME:"
							+ orderToEdit.getClientFirstName() + "];";
					dataBefore += " [CLIENT_LAST_NAME:"
							+ orderToEdit.getClientLastName() + "];";
					dataBefore += " [CLIENT_POSTAL_CODE:"
							+ orderToEdit.getClientPostalCode() + "];";
					dataBefore += " [LS_PRODUCT_ID:"
							+ orderToEdit.getLsProductID() + "];";
					dataBefore += " [UNIT_PRICE:" + orderToEdit.getUnitPrice()
							+ "];";
					dataBefore += " [STATUS:" + orderToEdit.getStatus() + "];";
					operationDTO.setDataBefore(dataBefore);
					operationDTO.setDataBefore(operationDTO.getDataBefore());
					operationDTO.setDataAfter("");
					operationsService.insertOperation(operationDTO);
					// Remove order from the list orders
					listOrdersDTO.remove(orderToEdit);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					showOrderDetailPop = "visibility:hidden;display:none;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
					// initialize index orders
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				} else { // Cancel Order Delete
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
				}
				return SUCCESS;
			}

			/*------ When Admin click the "Edit link" in the Order Table for Edit NOTE -----
							show only field Edit Note
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showOnlyEditNote != null && showOnlyEditNote != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowOnlyEditNote(0L);
					order.setCssRow("");
				}
				orderToEdit.setShowOnlyEditNote(1L);
				orderToEdit.setCssRow("background-color:#FF9966;");
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (ArrayList<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save Edit Note in the Orders Table" ----------
													save Only  notes
			  -------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOnlyNoteSignal != null && saveOnlyNoteSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						orderToEdit.setNotes(notes);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						orderToEdit.setCssRow("");
						// Save Note
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click the "Edit link" in the Order Table -------------
								show fields to edit shipping parameters
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showRowShipping != null && showRowShipping != 0L) {

				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowRowShipping(0L);
					order.setCssRow("");
				}
				// only Admins who has Active = true of action name='All' can
				// change shipping settings
				// of orders shipped or invoiced
				if (usersPrivChangeShippedStatus == null
						&& orderToEdit.getStatus() != null
						&& (orderToEdit.getStatus().equals("shipped") || orderToEdit
								.getStatus().equals("invoiced"))) {
					showRowShipping = 0L;
					return SUCCESS;
				}

				if (orderToEdit != null) {
					orderToEdit.setShowRowShipping(1L);
					orderToEdit.setShowOnlyEditNote(1L);
					orderToEdit.setCssRow("background-color:#FF9966;");
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (ArrayList<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				if (orderToEdit.getStatus().equals("open")) {
					statusId = 0L;
				} else if (orderToEdit.getStatus().equals("progress")) {
					statusId = 1L;
				} else if (orderToEdit.getStatus().equals("shipped")) {
					statusId = 2L;
				} else if (orderToEdit.getStatus().equals("invoiced")) {
					statusId = 3L;
				} else if (orderToEdit.getStatus().equals("canceled")) {
					statusId = 4L;
				}
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save in the Orders Table" ----------
							save all shipping parameters and notes
			 ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveShippingSignal != null && saveShippingSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						Date shippedDateToEdit = null;
						frm = new SimpleDateFormat("dd/MM/yyyy");
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))) {
							strShippedDate = strShippedDate.replaceAll(" ", "");
							try {
								Date date = frm.parse(strShippedDate);
								shippedDateToEdit = date;
							} catch (Exception pe) {
								shippedDateToEdit = null;
							}
						}
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))
								&& strShippedDate.length() <= 8)
							shippedDateToEdit = orderToEdit.getShippedDate();
						Double shippingPrice = null;
						// Double currencyShippingPrice=null;
						if (strShippingPrice != null
								&& !strShippingPrice.equals("")) {
							strShippingPrice = strShippingPrice.replaceAll(" ",
									"");
							int index = strShippingPrice.indexOf(",");
							if (index >= 0) {
								String strUnitPrice1 = strShippingPrice
										.substring(0, index);
								String strUnitPrice2 = strShippingPrice
										.substring(index + 1,
												strShippingPrice.length());
								strShippingPrice = strUnitPrice1 + "."
										+ strUnitPrice2;
							}

							try {
								shippingPrice = Double
										.parseDouble(strShippingPrice);
								/*
								 * if(shippingPrice!=null &&
								 * orderToEdit.getCurrencyId()!=null &&
								 * orderToEdit.getCurrencyId()!=1 &&
								 * orderToEdit.getCurrencyRate()!=null) {
								 * currencyShippingPrice = shippingPrice *
								 * orderToEdit.getCurrencyRate();
								 * currencyShippingPrice = (double)
								 * Math.round(currencyShippingPrice*100)/100; }
								 */
							} catch (Exception pe) {
								shippingPrice = null;
							}
						}

						if (trakingNumber != null)
							trakingNumber = trakingNumber.replaceAll(
									"^ +| +$|( )+", "$1");
						if (shippingCompany != null)
							shippingCompany = shippingCompany.replaceAll(
									"^ +| +$|( )+", "$1");
						orderToEdit.setShippingPrice(shippingPrice);
						// orderToEdit.setCurrencyShippingPrice(currencyShippingPrice);
						// orderToEdit.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
						orderToEdit.setShippedDate(shippedDateToEdit);
						orderToEdit.setNotes(notes);
						if (newStatus != null && !newStatus.equals(""))
							orderToEdit.setStatus(newStatus);
						orderToEdit.setShippingCompany(shippingCompany);
						orderToEdit.setTrackingNumber(trakingNumber);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						OrdersRows row = orderToEdit.getRowsList().get(0);
						row.setShippingPrice(shippingPrice);
						row.setShippingCompany(shippingCompany);
						row.setTrackingNumber(trakingNumber);
						orderToEdit.setCssRow("");

						if (newStatus != null && !newStatus.equals("")) { // if
																			// admin
																			// click
																			// on
																			// the
																			// save
																			// behind
																			// status
							orderService.updateStatusByLsOrderId(
									orderToEdit.getLsOrderId(), newStatus);
							orderToEdit.setStatus(newStatus);
							if (!newStatus.equals("shipped")
									&& !newStatus.equals("invoiced")
									&& !newStatus.equals("canceled")) {
								orderToEdit.setShippingPrice(null);
								orderToEdit.setTrackingNumber(null);
								orderToEdit.setShippedDate(null);
							}

						} else {// if admin click on the save other than Status
							if (orderToEdit.getShippedDate() != null
									&& orderToEdit.getTrackingNumber() != null
									&& !orderToEdit.getTrackingNumber().equals(
											"")
									&& orderToEdit.getShippingCompany() != null
									&& !orderToEdit.getShippingCompany()
											.equals("")
									&& orderToEdit.getShippingPrice() != null
									&& orderToEdit.getStatus() != null) {
								if (orderToEdit.getStatus().equals("open")
										|| orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"shipped");
									orderToEdit.setStatus("shipped");
								}
							} else {
								if (usersPrivChangeShippedStatus != null
										&& !orderToEdit.getStatus().equals(
												"open")
										&& !orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"progress");
									orderToEdit.setStatus("progress");
								}
							}
						}
						// if admin click on the save other then status(save
						// notes, save shipping company ...)
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click on icon findOrders.png ----------
								check user and complete infos client
			 ----------------------------------------------------------------*/
			if (findOrdersSignal != null
					&& findOrdersSignal != 0L
					|| (pageIndexSignal != null && pageIndexSignal != 0L)
					|| (nextListPagesSignal != null && nextListPagesSignal != 0L)
					|| (prevListPagesSignal != null && prevListPagesSignal != 0L)) {
				// session.setAttribute("allOrdersSelectedSignal",0L);
				// if admin click on search icon initialize checkBoxItem to
				// false
				if (findOrdersSignal != null && findOrdersSignal != 0L) {
					session.setAttribute("allOrdersSelectedSignal", 0L);
					checkBoxItem = false;
					session.setAttribute("checkBoxItem", checkBoxItem);
					indexSet = 0;
					session.setAttribute("indexSet", indexSet);
					nextListPages = 0;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("selectedStatus", selectedStatus);

				}
				// if admin navigate on pages keep the previous sorting
				if (((pageIndexSignal != null && pageIndexSignal != 0L)
						|| (nextListPagesSignal != null && nextListPagesSignal != 0L) || (prevListPagesSignal != null && prevListPagesSignal != 0L))) {
					listIndexColumn = (ArrayList<Integer>) session
							.getAttribute("listIndexColumn");
					if (listIndexColumn == null)
						listIndexColumn = getNewListIndexColumn();
				} else { // prepare new sorting
					listIndexColumn = getNewListIndexColumn();
				}

				lsOrderId = lsOrderId.toUpperCase();
				// if(findOrdersSignal!=null &&
				// findOrdersSignal!=0L)initalizeListIndexSet(session,orderService
				// );
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);

				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("sizeResult", sizeResult);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				return SUCCESS;
			}

			/*------------ When Admin click on the icon sorting of column ----------
							seach result with option of sorting list
			 -----------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& sortingOrdersSignal != null && sortingOrdersSignal != 0L) {
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				asc = (asc == 1 ? -1 : 1);
				int nextElement = listIndexColumn.get(0);
				fieldForSorting = asc * fieldForSorting;
				listIndexColumn.set(0, fieldForSorting);
				for (int i = 1; i < listIndexColumn.size(); i++) {
					int element = listIndexColumn.get(i);
					listIndexColumn.set(i, nextElement);
					nextElement = element;
				}
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				int balance = 0;
				int OrderIndex = 0;
				for (OrdersDTO orDTO : listOrdersDTO) {
					balance = (balance == 1 ? 0 : 1);
					if (balance == 1) {
						orDTO.setCssStyle("background-color: rgb(245,249,252);border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					} else {
						orDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					}
					orDTO.setIndex(OrderIndex);
					OrderIndex++;
				}
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("asc", asc);
				return SUCCESS;
			}

			/*------ when Admin click on the lsOrder link in table -----------
					show popup detail and allow admin to update Order
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& editOrderSignal != null && editOrderSignal != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit == null)
					orderToEdit = new OrdersDTO();
				if (orderToEdit.getProductOrderDate() == null)
					strProductOrderDate = "";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*--- when Admin click on the cancel Button of orderDetailPop ---
					we mast just hide popup OrderDetail
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& cancelSignal != null && cancelSignal != 0L) {
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}

			/*-------------------- When Admin left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& checkProductPriceSignal != null
					&& checkProductPriceSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToUpadate = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				UserProductPriceDTO userProductPrice = productService
						.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if (userProductPrice == null) {
					orderRowToUpadate.setCss("background-color:red;");
					orderRowToUpadate.setProductDescription("");
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				} else {
					Double usrPrice = orderRowToUpadate.getUnitPrice();
					if (usrPrice == null)
						usrPrice = 0D;
					if (usrPrice < userProductPrice.getPriceNum()) {
						orderRowToUpadate.setCssPrice("background-color:red;");
					}
					orderRowToUpadate.setProductDescription(userProductPrice
							.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice
							.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice
							.getLsProductId());
					orderRowToUpadate
							.setLsPrice(userProductPrice.getPriceNum());
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = orderDTOToUpdate;
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*----------------- When Admin check on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveTemporaryRowSignal != null
					&& saveTemporaryRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToSaveMemory = orderDTOToUpdate
						.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if (orderRowToSaveMemory != null) {
					orderRowToSaveMemory.setQuantity(quantity);
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory
							.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory
							.setCssPrice("background-color:#FF6666;");
					orderRowToSaveMemory
							.setCssQuantity("background-color:#FF6666;");
					if (quantity != null && quantity > 0D)
						orderRowToSaveMemory.setCssQuantity("");
					if (unitPrice != null
							&& orderRowToSaveMemory.getLsPrice() != null
							&& unitPrice >= orderRowToSaveMemory.getLsPrice())
						orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trakingNumber);
					if (orderRowToSaveMemory.getCurrencyId() != null
							&& orderRowToSaveMemory.getCurrencyId() != 1
							&& orderRowToSaveMemory.getCurrencyRate() != null) {
						if (unitPrice != null) {
							orderRowToSaveMemory
									.setCurrencyUnitPrice(unitPrice);
							unitPrice = unitPrice
									/ orderRowToSaveMemory.getCurrencyRate();
							unitPrice = (double) Math.round(unitPrice * 100) / 100;
							orderRowToSaveMemory.setUnitPrice(unitPrice);
						}
						/*
						 * if(shippingFee!=null) {
						 * orderRowToSaveMemory.setCurrencyShippingPrice
						 * (shippingFee); shippingFee =
						 * shippingFee/orderRowToSaveMemory.getCurrencyRate();
						 * shippingFee = (double)
						 * Math.round(shippingFee*100)/100;
						 * orderRowToSaveMemory.setShippingPrice(shippingFee); }
						 */
					}
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				// Change totalPrice also
				if (orderToEdit.getRowsList().get(0) != null
						&& orderToEdit.getRowsList().get(0).getQuantity() != null
						&& orderToEdit.getRowsList().get(0)
								.getQuantityToSplit() != null
						&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
					Double priceTotal = orderToEdit.getRowsList().get(0)
							.getUnitPrice()
							* orderToEdit.getRowsList().get(0)
									.getQuantityToSplit();
					priceTotal = (double) Math.round(priceTotal * 100) / 100;
					orderToEdit.setTotalPrice(priceTotal);
				}
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------- When Admin click on addSimilarRow Icon on the OrderDetailPop --------
								Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& addSimilarRowSignal != null && addSimilarRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				// generate lsOrderId to new order
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				if (orderRowToClone != null) {
					if (!orderRowToClone.getIcon().equals(
							"images/orders/itemValidated.png")) {
						orderRowToClone.setQuantity(quantity);
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone
								.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trakingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd = DTOFactory
							.getOrderRowClone(orderRowToClone);
					orderRowToAdd.setId(-1L);
					// Add currencyId
					if (orderRowToClone.getCurrencyId() != null)
						orderRowToAdd.setCurrencyId(orderRowToClone
								.getCurrencyId());

					orderDTOToUpdate.getRowsList().add(indexRow + 1,
							orderRowToAdd);
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------- When Admin click on Delete Row Icon of orderDetail Popup-----------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& deleteRowSignal != null && deleteRowSignal != 0L) {
				OrdersDTO orderDTO = listOrdersDTO.get(indexOrder);
				orderDTO = fillDataOrderDTO(orderDTO);
				int nb = orderService.nbOrderRowsNotDeleted(orderDTO
						.getRowsList());
				if (orderDTO != null && orderDTO.getRowsList().size() > 1) {
					for (int i = 0; i < orderDTO.getRowsList().size(); i++) {
						if (i == indexRow && nb > 1) {
							orderDTO.getRowsList().get(i).setToDelete(1);
							break;
						}
					}
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ when Admin click on the button save of orderDetail ------------------
					 save order and hide pup  
			  ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOrdersSignal != null && saveOrdersSignal != 0L) {
				session.setAttribute("orderNotSavedAtFirst", null);
				orderToEdit = listOrdersDTO.get(indexOrder);
				orderToEdit = fillDataOrderDTO(orderToEdit);

				// add special handling shipping
				User user = null;
				if (orderToEdit.getUserLogin() != null)
					user = userService.getUserByLogin(orderToEdit
							.getUserLogin());
				if (user != null) {
					Double totalPrice = null;
					orderToEdit.setSpecialHandlingName(user
							.getSpecialHandlingName());
					orderToEdit.setSpecialHandlingFee(user
							.getSpecialHandlingFee());
					if (orderToEdit.getRowsList().get(0).getQuantity() != null
							&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
						totalPrice = orderToEdit.getRowsList().get(0)
								.getQuantity()
								* orderToEdit.getRowsList().get(0)
										.getUnitPrice();
						totalPrice = (double) Math.round(totalPrice * 100) / 100;
					}

					orderToEdit.setTotalPrice(totalPrice);
				}

				orderService.updateOrderByLsOrderId(orderToEdit);
				for (OrdersRows row : orderToEdit.getRowsList()) {
					if (row.getId() == -1)
						row.setId(0L);
				}
				OrdersRows row = orderToEdit.getRowsList().get(0);
				if (row != null) {
					orderToEdit.getShippedDate();
					orderToEdit.setLsPrice(row.getLsPrice());
					orderToEdit.setLsProductID(row.getLsProductID());
					orderToEdit.setProductDescription(row
							.getProductDescription());
					orderToEdit.setQuantity(row.getQuantity());
				}
				orderToEdit = DTOFactory.getOrderDTOConsideredMissingInfo(
						orderToEdit, hashProvinces);
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				message = "Saving has completed successfuly";
				showSaveSuccessPop = "display:block;visibility:visible;";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ When user change Quantity to split in orderDetailPop -----------
					 prepare order to split from two other orders witch
				 	 one must have a lsOrder with underscore 
			 ------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& quantityToChangeSignal != null
					&& quantityToChangeSignal != 0L) {
				OrdersDTO orderToChangeQt = listOrdersDTO.get(indexOrder);
				OrdersRows orderRow = orderToChangeQt.getRowsList().get(
						indexRow);
				orderToChangeQt = fillDataOrderDTO(orderToChangeQt);
				if (quantityToChange < orderRow.getQuantity())
					orderRow.setQuantityToSplit(quantityToChange);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- Duplicate Order ----------------------------------------
							Create order in just in memory
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& duplicateOrderSignal != null
					&& duplicateOrderSignal != 0L) {
				OrdersDTO orderToClone = listOrdersDTO.get(indexOrder);
				orderToClone = fillDataOrderDTO(orderToClone);
				hashOrders = new Hashtable<String, OrdersDTO>();
				for (OrdersDTO ord : listOrdersDTO) {
					hashOrders.put(ord.getLsOrderId(), ord);
				}
				OrdersDTO orderClone = DTOFactory
						.getOrderDTOSplitted(orderToClone);
				if (orderClone != null) {
					orderClone.setDuplicate(true);
					String lsOrder = orderClone.getLsOrderId();
					String strlsOrder = orderService.generateLsOrderId(lsOrder,
							hashOrders);
					orderClone.setLsOrderId(strlsOrder);// rgb(116,180,209)
					orderClone
							.setCssStyle("background-color:#FFFF99;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					orderToEdit = orderClone;
					orderToEdit.setBackgroundColor("background-color:#FFFF99;");
					listOrdersDTO.add(indexOrder + 1, orderClone);
					indexOrder = 0;
					for (OrdersDTO ord : listOrdersDTO) {
						ord.setIndex(indexOrder);
						indexOrder++;
					}
					orderService.updateOrderByLsOrderId(orderToClone);
					orderService.insertOrderWithRows(orderClone);
					orderClone.setDuplicate(false);
					for (OrdersRows row : orderClone.getRowsList()) {
						if (row.getId() < 0L)
							row.setId(0L);
					}
					if (listOrdersDTO.size() > 0) {
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				} else
					orderToEdit = orderToClone;
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& okSaveSuccessPopSignal != null
					&& okSaveSuccessPopSignal != 0L) {
				showSaveSuccessPop = "visibility:hidden;display:none;";
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}

	/*
	 * ==========================================================================
	 * =============== fill all fields of order without rows
	 * ====================
	 * =====================================================================
	 */
	public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO) {
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		orderDTO.setClientLastName(clientLastName);
		orderDTO.setClientFirstName(clientFirstName);
		orderDTO.setClientOtherNames(clientOtherNames);
		orderDTO.setClientStreet(clientStreet);
		orderDTO.setClientOtherStreet(clientOtherStreet);
		orderDTO.setClientCity(clientCity);
		orderDTO.setClientProvince(code);
		orderDTO.setClientPostalCode(clientPostalCode);
		orderDTO.setClientPhone(clientPhone);
		orderDTO.setClientEmail(clientEmail);
		orderDTO.setProductOrderNumber(productOrderNumberSearch);
		orderDTO.setCompanyHeader(companyHeader);
		if (((strProductOrderDate) != null)
				&& (!"".equals(strProductOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strProductOrderDate);
				orderDTO.setProductOrderDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strCreationOrderDate) != null)
				&& (!"".equals(strCreationOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strCreationOrderDate);
				orderDTO.setCreationDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strRequiredDate) != null) && (!"".equals(strRequiredDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strRequiredDate);
				orderDTO.setRequiredDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}
		return orderDTO;
	}

	/*
	 * ==========================================================================
	 * =============== initialize ListIndexSet
	 * ==================================
	 * =======================================================
	 */
	public void initalizeListIndexSet(HttpSession session,
			OrdersService orderService) throws ServiceException {
		listIndexSet = new ArrayList<OrdersDTO>();
		totalOrders = orderService.getCountOrders(creationDateStartArg,
				creationDateEndArg, reportDateBetween, userLogin, lsOrderId,
				status);
		String strcount = totalOrders.toString();
		Integer sizeList = Integer.parseInt(strcount) / PAGE_ITEMS_COUNT;
		nextListPages = 1;
		session.setAttribute("nextListPages", nextListPages);
		for (int i = 1; i <= sizeList + 1 && i <= 11; i++) {
			OrdersDTO ord = new OrdersDTO();
			ord.setCssStyle("");
			ord.setIndex(i);
			listIndexSet.add(ord);
		}
		indexSet = 0;
		session.setAttribute("indexSet", indexSet);
		session.setAttribute("totalOrders", totalOrders);
		session.setAttribute("listIndexSet", listIndexSet);

	}

	/*
	 * ==========================================================================
	 * =============== initialize listIndexColumn
	 * ================================
	 * =========================================================
	 */
	List<Integer> getNewListIndexColumn() {
		List<Integer> reult = new ArrayList<Integer>();
		for (int i = 0; i <= 34; i++) {
			if (i != 2 && i <= 13) {
				reult.add(i);
				if (i != 0)
					reult.add(-i);
			}
			if (i == 30 || i == 31 || i == 34) {
				reult.add(i);
				reult.add(-i);
			}
		}
		return reult;
	}

	/*
	 * ==========================================================================
	 * =============== getStatus Selected by Admin for searching
	 * ================
	 * =========================================================================
	 */
	public String getStatusSelected(Integer StatusIndex) {
		String result = "";
		switch (StatusIndex) {
		case 0:
			result = "open";
			break;
		case 1:
			result = "progress";
			break;
		case 2:
			result = "shipped";
			break;
		case 3:
			result = "invoiced";
			break;
		case 4:
			result = "canceled";
			break;
		default:
			result = "";
		}
		return result;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:15:57.550
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.550
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.550
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:15:57.551
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:15:57.551
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:16:10.129
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class GoToOrders extends LoyautyAction {
	private static final long serialVersionUID = 2352657794009174955L;

	private UserService userService;
	private static ProductService productService;
	private static OrdersService orderService;
	private Date today;
	@Getter @Setter
	private List<OrdersDTO>listOrdersDTO;
	@Getter @Setter
	private List<User> usersList;
	@Getter @Setter
	private Long init;
	@Getter @Setter
	private Date creationDate ;
	@Getter @Setter
	private Date creationDateStart ;
	@Getter @Setter
	List<ProvinceDTO>listProvinces;
	@Getter @Setter
	private Integer reportDateBetween;
	@Getter @Setter
	private Integer invoicingDateBetween;
	@Getter @Setter 
	private String  code;

	private static int USER_TYPE = 2;

	public  GoToOrders() throws ServiceLocatorException {
		super();	
		userService = getServiceLocator().getUserService();
		productService = getServiceLocator().getProductService();
		orderService = getServiceLocator().getOrderService();
		today=new Date();
		usersList=new ArrayList<User>();
		listOrdersDTO=new ArrayList<OrdersDTO>();
	}
	/*=========================================================================================
											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		
		System.out.println("I am at Handeling Page");

		try {
			HttpSession session = request.getSession(true);
			listProvinces=productService.getAllProvinces();
			session.setAttribute("reportDateBetween",0);
			session.setAttribute("invoicingDateBetween",0);
			session.setAttribute("indexSet",0);  
			session.setAttribute("nextListPages",0);
			session.setAttribute("checkBoxItem",false);
			session.setAttribute("invoicedOrdersRefresh",0L);
			new ReportOrders().initalizeListIndexSet(session, orderService);
			session.setAttribute("totalInvoicedOrders",0L);
			session.setAttribute("totalOrders",0L);
			Hashtable<String, ProvinceDTO> hashProvinces=new Hashtable<String, ProvinceDTO>();
			for(ProvinceDTO prov:listProvinces){
				hashProvinces.put(prov.getCode(), prov);
			}
			session.setAttribute("hashProvinces",hashProvinces);
			//------------------ recovery users list ---------------------------
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession=(List<User>)session.getAttribute("usersListSession");
			if(usersListSession==null){
				List<UserSessionDTO> listAllUsers= userService.getAllUsers(basicUserDTO);
				for(UserSessionDTO userDTO:listAllUsers){
					User user=new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession",usersList);
			}else usersList=usersListSession;
			session.setAttribute("listOrdersDTOMan",null);
			session.setAttribute("listOrdersDTOAuto",null);
			if(init!=null && init!=0){
				int call=Integer.parseInt(init.toString());
				switch (call) {
				case 1:
					SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
					String lsOrderIdFirstPart="Man"+sdf.format(today);
					String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
					OrdersDTO orderDTO=new OrdersDTO();
					orderDTO.setLsOrderId(manLsOrderId);
					orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					OrdersRows orderRow=new OrdersRows();
					orderRow.setIcon("images/orders/itemNotValidated.png");
					orderDTO.getRowsList().add(orderRow);
					listOrdersDTO.add(orderDTO);
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					break;
				case 2:
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}


}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:16:10.130
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.CityDTO;
import com.loyauty.service.core.dto.CurrencyDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;


public class CreateOrdersManual extends LoyautyAction {
	private static final long serialVersionUID = -1238269595572206024L;

	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	@Getter @Setter
	private String userLogin;
	@Getter @Setter
	private Long userId;
	@Getter @Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter @Setter
	private File orderFile;
	@Getter @Setter
	List<OrdersDTO>listOrdersDTO;
	Hashtable<String, OrdersDTO>hashOrders;
	@Getter @Setter
	private String orderSelected;
	@Getter @Setter
	private Long saveOrdersSignal;
	@Getter @Setter
	private Long confirmSaveOrdersSignal;
	@Getter @Setter
	private String lsOrderId;
	@Getter @Setter
	private String message;
	@Getter @Setter
	Integer indexOrder;
	@Getter @Setter
	Integer indexRow;
	@Getter @Setter
	private Long checkBoxPrintSignal;
	@Getter @Setter
	private Boolean checkBoxPrintEtem;
	@Getter @Setter
	private Boolean checkBoxPrint;
	@Getter @Setter
	private Long pageTop=0L;
	@Getter @Setter
	private Long saved;
	@Getter @Setter
	private String showNotificationPop="visibility:hidden;display:none;";
	@Getter @Setter
	private Long addOrderSignal;
	@Getter @Setter
	private Long addSimilarOrderSignal;
	@Getter @Setter
	private Long deleteOrderSignal;
	@Getter @Setter
	private Long deleteRowSignal;
	@Getter @Setter
	private Long userLoginChangedSignal;
	@Getter @Setter
	private Long saveTemporarySignal;
	@Getter @Setter
	private Long addSimilarRowSignal;
	@Getter @Setter
	private Long saveTemporaryRowSignal;
	@Getter @Setter
	private Long checkProductPriceSignal;
	@Getter @Setter
	private Long userIdFindedSignal;
	@Getter @Setter
	private String userLogo;
	//recovery Data Order
	@Getter @Setter
	private String clientLastName;
	@Getter @Setter
	private String clientFirstName;
	@Getter @Setter
	private String clientOtherNames;
	@Getter @Setter
	private String clientStreet;
	@Getter @Setter
	private String  clientOtherStreet;
	@Getter @Setter
	private String  clientCity;
	@Getter @Setter
	private String  clientProvince;
	@Getter @Setter
	private String  clientPostalCode;
	@Getter @Setter
	private String  clientPhone;
	@Getter @Setter
	private String  clientEmail;
	@Getter @Setter
	private String productOrderNumber;
	@Getter @Setter
	private String strProductOrderDate;
	@Getter @Setter
	private String strRequiredDate;
	
	//recovery data row
	@Getter @Setter
	private Double quantity ;
	@Getter @Setter
	private String lsProductID;
	@Getter @Setter
	private Double stock;
	@Getter @Setter
	private String productDescription;
	@Getter @Setter
	private Double unitPrice;
	@Getter @Setter
	private Double shippingFee;
	@Getter @Setter
	private String shippingCompany;
	@Getter @Setter
	private String trackingNumber;
	@Getter @Setter
	private String strCreationOrderDate;
	@Getter @Setter
	private Date creationOrderDate; 
	@Getter @Setter
	private String showSaveSuccessPop="visibility:hidden;display:none;";
	//showSaveSuccessPop="display:block;visibility:visible;";
	//showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter @Setter
	private Long okSaveSuccessPopSignal;
	@Getter @Setter
	private Long requirdFieldError;
	@Getter @Setter
	private Long newLsOrderIdSignal;
	@Getter @Setter
	private List<ProvinceDTO>listProvinces;
	@Getter @Setter 
	private String  code;
	//@Getter @Setter
	//private List<CityDTO>listCities;
	private Hashtable<String, ProvinceDTO>hashProvinces;
	//private Hashtable<String, CityDTO>hashCities;
	//@Getter @Setter
	//private Long provinceChangedSignal;
	private Date today ;
	
	@Getter @Setter
	private Long currencyAlertPopSignal;
	
	@Getter @Setter
	private String currencySymbol;
	
	public  CreateOrdersManual() throws ServiceLocatorException {
		super();	
		productService = getServiceLocator().getProductService();   
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		hashOrders=new Hashtable<String, OrdersDTO>();
		//listProvinces=new ArrayList<ProvinceDTO>();
		today=new Date();
	}

	/*=========================================================================================
	 											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked", "unused" })
	@Override
	public String execute() throws Exception {
		HttpSession session = request.getSession(true);
		OrdersDTO orderDTOToAdd;
		userLogo=(String)session.getAttribute("userLogo");
		requirdFieldError=(Long)session.getAttribute("requirdFieldError");
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		SimpleDateFormat frmForLsOrderId = new SimpleDateFormat("yyyyMMdd");
		OrdersDTO orderDTOToUpdate;
		String initalClient="";
		try {
			//recovery provinces
			listProvinces=(List<ProvinceDTO>)session.getAttribute("listProvinces");
			if(listProvinces==null){
				listProvinces=productService.getAllProvinces();
				session.setAttribute("listProvinces",listProvinces);
			}
			if (((strCreationOrderDate)!=null)&&(!"".equals(strCreationOrderDate))){
				try {
					creationOrderDate = frm.parse(strCreationOrderDate);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession=(List<User>)session.getAttribute("usersListSession");
			if(usersListSession==null){
				List<UserSessionDTO> listAllUsers= userService.getAllUsers(basicUserDTO);
				usersList=new ArrayList<User>();
				for(UserSessionDTO userDTO:listAllUsers){
					User user=new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession",usersList);
			}else usersList=usersListSession;


			/*-------------------- recovery orders list ------------------------------------
						displaying at least one item in the orders list if it is empty
			  -----------------------------------------------------------------------------*/
			
			if(userIdFindedSignal==null || userIdFindedSignal==0L){
				userId=(Long)session.getAttribute("userId");
				if(userId!=null){
					UserDTO userFind=userService.getUserInformation(userId);
					userLogin=userFind.getLogin();
				}
			}
			
			listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
			if(listOrdersDTO==null)listOrdersDTO =new ArrayList<OrdersDTO>();
			if(listOrdersDTO.size()==0){
				//String lsOrderIdFirstPart="Man"+frm.format(today);
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				OrdersDTO orderDTO=new OrdersDTO();
				orderDTO.setLsOrderId(manLsOrderId);
				orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
				OrdersRows orderRow=new OrdersRows();
				orderRow.setIcon("images/orders/itemNotValidated.png");
				orderDTO.getRowsList().add(orderRow);
				listOrdersDTO.add(orderDTO);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
			}else{
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				OrdersDTO ordDTO=listOrdersDTO.get(0);
				ordDTO.setLsOrderId(manLsOrderId);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			//if(provinceChangedSignal!=null && provinceChangedSignal!=0L){
				hashProvinces=(Hashtable<String, ProvinceDTO>)session.getAttribute("hashProvinces");
				if(code!=null && !code.equals("")){
					ProvinceDTO provinceDTO=hashProvinces.get(code);
					if(provinceDTO!=null){
						clientProvince=provinceDTO.getCode();
						//listCities=provinceDTO.getListCities();
					}
				}//else listCities=new ArrayList<CityDTO>();
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				orderDTOToUpdate.setClientCity(clientCity);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				//return SUCCESS;
			//}

			/*-------------------- When Admin Find User Login ---------------------------
						change all value of userid list of orders
			 -----------------------------------------------------------------------------*/
			if(userIdFindedSignal!=null && userIdFindedSignal!=0L){
				User user=userService.getUserByLogin(userLogin);
				OrdersDTO orderDTO=listOrdersDTO.get(0);
				orderDTO=fillDataOrderDTO(orderDTO);
				userLogo=null;
				userId=null;
				if(user!=null){
					orderDTO.setUserId(user.getId());
					userId=user.getId();
					currencySymbol = "CAD";
					CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
					if(currencyDTO!=null && currencyDTO.getId()!=1) {
						currencyAlertPopSignal = 1L;
						if(currencyDTO.getSymbol()!=null) currencySymbol = currencyDTO.getSymbol();
					} else currencyAlertPopSignal=0L;
					for(OrdersDTO ord:listOrdersDTO){
						ord.setUserId(user.getId());
						ord.setUserLogin(userLogin);
					}
	    			//show user logo
	    			userLogo="./images/orders/usersLogos/"+userLogin+".png";
				}else userLogin=null;

				String filePath = session.getServletContext().getRealPath("/");
				//String LogoDestination = filePath + "images/orders/usersLogos/"+userLogin+".png";
				//File f=new File(LogoDestination);
				//if(!f.exists())userId=null;

    			//if userLogo dosn't exist give him a blank logo
    			createUserLogo(filePath +"images/orders/usersLogos/BLANK.png", filePath +"images/orders/usersLogos/"+userLogin+".png");
    			
    			session.setAttribute("userLogo",userLogo);
				session.setAttribute("userId",userId);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			if(userId==null)userLogin="";

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			/*if(provinceChangedSignal!=null && provinceChangedSignal!=0L){
				hashProvinces=(Hashtable<String, ProvinceDTO>)session.getAttribute("hashProvinces");
				if(code!=null){
					listCities=hashProvinces.get(code).getListCities();
				}else listCities=new ArrayList<CityDTO>();
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				//orderDTOToUpdate.setClientCity(clientCity)
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				//return SUCCESS;
			//}*/
			
			/*----------------- When Admin check on Add Similar order Icon or save Temporary -------
									Create a copy of order selected
			 ---------------------------------------------------------------------------------------*/
			if(((addSimilarOrderSignal!=null && addSimilarOrderSignal!=0L)||(saveTemporarySignal!=null && saveTemporarySignal!=0L)) && indexOrder>=0){
				orderDTOToAdd=listOrdersDTO.get(indexOrder);
				if(orderDTOToAdd==null)orderDTOToAdd=new OrdersDTO();
				if((saveTemporarySignal!=null && saveTemporarySignal!=0L))orderDTOToAdd.setLsOrderId(lsOrderId);
				orderDTOToAdd.setCreationDate(creationOrderDate); 
				orderDTOToAdd.setClientLastName(clientLastName);
				orderDTOToAdd.setClientFirstName(clientFirstName);
				orderDTOToAdd.setClientOtherNames(clientOtherNames); 
				orderDTOToAdd.setClientStreet(clientStreet);
				orderDTOToAdd.setClientOtherStreet(clientOtherStreet);
				orderDTOToAdd.setClientCity(clientCity);
				orderDTOToAdd.setClientProvince(clientProvince);
				orderDTOToAdd.setClientProvince(clientProvince);
				orderDTOToAdd.setClientPostalCode(clientPostalCode);
				orderDTOToAdd.setClientPhone(clientPhone);
				orderDTOToAdd.setClientEmail(clientEmail);			
				orderDTOToAdd.setProductOrderNumber(productOrderNumber);
				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToAdd.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToAdd.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				User user=userService.getUserByLogin(userLogin);
				if(user!=null){
					UserDTO userDTO=userService.getUserInformation(user.getId());
					orderDTOToAdd.setUserLogin(userLogin);
					orderDTOToAdd.setUserId(userDTO.getId());
				}
				if(addSimilarOrderSignal!=null && addSimilarOrderSignal!=0L){ 
					OrdersDTO orderDTOClone = DTOFactory.getOrderDTOClone(orderDTOToAdd);
					orderDTOClone.setCssStyle("background-color:white;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					listOrdersDTO.add(orderDTOClone);
				}
				int indexOrder=0;
				for(OrdersDTO orderDTO:listOrdersDTO){
					orderDTO.setIndex(indexOrder);
					indexOrder++;
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			
			/*----------------- When Admin click on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if(saveTemporaryRowSignal!=null && saveTemporaryRowSignal!=0L){
				
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				/*
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);
				orderDTOToUpdate.setCreationDate(creationOrderDate);
				orderDTOToUpdate.setClientLastName(clientLastName);
				orderDTOToUpdate.setClientFirstName(clientFirstName);
				orderDTOToUpdate.setClientOtherNames(clientOtherNames); 
				orderDTOToUpdate.setClientStreet(clientStreet);
				orderDTOToUpdate.setClientOtherStreet(clientOtherStreet);
				orderDTOToUpdate.setClientCity(clientCity);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientPostalCode(clientPostalCode);
				orderDTOToUpdate.setClientPhone(clientPhone);
				orderDTOToUpdate.setClientEmail(clientEmail);			
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);

				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToUpdate.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToUpdate.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				*/
				OrdersRows orderRowToSaveMemory=orderDTOToUpdate.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if(orderRowToSaveMemory!=null){
					orderRowToSaveMemory.setQuantity(quantity); 
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory.setCssPrice("background-color:red;");
					if(unitPrice!=null && orderRowToSaveMemory.getLsPrice()!=null
					  && unitPrice>=orderRowToSaveMemory.getLsPrice())
					  orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trackingNumber);	
					int indexOrder=0;
					int indexRow=0;
					for(OrdersDTO orderDTO:listOrdersDTO){
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow=0;
						for(OrdersRows orderRows:orderDTO.getRowsList()){
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				}

				return SUCCESS;
			}
			
			/*-------------------- When Admin click on addSimilarRow Icon -----------------
										Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if(addSimilarRowSignal!=null && addSimilarRowSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone=orderDTOToUpdate.getRowsList().get(indexRow);
				if(orderRowToClone!=null){
					if(!orderRowToClone.getIcon().equals("images/orders/itemValidated.png")){
						orderRowToClone.setQuantity(quantity); 
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingPrice(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trackingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd=DTOFactory.getOrderRowClone(orderRowToClone);
					orderDTOToUpdate.getRowsList().add(indexRow+1,orderRowToAdd);
					int indexOrder=0;
					int indexRow=0;
					for(OrdersDTO orderDTO:listOrdersDTO){
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow=0;
						for(OrdersRows orderRows:orderDTO.getRowsList()){
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				}
				return SUCCESS;
			}

			/*-------------------- When Admin click on Delete order Icon -------------
									Delete this order using index
			 -----------------------------------------------------------------------------*/
			
			if(deleteOrderSignal!=null && deleteOrderSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				List<OrdersDTO> listOrdersDTOAfterDelete=new ArrayList<OrdersDTO>();
				for(int i=0 ;i<listOrdersDTO.size();i++){
					if(i!=indexOrder || indexOrder==0)listOrdersDTOAfterDelete.add(listOrdersDTO.get(i));
				}
				int index=0;
				for(int i=0 ;i<listOrdersDTOAfterDelete.size();i++){
					listOrdersDTOAfterDelete.get(i).setIndex(index);
					index++;
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTOAfterDelete);
				listOrdersDTO=listOrdersDTOAfterDelete;
				return SUCCESS;
			}

			/*-------------------- When Admin check on Delete Row Icon -------------------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if(deleteRowSignal!=null && deleteRowSignal!=0L){
				ArrayList<OrdersRows>listRowsAfterDelete=new ArrayList<OrdersRows>();
				OrdersDTO orderDTO=listOrdersDTO.get(indexOrder);
				orderDTO=fillDataOrderDTO(orderDTO);
				if(orderDTO!=null && orderDTO.getRowsList().size()>1){
					for(int i=0 ;i<orderDTO.getRowsList().size();i++){
						if(i!=indexRow)listRowsAfterDelete.add(orderDTO.getRowsList().get(i));
					}
					int index=0;
					for(int i=0 ;i<listRowsAfterDelete.size();i++){
						listRowsAfterDelete.get(i).setIndex(index);
						index++;
					}
					orderDTO.setRowsList(listRowsAfterDelete);
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			

			/*-------------------- When Admin check left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if(checkProductPriceSignal!=null && checkProductPriceSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				/*
				orderDTOToUpdate.setClientLastName(clientLastName);
				orderDTOToUpdate.setClientFirstName(clientFirstName);
				orderDTOToUpdate.setClientOtherNames(clientOtherNames); 
				orderDTOToUpdate.setClientStreet(clientStreet);
				orderDTOToUpdate.setClientOtherStreet(clientOtherStreet);
				orderDTOToUpdate.setClientCity(clientCity);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientPostalCode(clientPostalCode);
				orderDTOToUpdate.setClientPhone(clientPhone);
				orderDTOToUpdate.setClientEmail(clientEmail);			
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);
				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToUpdate.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToUpdate.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				*/
				OrdersRows orderRowToUpadate=orderDTOToUpdate.getRowsList().get(indexRow);
				UserProductPriceDTO userProductPrice=productService.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if(userProductPrice==null){
					lsProductID=null;
					orderRowToUpadate.setCss("background-color:red;");
					addActionError(getText("loyauty.error.common.requiredLsProductOrder"));
					orderRowToUpadate.setProductDescription(""); 
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				}else{
					Double usrPrice=orderRowToUpadate.getUnitPrice();
					if(usrPrice==null)usrPrice=0D;
					if(usrPrice < userProductPrice.getPriceNum()){
						orderRowToUpadate.setCssPrice("background-color:red;");	
					}
					orderRowToUpadate.setProductDescription(userProductPrice.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice.getLsProductId());
					orderRowToUpadate.setLsPrice(userProductPrice.getPriceNum());
					if(userProductPrice.getUserId()!=null) {
						//currency
						Long userId = userProductPrice.getUserId();
						Long currencyId = 1L;
						Double currencyRate = 1D;
						Double currencyPrice = 0D;
						CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
						if(currencyDTO!=null && currencyDTO.getRate()!=null) {
							currencyId = currencyDTO.getId();
							if(currencyId!=1) {
								currencyRate = currencyDTO.getRate();
								currencyPrice = (double) Math.round((orderRowToUpadate.getLsPrice()*currencyRate)*100) / 100;
								orderRowToUpadate.setLsPrice(currencyPrice);
							}
						}
					}
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				return SUCCESS;
			}
			
			/*-------------------------------- SAVE ORDERS -------------------------------
						save in data bases just orders witch has print checked 
	 		 -----------------------------------------------------------------------------*/
			if(saveOrdersSignal!=null && saveOrdersSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				User user=userService.getUserByLogin(userLogin);
				OrdersDTO order=listOrdersDTO.get(0);
				order.setManOrder(true);
				order=fillDataOrderDTO(order);
				if(user!=null)order.setUserId(user.getId());
				boolean productNotFond=false;
				for(OrdersRows row:order.getRowsList()){
					if(row.getLsProductID()==null || row.getLsProductID().equals("")){
						productNotFond=true;
						break;
					}
				}
				requirdFieldError=null;
				session.setAttribute("requirdFieldError",null);
				productOrderNumber=order.getProductOrderNumber().replaceAll("^ +| +$|( )+", "$1");
				clientFirstName=order.getClientFirstName().replaceAll("^ +| +$|( )+", "$1");
				clientLastName=order.getClientLastName().replaceAll("^ +| +$|( )+", "$1");
				clientStreet=order.getClientStreet().replaceAll("^ +| +$|( )+", "$1");
				clientCity=order.getClientCity().replaceAll("^ +| +$|( )+", "$1");
				clientProvince=order.getClientProvince().replaceAll("^ +| +$|( )+", "$1");
				clientPostalCode=order.getClientPostalCode().replaceAll("^ +| +$|( )+", "$1");
				
				order.setProductOrderNumber(productOrderNumber);
				order.setClientFirstName(clientFirstName);
				order.setClientLastName(clientLastName);
				order.setClientStreet(clientStreet);
				order.setClientCity(clientCity);
				order.setClientProvince(clientProvince);
				order.setClientPostalCode(clientPostalCode);
				
				if(order.getProductOrderNumber()==null || order.getProductOrderNumber().equals("")||
						   order.getLsOrderId()==null || order.getLsOrderId().equals("") ||
						   order.getCreationDate()==null || productNotFond ||
						   order.getClientFirstName()==null || order.getClientFirstName().equals("")||
						   order.getClientLastName()==null || order.getClientLastName().equals("") ||
						   order.getClientStreet()==null || order.getClientStreet().equals("") ||
						   order.getClientCity()==null || order.getClientCity().equals("") || 
						   order.getClientProvince()==null || order.getClientProvince().equals("") ||
						   order.getClientPostalCode()==null || order.getClientPostalCode().equals("")){
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					addActionError(getText("loyauty.error.common.requiredFieldOrders"));
					requirdFieldError=1L;
					session.setAttribute("requirdFieldError",1L);
					return SUCCESS;
				}
				
				for(OrdersRows row:order.getRowsList()){
					if(row.getLsProductID()==null || row.getLsProductID().equals("")||
					   row.getQuantity()==null || row.getQuantity()==0D){
						requirdFieldError=1L;
					   session.setAttribute("requirdFieldError",1L);
					   addActionError(getText("loyauty.error.common.requiredFieldOrders"));
					   return SUCCESS;
					}
				}
				//add special handling shipping	+ currency
				for(OrdersDTO orDTO:listOrdersDTO){
					if(user!=null){
						//currency
						Long userId = user.getId();
						Long currencyId = 1L;
						String currencySymbol = "CAD";
						Double currencyRate = 1D;
						Double currencyUnitPrice = 0D;
						Double currencyTotalPrice = null;
						//Double currencyShippingPrice = null;
						Double unitPrice = null;
						CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
						if(currencyDTO!=null) {
							currencyId = currencyDTO.getId();
							if(currencyDTO.getSymbol()!=null) currencySymbol = currencyDTO.getSymbol();
							if(currencyDTO.getRate()!=null) currencyRate = currencyDTO.getRate();
						}
						
						Double totalPrice=null;
						orDTO.setSpecialHandlingName(user.getSpecialHandlingName());
						orDTO.setSpecialHandlingFee(user.getSpecialHandlingFee());
						if(orDTO.getRowsList().get(0).getQuantity()!=null && orDTO.getRowsList().get(0).getUnitPrice()!=null){
							unitPrice = orDTO.getRowsList().get(0).getUnitPrice();
							totalPrice= orDTO.getRowsList().get(0).getQuantity()*unitPrice;
							totalPrice = (double) Math.round(totalPrice * 100) / 100;
							if(currencyId!=1) {
								currencyUnitPrice = unitPrice;
								unitPrice = (double) Math.round((unitPrice/currencyRate)*100) / 100;
								orDTO.setUnitPrice(unitPrice);
								orDTO.getRowsList().get(0).setUnitPrice(unitPrice);
								currencyTotalPrice = totalPrice;
								totalPrice = (double) Math.round((totalPrice/currencyRate)*100) / 100;
								/*
								if(orDTO.getRowsList().get(0).getShippingPrice()!=null) {
									currencyShippingPrice = orDTO.getRowsList().get(0).getShippingPrice();
									Double shippingPrice = (double) Math.round((currencyShippingPrice/currencyRate)*100) / 100;
									orDTO.setShippingPrice(shippingPrice);
									orDTO.setShippingFee(shippingPrice);
									orDTO.setCurrencyShippingPrice(currencyShippingPrice);
									orDTO.getRowsList().get(0).setShippingPrice(shippingPrice);
									orDTO.getRowsList().get(0).setShippingFee(shippingPrice);
									orDTO.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
								}
								*/
							}
						}
						orDTO.setTotalPrice(totalPrice);
						orDTO.setCurrencyId(currencyId);
						orDTO.setCurrencySymbol(currencySymbol);
						orDTO.setCurrencyRate(currencyRate);
						orDTO.setCurrencyUnitPrice(currencyUnitPrice);
						orDTO.setCurrencyTotalPrice(currencyTotalPrice);
						
						for(OrdersRows row: orDTO.getRowsList()){
							row.setCurrencyId(currencyId);
							row.setCurrencySymbol(currencySymbol);
							row.setCurrencyRate(currencyRate);
							row.setCurrencyUnitPrice(currencyUnitPrice);
						}
					}	
				}
				listOrdersDTO=orderService.insertListOrders(listOrdersDTO);
				listOrdersDTO=new ArrayList<OrdersDTO>();
				if(listOrdersDTO.size()==0){
					frm = new SimpleDateFormat("yyyyMMdd");
					if(userLogin!=null && userLogin.length()>=2){
						initalClient=userLogin.substring(0, 2);
						initalClient=initalClient.toUpperCase();
					}
					//String lsOrderIdFirstPart="Man"+frm.format(today);
					String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
					String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
					OrdersDTO orderDTO=new OrdersDTO();
					//recovery userId
					if(user!=null)orderDTO.setUserId(user.getId());
					orderDTO.setLsOrderId(manLsOrderId);
					orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					OrdersRows orderRow=new OrdersRows();
					orderRow.setIcon("images/orders/itemNotValidated.png");
					orderDTO.getRowsList().add(orderRow);
					listOrdersDTO.add(orderDTO);
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				}
				message="Saving has completed successfuly";
				showSaveSuccessPop="display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
	 		 -----------------------------------------------------------------------------*/
			if(checkBoxPrintSignal!=null && checkBoxPrintSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				OrdersDTO orderDTOInList=listOrdersDTO.get(indexOrder);
				orderDTOInList=fillDataOrderDTO(orderDTOInList);
				orderDTOInList.setPrint(checkBoxPrint);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}


			/*-------------- When user click on the button OK of showSaveSuccessPop -------
						just hide dialogue popup: showSaveSuccessPop
	 		 ------------------------------------------------------------------------------*/
			if(okSaveSuccessPopSignal!=null && okSaveSuccessPopSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				showSaveSuccessPop="visibility:hidden;display:none;";
				return SUCCESS;
			}



			/*-------------- When user click on the image imgNewLsOrderId -----------------
								generate other LsOrderId
	 		 ------------------------------------------------------------------------------*/
			if(newLsOrderIdSignal!=null && newLsOrderIdSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				OrdersDTO orderDTO=listOrdersDTO.get(0);
				frm = new SimpleDateFormat("yyyyMMdd");
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				//String lsOrderIdFirstPart="Man"+frm.format(today);
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				orderDTO.setLsOrderId(manLsOrderId);
				return SUCCESS;
			}

		} catch (Exception e) {
			addActionError(getText("loyauty.error.common.userNotSelected"));
			e.printStackTrace();
			return "input";
		}
	return SUCCESS;
	}
	

	   /*=========================================================================================
								fill all fields of order without rows
		 =========================================================================================*/
		public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO){
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			//orderToEdit=listOrdersDTO.get(indexOrder);
			orderDTO.setClientLastName(clientLastName);
			orderDTO.setClientFirstName(clientFirstName);
			orderDTO.setClientOtherNames(clientOtherNames); 
			orderDTO.setClientStreet(clientStreet);
			orderDTO.setClientOtherStreet(clientOtherStreet);
			orderDTO.setClientCity(clientCity);
			orderDTO.setClientProvince(clientProvince);
			orderDTO.setClientProvince(clientProvince);
			orderDTO.setClientPostalCode(clientPostalCode);
			orderDTO.setClientPhone(clientPhone);
			orderDTO.setClientEmail(clientEmail);			
			orderDTO.setProductOrderNumber(productOrderNumber);
			
			
			if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strProductOrderDate);
					orderDTO.setProductOrderDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			
			if (((strCreationOrderDate)!=null)&&(!"".equals(strCreationOrderDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationOrderDate);
					orderDTO.setCreationDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			
			if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strRequiredDate);
					orderDTO.setRequiredDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			return orderDTO;
		}


		/*=========================  createUserLogo ===========================
		 				Create  Blank User Logo if not Exist
		  =================================================================*/
		public void createUserLogo(String source, String destination) throws IOException{
			File fileLogo=new File(destination);
			if(!fileLogo.exists()){
				InputStream in = new FileInputStream(source);
				OutputStream out = new FileOutputStream(destination);
				byte[] buf = new byte[1024];
				int len;
				while ((len = in.read(buf)) > 0) {
					out.write(buf, 0, len);
				}
				in.close();
				out.close();	
			}
		}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:16:10.131
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.131
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.131
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:16:10.132
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.133
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.133
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:16:10.134
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.134
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:16:10.135
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.135
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:16:10.139
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;

import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceException;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OperationsDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.core.dto.UsersPrivilegesDTO;
import com.loyauty.service.operations.OperationsService;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class ReportOrders extends LoyautyAction {
	private static final long serialVersionUID = -3811760851445730062L;
	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	private OperationsService operationsService;
	@Getter
	@Setter
	private String userLogin;
	@Getter
	@Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter
	@Setter
	List<OrdersDTO> listOrdersDTO;
	@Getter
	@Setter
	List<OrdersDTO> listStatus;
	@Getter
	@Setter
	private String lsOrderId;
	@Getter
	@Setter
	Long poYpop;
	@Getter
	@Setter
	Long poXpop;
	@Getter
	@Setter
	private Long pageTop = 0L;
	@Getter
	@Setter
	private Date creationDate;
	@Getter
	@Setter
	private Long findOrdersSignal;
	private String status;
	@Getter
	@Setter
	private Long sizeResult = 0L;
	@Getter
	@Setter
	private Long sorting;
	@Getter
	@Setter
	private Long sortingOrdersSignal;
	@Getter
	@Setter
	private Integer fieldForSorting;
	@Getter
	@Setter
	private Integer asc;
	@Getter
	@Setter
	private Integer scrollDivRowsLeft;
	@Getter
	@Setter
	private Integer scrollPageLeft;
	@Getter
	@Setter
	private Integer scrollDivRowsTop;
	@Getter
	@Setter
	private String strCreationDateStart;
	@Getter
	@Setter
	private String strCreationDateEnd;
	@Getter
	@Setter
	private Date creationDateStart;
	@Getter
	@Setter
	private Date creationDateEnd;
	private Date creationDateStartArg;
	private Date creationDateEndArg;
	@Getter
	@Setter
	private Integer selectedStatus;
	@Getter
	@Setter
	private Long editOrderSignal;
	@Getter
	@Setter
	private Long cancelSignal;
	@Getter
	@Setter
	private Integer indexOrder;
	@Getter
	@Setter
	private OrdersDTO orderToEdit;
	@Getter
	@Setter
	private String strProductOrderDate;
	@Getter
	@Setter
	private String lsProductID;
	@Getter
	@Setter
	Integer indexRow;
	@Getter
	@Setter
	private String showOrderDetailPop;
	@Getter
	@Setter
	private Long userId;
	@Getter
	@Setter
	private Long checkProductPriceSignal;
	@Getter
	@Setter
	private Long saveTemporaryRowSignal;
	@Getter
	@Setter
	private Long addSimilarRowSignal;
	@Getter
	@Setter
	private Long deleteRowSignal;
	@Getter
	@Setter
	private Long saveOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxPrint;

	// recovery Data Order
	@Getter
	@Setter
	private String clientLastName;
	@Getter
	@Setter
	private String clientFirstName;
	@Getter
	@Setter
	private String clientOtherNames;
	@Getter
	@Setter
	private String clientStreet;
	@Getter
	@Setter
	private String clientOtherStreet;
	@Getter
	@Setter
	private String clientCity;
	@Getter
	@Setter
	private String clientProvince;
	@Getter
	@Setter
	private String clientPostalCode;
	@Getter
	@Setter
	private String clientPhone;
	@Getter
	@Setter
	private String clientEmail;
//	@Getter
//	@Setter
//	private String productOrderNumber;
	@Getter
	@Setter
	private String strRequiredDate;

	// recovery data row
	@Getter
	@Setter
	private Double quantity;
	@Getter
	@Setter
	private String notes;
	@Getter
	@Setter
	private Double quantityToChange;
	@Getter
	@Setter
	private Double stock;
	@Getter
	@Setter
	private String productDescription;
	@Getter
	@Setter
	private Double unitPrice;
	@Getter
	@Setter
	private Double shippingFee;
	@Getter
	@Setter
	private String shippingCompany;
	@Getter
	@Setter
	private String companyHeader;

	@Getter
	@Setter
	private Long quantityToChangeSignal;
	@Getter
	@Setter
	private Long duplicateOrderSignal;
	@Getter
	@Setter
	private String strCreationDate;
	@Getter
	@Setter
	private String strCreationOrderDate;
	@Getter
	@Setter
	private User usr;
	@Getter
	@Setter
	private String showSaveSuccessPop;
	// showSaveSuccessPop="display:block;visibility:visible;";
	// showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter
	@Setter
	private String message;
	@Getter
	@Setter
	private Long okSaveSuccessPopSignal;
	@Getter
	@Setter
	private Long showRowShipping;
	@Getter
	@Setter
	private Long showOnlyEditNote;
	@Getter
	@Setter
	private Long saveShippingSignal;
	@Getter
	@Setter
	private Long saveOnlyNoteSignal;
	@Getter
	@Setter
	private String code;
	@Getter
	@Setter
	private Long cityId;
	@Getter
	@Setter
	private List<ProvinceDTO> listProvinces;
	private Hashtable<String, ProvinceDTO> hashProvinces;
	@Getter
	@Setter
	private Boolean orderNotSavedAtFirst;
	@Getter
	@Setter
	private String strShippedDate;
	@Getter
	@Setter
	private String strShippingPrice;
	@Getter
	@Setter
	private String showConfirmDeleteOrderPop;
	@Getter
	@Setter
	private Long deleteOrderSignal;
	@Getter
	@Setter
	private Long confirmDeleteSignal;
	@Getter
	@Setter
	private UsersPrivilegesDTO userPrivileges;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivShippedToInvoiced;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivChangeShippedStatus;
	@Getter
	@Setter
	private HashMap<Integer, String> hashStatus;
	@Getter
	@Setter
	private Long statusId;
	@Getter
	@Setter
	private String strPrint;
	@Getter
	@Setter
	private Integer testSignal;
	@Getter
	@Setter
	private String newStatus;
	Long invoicedOrdersRefresh;
	@Getter
	@Setter
	private Integer reportDateBetween;
	@Getter
	@Setter
	private Long dateBetweenSignal;
	@Getter
	@Setter
	private Long selectAllOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxItem;
	// ------Pagination
	@Getter
	@Setter
	Long pageIndexSignal;
	@Getter
	@Setter
	Long prevListPagesSignal;
	@Getter
	@Setter
	Long nextListPagesSignal;
	@Getter
	@Setter
	Long totalOrders;
	@Getter
	@Setter
	Integer nextListPages;
	@Getter
	@Setter
	Integer prevListPages;
	@Getter
	@Setter
	Integer indexSet = 0;
	@Getter
	@Setter
	Integer indexList;
	@Getter
	@Setter
	List<OrdersDTO> listIndexSet;
	@Getter
	@Setter
	Integer PAGE_ITEMS_COUNT = 100;
	
	//New Added Field in the search option as toggle functionality
	@Getter
	@Setter
	private String productOrderNumberSearch;
	@Getter
	@Setter
	private String trakingNumber;
	@Getter
	@Setter
	private String  clientOther;
	@Getter
	@Setter
	private String	 clientOrderNumber;
	//New Added Field in the search option as toggle functionality

	// ------Pagination

	/*
	 * ==========================================================================
	 * =============== Default constructor
	 * ======================================
	 * ===================================================
	 */
	public ReportOrders() throws ServiceLocatorException {
		super();
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		productService = getServiceLocator().getProductService();
		operationsService = getServiceLocator().getOperationsService();
	}

	/*
	 * ==========================================================================
	 * =============== method execute
	 * ============================================
	 * =============================================
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		System.out.println("Product Order Number: "+ productOrderNumberSearch);
		System.out.println("Tracking Number: "+ trakingNumber);
		System.out.println("Client Order ID: "+ clientOrderNumber);
		System.out.println("Client Other ID: "+ clientOther);
		
		HttpSession session = request.getSession(true);

		if (showOrderDetailPop == null)
			showOrderDetailPop = "visibility:hidden;display:none;";
		if (showConfirmDeleteOrderPop == null)
			showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
		if (showSaveSuccessPop == null)
			showSaveSuccessPop = "visibility:hidden;display:none;";
		if (poYpop == null)
			poYpop = 100L;
		if (poXpop == null)
			poXpop = 100L;
		Hashtable<String, OrdersDTO> hashOrders;
		if (selectedStatus == null)
			selectedStatus = -1;
		sizeResult = (Long) session.getAttribute("sizeResult");
		totalOrders = (Long) session.getAttribute("totalOrders");
		if (totalOrders == null)
			totalOrders = 0L;
		asc = (Integer) session.getAttribute("asc");
		if (asc == null)
			asc = 0;
		if (sizeResult == null)
			sizeResult = 0L;
		if (indexOrder == null)
			indexOrder = 0;
		userPrivileges = (UsersPrivilegesDTO) session.getAttribute("userPrivileges");
		usersPrivShippedToInvoiced = (UsersPrivilegesDTO) session.getAttribute("usersPrivShippedToInvoiced");
		usersPrivChangeShippedStatus = (UsersPrivilegesDTO) session
				.getAttribute("usersPrivChangeShippedStatus");
		hashStatus = (HashMap<Integer, String>) session
				.getAttribute("hashStatus");
		if (hashStatus == null) {
			hashStatus = new HashMap<Integer, String>();
			hashStatus.put(0, "");
			hashStatus.put(1, "open");
			hashStatus.put(2, "progress");
		}
		List<Integer> listIndexColumn = new ArrayList<Integer>();
		// fill list status
		listStatus = (ArrayList<OrdersDTO>) session.getAttribute("listStatus");
		if (listStatus == null) {
			listStatus = new ArrayList<OrdersDTO>();
			OrdersDTO orderDTOOpen = new OrdersDTO();
			orderDTOOpen.setStatus("open");
			orderDTOOpen.setId(0L);
			listStatus.add(orderDTOOpen);
			OrdersDTO orderDTOProgress = new OrdersDTO();
			orderDTOProgress.setStatus("progress");
			orderDTOProgress.setId(1L);
			listStatus.add(orderDTOProgress);
			if (usersPrivChangeShippedStatus != null) {
				OrdersDTO orderDTOShipped = new OrdersDTO();
				orderDTOShipped.setStatus("shipped");
				orderDTOShipped.setId(2L);
				listStatus.add(orderDTOShipped);
			}

		}

		try {

			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			// recovery provinces
			listProvinces = (List<ProvinceDTO>) session
					.getAttribute("listProvinces");
			if (listProvinces == null)
				listProvinces = productService.getAllProvinces();
			orderNotSavedAtFirst = (Boolean) session
					.getAttribute("listNotSavedAtFirst");
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession = (List<User>) session
					.getAttribute("usersListSession");
			if (usersListSession == null) {
				List<UserSessionDTO> listAllUsers = userService
						.getAllUsers(basicUserDTO);
				usersList = new ArrayList<User>();
				for (UserSessionDTO userDTO : listAllUsers) {
					User user = new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession", usersList);
			} else
				usersList = usersListSession;
			listOrdersDTO = (ArrayList<OrdersDTO>) session
					.getAttribute("listOrdersDTOReport");
			reportDateBetween = (Integer) session
					.getAttribute("reportDateBetween");
			if (reportDateBetween == null) {
				reportDateBetween = 0;
				session.setAttribute("reportDateBetween", reportDateBetween);
			}

			/*------ always check if the Admin select all orders ------------
					if The Admin select all orders change checkBoxItem value 
			  ---------------------------------------------------------------*/
			if (selectAllOrdersSignal != null && selectAllOrdersSignal != 0L) {
				if (checkBoxItem != null) {
					session.setAttribute("checkBoxItem", checkBoxItem);
					session.setAttribute("allOrdersSelectedSignal", 0L);
					if (checkBoxItem)
						session.setAttribute("allOrdersSelectedSignal", 1L);
				}
			}
			checkBoxItem = (Boolean) session.getAttribute("checkBoxItem");
			if (checkBoxItem == null)
				checkBoxItem = false;
			/*------ always recovery creationDate from strCreationDate ------
						always keep the user search options
			  ---------------------------------------------------------------*/
			creationDateStart = null;
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			if (((strCreationDateStart) != null)
					&& (!"".equals(strCreationDateStart))) {
				try {
					Date date = frm.parse(strCreationDateStart);
					creationDateStart = date;
					creationDateStartArg = date;
				} catch (Exception pe) {
					creationDateStart = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateStart == null) {
				Date date = frm.parse("01/01/1900");
				creationDateStartArg = date;
			}
			creationDateEnd = null;
			if (((strCreationDateEnd) != null)
					&& (!"".equals(strCreationDateEnd))) {
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationDateEnd);
					creationDateEnd = date;
					creationDateEndArg = date;
				} catch (Exception pe) {
					creationDateEnd = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateEnd == null) {
				creationDateEndArg = new Date();
			}

			/*------ always recovery Status from selectedStatus key ------
						always keep the status search options
			  ---------------------------------------------------------------*/
			status = getStatusSelected(selectedStatus);

			/*----------- always initialized listPages if not done ----------
				   		    and check if is there next listPages
			  ---------------------------------------------------------------*/
			nextListPages = (Integer) session.getAttribute("nextListPages");
			if (nextListPages == null)
				nextListPages = 0;
			if (indexSet == null || indexSet == -1) {
				indexSet = (Integer) session.getAttribute("indexSet");
				if (indexSet == null)
					indexSet = 0;
			}
			listIndexSet = (List<OrdersDTO>) session
					.getAttribute("listIndexSet");
			if (listIndexSet == null)
				initalizeListIndexSet(session, orderService);

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/

			if (dateBetweenSignal != null && dateBetweenSignal != 0L) {
				reportDateBetween = ((reportDateBetween == null || reportDateBetween == 0) ? 1
						: 0);
				listOrdersDTO = new ArrayList<OrdersDTO>();
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("reportDateBetween", reportDateBetween);
				return SUCCESS;
			}

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/
			if (pageIndexSignal != null && pageIndexSignal != 0L) {
				OrdersDTO orderDTO = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTO != null)
					orderDTO.setCssStyle("");
				OrdersDTO orderPageSelected = listIndexSet.get(indexList);
				orderPageSelected
						.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
				indexSet = orderPageSelected.getIndex() - 1;
				indexSet = indexSet * PAGE_ITEMS_COUNT;
				session.setAttribute("indexSet", indexSet);
				session.setAttribute("listIndexSet", listIndexSet);
				session.setAttribute("orderPageSelected", orderPageSelected);
			}

			/*----------------- When Admin Click on the nextListPages ------------------------------
						recreate listIndexSet started with index>index+10 and indexSet>indexSet+10
			 ---------------------------------------------------------------------------------------*/
			if (nextListPagesSignal != null && nextListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				OrdersDTO orderDTO = listIndexSet.get(listIndexSet.size() - 1);
				if (orderDTO != null)
					nextListPages = orderDTO.getIndex() + 1;
				Long totalOrders = orderService.getCountOrders(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status);
				String strcount = totalOrders.toString();
				Integer sizeList = Integer.parseInt(strcount)
						/ PAGE_ITEMS_COUNT;
				if (nextListPages <= sizeList + 1) {
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = nextListPages; i <= sizeList + 1
							&& i <= nextListPages + 10; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					if (nextListPages <= sizeList + 1) {
						indexSet = nextListPages - 1;
						OrdersDTO orderPageSelected = listIndexSet.get(0);
						orderPageSelected
								.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
						indexSet = indexSet * PAGE_ITEMS_COUNT;
						session.setAttribute("indexSet", indexSet);
						session.setAttribute("nextListPages", nextListPages);
						session.setAttribute("listIndexSet", listIndexSet);
						session.setAttribute("orderPageSelected",
								orderPageSelected);
					}
				}
			}

			/*----------------- When Admin Click on the previousListPages --------------------------
					recreate listIndexSet started with index< index-10 and indexSet<indexSet-10
			 ---------------------------------------------------------------------------------------*/
			if (prevListPagesSignal != null && prevListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				nextListPages = (Integer) session.getAttribute("nextListPages");
				if (nextListPages != null && nextListPages >= 11) {
					prevListPages = nextListPages - 11;
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = prevListPages; i < nextListPages; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					indexSet = prevListPages - 1;
					OrdersDTO orderPageSelected = listIndexSet.get(0);
					orderPageSelected
							.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
					indexSet = indexSet * PAGE_ITEMS_COUNT;
					nextListPages = prevListPages;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("indexSet", indexSet);
					session.setAttribute("listIndexSet", listIndexSet);
					session.setAttribute("orderPageSelected", orderPageSelected);
				}
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			hashProvinces = (Hashtable<String, ProvinceDTO>) session
					.getAttribute("hashProvinces");
			if (hashProvinces == null) {
				listProvinces = productService.getAllProvinces();
				Hashtable<String, ProvinceDTO> hashProvinces = new Hashtable<String, ProvinceDTO>();
				for (ProvinceDTO prov : listProvinces) {
					hashProvinces.put(prov.getCode(), prov);
				}
				session.setAttribute("hashProvinces", hashProvinces);
			}
			if (code != null && !code.equals("") && listOrdersDTO != null) {
				ProvinceDTO provinceDTO = hashProvinces.get(code);
				if (provinceDTO != null) {
					clientProvince = provinceDTO.getCode();
				}
			}// else listCities=new ArrayList<CityDTO>();
			if (listOrdersDTO != null && indexOrder != -1) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit != null) {
					orderToEdit.setClientProvince(code);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				}
			}

			/*------------------------------- Refresh listOrdersDTO------------------------------------
						Refresh listOrders before generation of invoiced orders XLS file 
				 ------------------------------------------------------------------------------------------*/
			invoicedOrdersRefresh = (Long) session
					.getAttribute("invoicedOrdersRefresh");
			if (invoicedOrdersRefresh != null && invoicedOrdersRefresh != 0L) {
				listIndexColumn = (ArrayList<Integer>) session
						.getAttribute("listIndexColumn");
				if (listIndexColumn == null)
					listIndexColumn = getNewListIndexColumn();
				lsOrderId = lsOrderId.toUpperCase();
				//Searching Functionality 
				
				//Create new object or Order to modify the search functinality
				OrdersDTO orderDTO=new OrdersDTO();
				orderDTO.setLsOrderId(lsOrderId);
				orderDTO.setUserLogin(userLogin);
				orderDTO.setStatus(newStatus);
				orderDTO.setProductOrderNumber(productOrderNumberSearch);
				orderDTO.setClientOrderNumber(clientOrderNumber);
				orderDTO.setClientOtherId(clientOther);
				
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween,orderDTO,listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				indexSet = 0;
				session.setAttribute("indexSet", indexSet);
				nextListPages = 0;
				session.setAttribute("nextListPages", nextListPages);
				session.setAttribute("selectedStatus", selectedStatus);
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("invoicedOrdersRefresh", 0L);
				return SUCCESS;
			}

			/*------------ When Admin click on the Button "Delete Order" in The OrderDtailPop --------------
								show other pop to confirm Order Delete
			  ----------------------------------------------------------------------------------------------*/
			if (deleteOrderSignal != null && deleteOrderSignal != 0L) {
				message = "Attention! if you click on \"Delete Order\" you can not restore it.";
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (confirmDeleteSignal != null && confirmDeleteSignal == 0L) { // Delete
																				// Order
																				// Request
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "display:block;visibility:visible;";
				} else if (confirmDeleteSignal == 1L) { // Delete Order
														// Confirmed
					orderService.deleteOrderByLsOrderId(orderToEdit);
					// Save this operation in table operation
					OperationsDTO operationDTO = new OperationsDTO();
					User userAdmin = (User) session.getAttribute("userAdmin");
					if (userAdmin != null)
						operationDTO.setUserId(userAdmin.getId());
					operationDTO.setOperationDate(new Date());
					operationDTO.setOperationType("Delete Order");
					String dataBefore = "[PARTNER NAME:"
							+ orderToEdit.getUserLogin() + "];";
					dataBefore += " [LS_ORDER_ID:" + orderToEdit.getLsOrderId()
							+ "];";
					dataBefore += " [PRODUCT_ORDER_NUMBER:"
							+ orderToEdit.getProductOrderNumber() + "];";
					dataBefore += " [CLIENT_FIRST_NAME:"
							+ orderToEdit.getClientFirstName() + "];";
					dataBefore += " [CLIENT_LAST_NAME:"
							+ orderToEdit.getClientLastName() + "];";
					dataBefore += " [CLIENT_POSTAL_CODE:"
							+ orderToEdit.getClientPostalCode() + "];";
					dataBefore += " [LS_PRODUCT_ID:"
							+ orderToEdit.getLsProductID() + "];";
					dataBefore += " [UNIT_PRICE:" + orderToEdit.getUnitPrice()
							+ "];";
					dataBefore += " [STATUS:" + orderToEdit.getStatus() + "];";
					operationDTO.setDataBefore(dataBefore);
					operationDTO.setDataBefore(operationDTO.getDataBefore());
					operationDTO.setDataAfter("");
					operationsService.insertOperation(operationDTO);
					// Remove order from the list orders
					listOrdersDTO.remove(orderToEdit);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					showOrderDetailPop = "visibility:hidden;display:none;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
					// initialize index orders
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				} else { // Cancel Order Delete
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
				}
				return SUCCESS;
			}

			/*------ When Admin click the "Edit link" in the Order Table for Edit NOTE -----
							show only field Edit Note
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showOnlyEditNote != null && showOnlyEditNote != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowOnlyEditNote(0L);
					order.setCssRow("");
				}
				orderToEdit.setShowOnlyEditNote(1L);
				orderToEdit.setCssRow("background-color:#FF9966;");
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (ArrayList<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save Edit Note in the Orders Table" ----------
													save Only  notes
			  -------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOnlyNoteSignal != null && saveOnlyNoteSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						orderToEdit.setNotes(notes);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						orderToEdit.setCssRow("");
						// Save Note
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click the "Edit link" in the Order Table -------------
								show fields to edit shipping parameters
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showRowShipping != null && showRowShipping != 0L) {

				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowRowShipping(0L);
					order.setCssRow("");
				}
				// only Admins who has Active = true of action name='All' can
				// change shipping settings
				// of orders shipped or invoiced
				if (usersPrivChangeShippedStatus == null
						&& orderToEdit.getStatus() != null
						&& (orderToEdit.getStatus().equals("shipped") || orderToEdit
								.getStatus().equals("invoiced"))) {
					showRowShipping = 0L;
					return SUCCESS;
				}

				if (orderToEdit != null) {
					orderToEdit.setShowRowShipping(1L);
					orderToEdit.setShowOnlyEditNote(1L);
					orderToEdit.setCssRow("background-color:#FF9966;");
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (ArrayList<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				if (orderToEdit.getStatus().equals("open")) {
					statusId = 0L;
				} else if (orderToEdit.getStatus().equals("progress")) {
					statusId = 1L;
				} else if (orderToEdit.getStatus().equals("shipped")) {
					statusId = 2L;
				} else if (orderToEdit.getStatus().equals("invoiced")) {
					statusId = 3L;
				} else if (orderToEdit.getStatus().equals("canceled")) {
					statusId = 4L;
				}
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save in the Orders Table" ----------
							save all shipping parameters and notes
			 ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveShippingSignal != null && saveShippingSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						Date shippedDateToEdit = null;
						frm = new SimpleDateFormat("dd/MM/yyyy");
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))) {
							strShippedDate = strShippedDate.replaceAll(" ", "");
							try {
								Date date = frm.parse(strShippedDate);
								shippedDateToEdit = date;
							} catch (Exception pe) {
								shippedDateToEdit = null;
							}
						}
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))
								&& strShippedDate.length() <= 8)
							shippedDateToEdit = orderToEdit.getShippedDate();
						Double shippingPrice = null;
						// Double currencyShippingPrice=null;
						if (strShippingPrice != null
								&& !strShippingPrice.equals("")) {
							strShippingPrice = strShippingPrice.replaceAll(" ",
									"");
							int index = strShippingPrice.indexOf(",");
							if (index >= 0) {
								String strUnitPrice1 = strShippingPrice
										.substring(0, index);
								String strUnitPrice2 = strShippingPrice
										.substring(index + 1,
												strShippingPrice.length());
								strShippingPrice = strUnitPrice1 + "."
										+ strUnitPrice2;
							}

							try {
								shippingPrice = Double
										.parseDouble(strShippingPrice);
								/*
								 * if(shippingPrice!=null &&
								 * orderToEdit.getCurrencyId()!=null &&
								 * orderToEdit.getCurrencyId()!=1 &&
								 * orderToEdit.getCurrencyRate()!=null) {
								 * currencyShippingPrice = shippingPrice *
								 * orderToEdit.getCurrencyRate();
								 * currencyShippingPrice = (double)
								 * Math.round(currencyShippingPrice*100)/100; }
								 */
							} catch (Exception pe) {
								shippingPrice = null;
							}
						}

						if (trakingNumber != null)
							trakingNumber = trakingNumber.replaceAll(
									"^ +| +$|( )+", "$1");
						if (shippingCompany != null)
							shippingCompany = shippingCompany.replaceAll(
									"^ +| +$|( )+", "$1");
						orderToEdit.setShippingPrice(shippingPrice);
						// orderToEdit.setCurrencyShippingPrice(currencyShippingPrice);
						// orderToEdit.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
						orderToEdit.setShippedDate(shippedDateToEdit);
						orderToEdit.setNotes(notes);
						if (newStatus != null && !newStatus.equals(""))
							orderToEdit.setStatus(newStatus);
						orderToEdit.setShippingCompany(shippingCompany);
						orderToEdit.setTrackingNumber(trakingNumber);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						OrdersRows row = orderToEdit.getRowsList().get(0);
						row.setShippingPrice(shippingPrice);
						row.setShippingCompany(shippingCompany);
						row.setTrackingNumber(trakingNumber);
						orderToEdit.setCssRow("");

						if (newStatus != null && !newStatus.equals("")) { // if
																			// admin
																			// click
																			// on
																			// the
																			// save
																			// behind
																			// status
							orderService.updateStatusByLsOrderId(
									orderToEdit.getLsOrderId(), newStatus);
							orderToEdit.setStatus(newStatus);
							if (!newStatus.equals("shipped")
									&& !newStatus.equals("invoiced")
									&& !newStatus.equals("canceled")) {
								orderToEdit.setShippingPrice(null);
								orderToEdit.setTrackingNumber(null);
								orderToEdit.setShippedDate(null);
							}

						} else {// if admin click on the save other than Status
							if (orderToEdit.getShippedDate() != null
									&& orderToEdit.getTrackingNumber() != null
									&& !orderToEdit.getTrackingNumber().equals(
											"")
									&& orderToEdit.getShippingCompany() != null
									&& !orderToEdit.getShippingCompany()
											.equals("")
									&& orderToEdit.getShippingPrice() != null
									&& orderToEdit.getStatus() != null) {
								if (orderToEdit.getStatus().equals("open")
										|| orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"shipped");
									orderToEdit.setStatus("shipped");
								}
							} else {
								if (usersPrivChangeShippedStatus != null
										&& !orderToEdit.getStatus().equals(
												"open")
										&& !orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"progress");
									orderToEdit.setStatus("progress");
								}
							}
						}
						// if admin click on the save other then status(save
						// notes, save shipping company ...)
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click on icon findOrders.png ----------
								check user and complete infos client
			 ----------------------------------------------------------------*/
			if (findOrdersSignal != null
					&& findOrdersSignal != 0L
					|| (pageIndexSignal != null && pageIndexSignal != 0L)
					|| (nextListPagesSignal != null && nextListPagesSignal != 0L)
					|| (prevListPagesSignal != null && prevListPagesSignal != 0L)) {
				// session.setAttribute("allOrdersSelectedSignal",0L);
				// if admin click on search icon initialize checkBoxItem to
				// false
				if (findOrdersSignal != null && findOrdersSignal != 0L) {
					session.setAttribute("allOrdersSelectedSignal", 0L);
					checkBoxItem = false;
					session.setAttribute("checkBoxItem", checkBoxItem);
					indexSet = 0;
					session.setAttribute("indexSet", indexSet);
					nextListPages = 0;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("selectedStatus", selectedStatus);

				}
				// if admin navigate on pages keep the previous sorting
				if (((pageIndexSignal != null && pageIndexSignal != 0L)
						|| (nextListPagesSignal != null && nextListPagesSignal != 0L) || (prevListPagesSignal != null && prevListPagesSignal != 0L))) {
					listIndexColumn = (ArrayList<Integer>) session
							.getAttribute("listIndexColumn");
					if (listIndexColumn == null)
						listIndexColumn = getNewListIndexColumn();
				} else { // prepare new sorting
					listIndexColumn = getNewListIndexColumn();
				}

				lsOrderId = lsOrderId.toUpperCase();
				// if(findOrdersSignal!=null &&
				// findOrdersSignal!=0L)initalizeListIndexSet(session,orderService
				// );
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);

				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("sizeResult", sizeResult);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				return SUCCESS;
			}

			/*------------ When Admin click on the icon sorting of column ----------
							seach result with option of sorting list
			 -----------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& sortingOrdersSignal != null && sortingOrdersSignal != 0L) {
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				asc = (asc == 1 ? -1 : 1);
				int nextElement = listIndexColumn.get(0);
				fieldForSorting = asc * fieldForSorting;
				listIndexColumn.set(0, fieldForSorting);
				for (int i = 1; i < listIndexColumn.size(); i++) {
					int element = listIndexColumn.get(i);
					listIndexColumn.set(i, nextElement);
					nextElement = element;
				}
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				int balance = 0;
				int OrderIndex = 0;
				for (OrdersDTO orDTO : listOrdersDTO) {
					balance = (balance == 1 ? 0 : 1);
					if (balance == 1) {
						orDTO.setCssStyle("background-color: rgb(245,249,252);border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					} else {
						orDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					}
					orDTO.setIndex(OrderIndex);
					OrderIndex++;
				}
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("asc", asc);
				return SUCCESS;
			}

			/*------ when Admin click on the lsOrder link in table -----------
					show popup detail and allow admin to update Order
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& editOrderSignal != null && editOrderSignal != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit == null)
					orderToEdit = new OrdersDTO();
				if (orderToEdit.getProductOrderDate() == null)
					strProductOrderDate = "";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*--- when Admin click on the cancel Button of orderDetailPop ---
					we mast just hide popup OrderDetail
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& cancelSignal != null && cancelSignal != 0L) {
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}

			/*-------------------- When Admin left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& checkProductPriceSignal != null
					&& checkProductPriceSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToUpadate = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				UserProductPriceDTO userProductPrice = productService
						.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if (userProductPrice == null) {
					orderRowToUpadate.setCss("background-color:red;");
					orderRowToUpadate.setProductDescription("");
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				} else {
					Double usrPrice = orderRowToUpadate.getUnitPrice();
					if (usrPrice == null)
						usrPrice = 0D;
					if (usrPrice < userProductPrice.getPriceNum()) {
						orderRowToUpadate.setCssPrice("background-color:red;");
					}
					orderRowToUpadate.setProductDescription(userProductPrice
							.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice
							.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice
							.getLsProductId());
					orderRowToUpadate
							.setLsPrice(userProductPrice.getPriceNum());
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = orderDTOToUpdate;
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*----------------- When Admin check on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveTemporaryRowSignal != null
					&& saveTemporaryRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToSaveMemory = orderDTOToUpdate
						.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if (orderRowToSaveMemory != null) {
					orderRowToSaveMemory.setQuantity(quantity);
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory
							.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory
							.setCssPrice("background-color:#FF6666;");
					orderRowToSaveMemory
							.setCssQuantity("background-color:#FF6666;");
					if (quantity != null && quantity > 0D)
						orderRowToSaveMemory.setCssQuantity("");
					if (unitPrice != null
							&& orderRowToSaveMemory.getLsPrice() != null
							&& unitPrice >= orderRowToSaveMemory.getLsPrice())
						orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trakingNumber);
					if (orderRowToSaveMemory.getCurrencyId() != null
							&& orderRowToSaveMemory.getCurrencyId() != 1
							&& orderRowToSaveMemory.getCurrencyRate() != null) {
						if (unitPrice != null) {
							orderRowToSaveMemory
									.setCurrencyUnitPrice(unitPrice);
							unitPrice = unitPrice
									/ orderRowToSaveMemory.getCurrencyRate();
							unitPrice = (double) Math.round(unitPrice * 100) / 100;
							orderRowToSaveMemory.setUnitPrice(unitPrice);
						}
						/*
						 * if(shippingFee!=null) {
						 * orderRowToSaveMemory.setCurrencyShippingPrice
						 * (shippingFee); shippingFee =
						 * shippingFee/orderRowToSaveMemory.getCurrencyRate();
						 * shippingFee = (double)
						 * Math.round(shippingFee*100)/100;
						 * orderRowToSaveMemory.setShippingPrice(shippingFee); }
						 */
					}
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				// Change totalPrice also
				if (orderToEdit.getRowsList().get(0) != null
						&& orderToEdit.getRowsList().get(0).getQuantity() != null
						&& orderToEdit.getRowsList().get(0)
								.getQuantityToSplit() != null
						&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
					Double priceTotal = orderToEdit.getRowsList().get(0)
							.getUnitPrice()
							* orderToEdit.getRowsList().get(0)
									.getQuantityToSplit();
					priceTotal = (double) Math.round(priceTotal * 100) / 100;
					orderToEdit.setTotalPrice(priceTotal);
				}
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------- When Admin click on addSimilarRow Icon on the OrderDetailPop --------
								Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& addSimilarRowSignal != null && addSimilarRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				// generate lsOrderId to new order
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				if (orderRowToClone != null) {
					if (!orderRowToClone.getIcon().equals(
							"images/orders/itemValidated.png")) {
						orderRowToClone.setQuantity(quantity);
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone
								.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trakingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd = DTOFactory
							.getOrderRowClone(orderRowToClone);
					orderRowToAdd.setId(-1L);
					// Add currencyId
					if (orderRowToClone.getCurrencyId() != null)
						orderRowToAdd.setCurrencyId(orderRowToClone
								.getCurrencyId());

					orderDTOToUpdate.getRowsList().add(indexRow + 1,
							orderRowToAdd);
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------- When Admin click on Delete Row Icon of orderDetail Popup-----------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& deleteRowSignal != null && deleteRowSignal != 0L) {
				OrdersDTO orderDTO = listOrdersDTO.get(indexOrder);
				orderDTO = fillDataOrderDTO(orderDTO);
				int nb = orderService.nbOrderRowsNotDeleted(orderDTO
						.getRowsList());
				if (orderDTO != null && orderDTO.getRowsList().size() > 1) {
					for (int i = 0; i < orderDTO.getRowsList().size(); i++) {
						if (i == indexRow && nb > 1) {
							orderDTO.getRowsList().get(i).setToDelete(1);
							break;
						}
					}
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ when Admin click on the button save of orderDetail ------------------
					 save order and hide pup  
			  ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOrdersSignal != null && saveOrdersSignal != 0L) {
				session.setAttribute("orderNotSavedAtFirst", null);
				orderToEdit = listOrdersDTO.get(indexOrder);
				orderToEdit = fillDataOrderDTO(orderToEdit);

				// add special handling shipping
				User user = null;
				if (orderToEdit.getUserLogin() != null)
					user = userService.getUserByLogin(orderToEdit
							.getUserLogin());
				if (user != null) {
					Double totalPrice = null;
					orderToEdit.setSpecialHandlingName(user
							.getSpecialHandlingName());
					orderToEdit.setSpecialHandlingFee(user
							.getSpecialHandlingFee());
					if (orderToEdit.getRowsList().get(0).getQuantity() != null
							&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
						totalPrice = orderToEdit.getRowsList().get(0)
								.getQuantity()
								* orderToEdit.getRowsList().get(0)
										.getUnitPrice();
						totalPrice = (double) Math.round(totalPrice * 100) / 100;
					}

					orderToEdit.setTotalPrice(totalPrice);
				}

				orderService.updateOrderByLsOrderId(orderToEdit);
				for (OrdersRows row : orderToEdit.getRowsList()) {
					if (row.getId() == -1)
						row.setId(0L);
				}
				OrdersRows row = orderToEdit.getRowsList().get(0);
				if (row != null) {
					orderToEdit.getShippedDate();
					orderToEdit.setLsPrice(row.getLsPrice());
					orderToEdit.setLsProductID(row.getLsProductID());
					orderToEdit.setProductDescription(row
							.getProductDescription());
					orderToEdit.setQuantity(row.getQuantity());
				}
				orderToEdit = DTOFactory.getOrderDTOConsideredMissingInfo(
						orderToEdit, hashProvinces);
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				message = "Saving has completed successfuly";
				showSaveSuccessPop = "display:block;visibility:visible;";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ When user change Quantity to split in orderDetailPop -----------
					 prepare order to split from two other orders witch
				 	 one must have a lsOrder with underscore 
			 ------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& quantityToChangeSignal != null
					&& quantityToChangeSignal != 0L) {
				OrdersDTO orderToChangeQt = listOrdersDTO.get(indexOrder);
				OrdersRows orderRow = orderToChangeQt.getRowsList().get(
						indexRow);
				orderToChangeQt = fillDataOrderDTO(orderToChangeQt);
				if (quantityToChange < orderRow.getQuantity())
					orderRow.setQuantityToSplit(quantityToChange);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- Duplicate Order ----------------------------------------
							Create order in just in memory
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& duplicateOrderSignal != null
					&& duplicateOrderSignal != 0L) {
				OrdersDTO orderToClone = listOrdersDTO.get(indexOrder);
				orderToClone = fillDataOrderDTO(orderToClone);
				hashOrders = new Hashtable<String, OrdersDTO>();
				for (OrdersDTO ord : listOrdersDTO) {
					hashOrders.put(ord.getLsOrderId(), ord);
				}
				OrdersDTO orderClone = DTOFactory
						.getOrderDTOSplitted(orderToClone);
				if (orderClone != null) {
					orderClone.setDuplicate(true);
					String lsOrder = orderClone.getLsOrderId();
					String strlsOrder = orderService.generateLsOrderId(lsOrder,
							hashOrders);
					orderClone.setLsOrderId(strlsOrder);// rgb(116,180,209)
					orderClone
							.setCssStyle("background-color:#FFFF99;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					orderToEdit = orderClone;
					orderToEdit.setBackgroundColor("background-color:#FFFF99;");
					listOrdersDTO.add(indexOrder + 1, orderClone);
					indexOrder = 0;
					for (OrdersDTO ord : listOrdersDTO) {
						ord.setIndex(indexOrder);
						indexOrder++;
					}
					orderService.updateOrderByLsOrderId(orderToClone);
					orderService.insertOrderWithRows(orderClone);
					orderClone.setDuplicate(false);
					for (OrdersRows row : orderClone.getRowsList()) {
						if (row.getId() < 0L)
							row.setId(0L);
					}
					if (listOrdersDTO.size() > 0) {
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				} else
					orderToEdit = orderToClone;
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& okSaveSuccessPopSignal != null
					&& okSaveSuccessPopSignal != 0L) {
				showSaveSuccessPop = "visibility:hidden;display:none;";
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}

	/*
	 * ==========================================================================
	 * =============== fill all fields of order without rows
	 * ====================
	 * =====================================================================
	 */
	public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO) {
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		orderDTO.setClientLastName(clientLastName);
		orderDTO.setClientFirstName(clientFirstName);
		orderDTO.setClientOtherNames(clientOtherNames);
		orderDTO.setClientStreet(clientStreet);
		orderDTO.setClientOtherStreet(clientOtherStreet);
		orderDTO.setClientCity(clientCity);
		orderDTO.setClientProvince(code);
		orderDTO.setClientPostalCode(clientPostalCode);
		orderDTO.setClientPhone(clientPhone);
		orderDTO.setClientEmail(clientEmail);
		orderDTO.setProductOrderNumber(productOrderNumberSearch);
		orderDTO.setCompanyHeader(companyHeader);
		if (((strProductOrderDate) != null)
				&& (!"".equals(strProductOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strProductOrderDate);
				orderDTO.setProductOrderDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strCreationOrderDate) != null)
				&& (!"".equals(strCreationOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strCreationOrderDate);
				orderDTO.setCreationDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strRequiredDate) != null) && (!"".equals(strRequiredDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strRequiredDate);
				orderDTO.setRequiredDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}
		return orderDTO;
	}

	/*
	 * ==========================================================================
	 * =============== initialize ListIndexSet
	 * ==================================
	 * =======================================================
	 */
	public void initalizeListIndexSet(HttpSession session,
			OrdersService orderService) throws ServiceException {
		listIndexSet = new ArrayList<OrdersDTO>();
		totalOrders = orderService.getCountOrders(creationDateStartArg,
				creationDateEndArg, reportDateBetween, userLogin, lsOrderId,
				status);
		String strcount = totalOrders.toString();
		Integer sizeList = Integer.parseInt(strcount) / PAGE_ITEMS_COUNT;
		nextListPages = 1;
		session.setAttribute("nextListPages", nextListPages);
		for (int i = 1; i <= sizeList + 1 && i <= 11; i++) {
			OrdersDTO ord = new OrdersDTO();
			ord.setCssStyle("");
			ord.setIndex(i);
			listIndexSet.add(ord);
		}
		indexSet = 0;
		session.setAttribute("indexSet", indexSet);
		session.setAttribute("totalOrders", totalOrders);
		session.setAttribute("listIndexSet", listIndexSet);

	}

	/*
	 * ==========================================================================
	 * =============== initialize listIndexColumn
	 * ================================
	 * =========================================================
	 */
	List<Integer> getNewListIndexColumn() {
		List<Integer> reult = new ArrayList<Integer>();
		for (int i = 0; i <= 34; i++) {
			if (i != 2 && i <= 13) {
				reult.add(i);
				if (i != 0)
					reult.add(-i);
			}
			if (i == 30 || i == 31 || i == 34) {
				reult.add(i);
				reult.add(-i);
			}
		}
		return reult;
	}

	/*
	 * ==========================================================================
	 * =============== getStatus Selected by Admin for searching
	 * ================
	 * =========================================================================
	 */
	public String getStatusSelected(Integer StatusIndex) {
		String result = "";
		switch (StatusIndex) {
		case 0:
			result = "open";
			break;
		case 1:
			result = "progress";
			break;
		case 2:
			result = "shipped";
			break;
		case 3:
			result = "invoiced";
			break;
		case 4:
			result = "canceled";
			break;
		default:
			result = "";
		}
		return result;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:16:10.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.140
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.141
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:16:10.141
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:10.142
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:16:30.675
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.CityDTO;
import com.loyauty.service.core.dto.CurrencyDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;


public class CreateOrdersManual extends LoyautyAction {
	private static final long serialVersionUID = -1238269595572206024L;

	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	@Getter @Setter
	private String userLogin;
	@Getter @Setter
	private Long userId;
	@Getter @Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter @Setter
	private File orderFile;
	@Getter @Setter
	List<OrdersDTO>listOrdersDTO;
	Hashtable<String, OrdersDTO>hashOrders;
	@Getter @Setter
	private String orderSelected;
	@Getter @Setter
	private Long saveOrdersSignal;
	@Getter @Setter
	private Long confirmSaveOrdersSignal;
	@Getter @Setter
	private String lsOrderId;
	@Getter @Setter
	private String message;
	@Getter @Setter
	Integer indexOrder;
	@Getter @Setter
	Integer indexRow;
	@Getter @Setter
	private Long checkBoxPrintSignal;
	@Getter @Setter
	private Boolean checkBoxPrintEtem;
	@Getter @Setter
	private Boolean checkBoxPrint;
	@Getter @Setter
	private Long pageTop=0L;
	@Getter @Setter
	private Long saved;
	@Getter @Setter
	private String showNotificationPop="visibility:hidden;display:none;";
	@Getter @Setter
	private Long addOrderSignal;
	@Getter @Setter
	private Long addSimilarOrderSignal;
	@Getter @Setter
	private Long deleteOrderSignal;
	@Getter @Setter
	private Long deleteRowSignal;
	@Getter @Setter
	private Long userLoginChangedSignal;
	@Getter @Setter
	private Long saveTemporarySignal;
	@Getter @Setter
	private Long addSimilarRowSignal;
	@Getter @Setter
	private Long saveTemporaryRowSignal;
	@Getter @Setter
	private Long checkProductPriceSignal;
	@Getter @Setter
	private Long userIdFindedSignal;
	@Getter @Setter
	private String userLogo;
	//recovery Data Order
	@Getter @Setter
	private String clientLastName;
	@Getter @Setter
	private String clientFirstName;
	@Getter @Setter
	private String clientOtherNames;
	@Getter @Setter
	private String clientStreet;
	@Getter @Setter
	private String  clientOtherStreet;
	@Getter @Setter
	private String  clientCity;
	@Getter @Setter
	private String  clientProvince;
	@Getter @Setter
	private String  clientPostalCode;
	@Getter @Setter
	private String  clientPhone;
	@Getter @Setter
	private String  clientEmail;
	@Getter @Setter
	private String productOrderNumber;
	@Getter @Setter
	private String strProductOrderDate;
	@Getter @Setter
	private String strRequiredDate;
	
	//recovery data row
	@Getter @Setter
	private Double quantity ;
	@Getter @Setter
	private String lsProductID;
	@Getter @Setter
	private Double stock;
	@Getter @Setter
	private String productDescription;
	@Getter @Setter
	private Double unitPrice;
	@Getter @Setter
	private Double shippingFee;
	@Getter @Setter
	private String shippingCompany;
	@Getter @Setter
	private String trackingNumber;
	@Getter @Setter
	private String strCreationOrderDate;
	@Getter @Setter
	private Date creationOrderDate; 
	@Getter @Setter
	private String showSaveSuccessPop="visibility:hidden;display:none;";
	//showSaveSuccessPop="display:block;visibility:visible;";
	//showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter @Setter
	private Long okSaveSuccessPopSignal;
	@Getter @Setter
	private Long requirdFieldError;
	@Getter @Setter
	private Long newLsOrderIdSignal;
	@Getter @Setter
	private List<ProvinceDTO>listProvinces;
	@Getter @Setter 
	private String  code;
	//@Getter @Setter
	//private List<CityDTO>listCities;
	private Hashtable<String, ProvinceDTO>hashProvinces;
	//private Hashtable<String, CityDTO>hashCities;
	//@Getter @Setter
	//private Long provinceChangedSignal;
	private Date today ;
	
	@Getter @Setter
	private Long currencyAlertPopSignal;
	
	@Getter @Setter
	private String currencySymbol;
	
	public  CreateOrdersManual() throws ServiceLocatorException {
		super();	
		productService = getServiceLocator().getProductService();   
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		hashOrders=new Hashtable<String, OrdersDTO>();
		//listProvinces=new ArrayList<ProvinceDTO>();
		today=new Date();
	}

	/*=========================================================================================
	 											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked", "unused" })
	@Override
	public String execute() throws Exception {
		HttpSession session = request.getSession(true);
		OrdersDTO orderDTOToAdd;
		userLogo=(String)session.getAttribute("userLogo");
		requirdFieldError=(Long)session.getAttribute("requirdFieldError");
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		SimpleDateFormat frmForLsOrderId = new SimpleDateFormat("yyyyMMdd");
		OrdersDTO orderDTOToUpdate;
		String initalClient="";
		try {
			//recovery provinces
			listProvinces=(List<ProvinceDTO>)session.getAttribute("listProvinces");
			if(listProvinces==null){
				listProvinces=productService.getAllProvinces();
				session.setAttribute("listProvinces",listProvinces);
			}
			if (((strCreationOrderDate)!=null)&&(!"".equals(strCreationOrderDate))){
				try {
					creationOrderDate = frm.parse(strCreationOrderDate);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession=(List<User>)session.getAttribute("usersListSession");
			if(usersListSession==null){
				List<UserSessionDTO> listAllUsers= userService.getAllUsers(basicUserDTO);
				usersList=new ArrayList<User>();
				for(UserSessionDTO userDTO:listAllUsers){
					User user=new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession",usersList);
			}else usersList=usersListSession;


			/*-------------------- recovery orders list ------------------------------------
						displaying at least one item in the orders list if it is empty
			  -----------------------------------------------------------------------------*/
			
			if(userIdFindedSignal==null || userIdFindedSignal==0L){
				userId=(Long)session.getAttribute("userId");
				if(userId!=null){
					UserDTO userFind=userService.getUserInformation(userId);
					userLogin=userFind.getLogin();
				}
			}
			
			listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
			if(listOrdersDTO==null)listOrdersDTO =new ArrayList<OrdersDTO>();
			if(listOrdersDTO.size()==0){
				//String lsOrderIdFirstPart="Man"+frm.format(today);
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				OrdersDTO orderDTO=new OrdersDTO();
				orderDTO.setLsOrderId(manLsOrderId);
				orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
				OrdersRows orderRow=new OrdersRows();
				orderRow.setIcon("images/orders/itemNotValidated.png");
				orderDTO.getRowsList().add(orderRow);
				listOrdersDTO.add(orderDTO);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
			}else{
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				OrdersDTO ordDTO=listOrdersDTO.get(0);
				ordDTO.setLsOrderId(manLsOrderId);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			//if(provinceChangedSignal!=null && provinceChangedSignal!=0L){
				hashProvinces=(Hashtable<String, ProvinceDTO>)session.getAttribute("hashProvinces");
				if(code!=null && !code.equals("")){
					ProvinceDTO provinceDTO=hashProvinces.get(code);
					if(provinceDTO!=null){
						clientProvince=provinceDTO.getCode();
						//listCities=provinceDTO.getListCities();
					}
				}//else listCities=new ArrayList<CityDTO>();
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				orderDTOToUpdate.setClientCity(clientCity);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				//return SUCCESS;
			//}

			/*-------------------- When Admin Find User Login ---------------------------
						change all value of userid list of orders
			 -----------------------------------------------------------------------------*/
			if(userIdFindedSignal!=null && userIdFindedSignal!=0L){
				User user=userService.getUserByLogin(userLogin);
				OrdersDTO orderDTO=listOrdersDTO.get(0);
				orderDTO=fillDataOrderDTO(orderDTO);
				userLogo=null;
				userId=null;
				if(user!=null){
					orderDTO.setUserId(user.getId());
					userId=user.getId();
					currencySymbol = "CAD";
					CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
					if(currencyDTO!=null && currencyDTO.getId()!=1) {
						currencyAlertPopSignal = 1L;
						if(currencyDTO.getSymbol()!=null) currencySymbol = currencyDTO.getSymbol();
					} else currencyAlertPopSignal=0L;
					for(OrdersDTO ord:listOrdersDTO){
						ord.setUserId(user.getId());
						ord.setUserLogin(userLogin);
					}
	    			//show user logo
	    			userLogo="./images/orders/usersLogos/"+userLogin+".png";
				}else userLogin=null;

				String filePath = session.getServletContext().getRealPath("/");
				//String LogoDestination = filePath + "images/orders/usersLogos/"+userLogin+".png";
				//File f=new File(LogoDestination);
				//if(!f.exists())userId=null;

    			//if userLogo dosn't exist give him a blank logo
    			createUserLogo(filePath +"images/orders/usersLogos/BLANK.png", filePath +"images/orders/usersLogos/"+userLogin+".png");
    			
    			session.setAttribute("userLogo",userLogo);
				session.setAttribute("userId",userId);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			if(userId==null)userLogin="";

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			/*if(provinceChangedSignal!=null && provinceChangedSignal!=0L){
				hashProvinces=(Hashtable<String, ProvinceDTO>)session.getAttribute("hashProvinces");
				if(code!=null){
					listCities=hashProvinces.get(code).getListCities();
				}else listCities=new ArrayList<CityDTO>();
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				//orderDTOToUpdate.setClientCity(clientCity)
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				//return SUCCESS;
			//}*/
			
			/*----------------- When Admin check on Add Similar order Icon or save Temporary -------
									Create a copy of order selected
			 ---------------------------------------------------------------------------------------*/
			if(((addSimilarOrderSignal!=null && addSimilarOrderSignal!=0L)||(saveTemporarySignal!=null && saveTemporarySignal!=0L)) && indexOrder>=0){
				orderDTOToAdd=listOrdersDTO.get(indexOrder);
				if(orderDTOToAdd==null)orderDTOToAdd=new OrdersDTO();
				if((saveTemporarySignal!=null && saveTemporarySignal!=0L))orderDTOToAdd.setLsOrderId(lsOrderId);
				orderDTOToAdd.setCreationDate(creationOrderDate); 
				orderDTOToAdd.setClientLastName(clientLastName);
				orderDTOToAdd.setClientFirstName(clientFirstName);
				orderDTOToAdd.setClientOtherNames(clientOtherNames); 
				orderDTOToAdd.setClientStreet(clientStreet);
				orderDTOToAdd.setClientOtherStreet(clientOtherStreet);
				orderDTOToAdd.setClientCity(clientCity);
				orderDTOToAdd.setClientProvince(clientProvince);
				orderDTOToAdd.setClientProvince(clientProvince);
				orderDTOToAdd.setClientPostalCode(clientPostalCode);
				orderDTOToAdd.setClientPhone(clientPhone);
				orderDTOToAdd.setClientEmail(clientEmail);			
				orderDTOToAdd.setProductOrderNumber(productOrderNumber);
				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToAdd.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToAdd.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				User user=userService.getUserByLogin(userLogin);
				if(user!=null){
					UserDTO userDTO=userService.getUserInformation(user.getId());
					orderDTOToAdd.setUserLogin(userLogin);
					orderDTOToAdd.setUserId(userDTO.getId());
				}
				if(addSimilarOrderSignal!=null && addSimilarOrderSignal!=0L){ 
					OrdersDTO orderDTOClone = DTOFactory.getOrderDTOClone(orderDTOToAdd);
					orderDTOClone.setCssStyle("background-color:white;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					listOrdersDTO.add(orderDTOClone);
				}
				int indexOrder=0;
				for(OrdersDTO orderDTO:listOrdersDTO){
					orderDTO.setIndex(indexOrder);
					indexOrder++;
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			
			/*----------------- When Admin click on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if(saveTemporaryRowSignal!=null && saveTemporaryRowSignal!=0L){
				
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				/*
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);
				orderDTOToUpdate.setCreationDate(creationOrderDate);
				orderDTOToUpdate.setClientLastName(clientLastName);
				orderDTOToUpdate.setClientFirstName(clientFirstName);
				orderDTOToUpdate.setClientOtherNames(clientOtherNames); 
				orderDTOToUpdate.setClientStreet(clientStreet);
				orderDTOToUpdate.setClientOtherStreet(clientOtherStreet);
				orderDTOToUpdate.setClientCity(clientCity);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientPostalCode(clientPostalCode);
				orderDTOToUpdate.setClientPhone(clientPhone);
				orderDTOToUpdate.setClientEmail(clientEmail);			
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);

				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToUpdate.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToUpdate.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				*/
				OrdersRows orderRowToSaveMemory=orderDTOToUpdate.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if(orderRowToSaveMemory!=null){
					orderRowToSaveMemory.setQuantity(quantity); 
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory.setCssPrice("background-color:red;");
					if(unitPrice!=null && orderRowToSaveMemory.getLsPrice()!=null
					  && unitPrice>=orderRowToSaveMemory.getLsPrice())
					  orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trackingNumber);	
					int indexOrder=0;
					int indexRow=0;
					for(OrdersDTO orderDTO:listOrdersDTO){
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow=0;
						for(OrdersRows orderRows:orderDTO.getRowsList()){
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				}

				return SUCCESS;
			}
			
			/*-------------------- When Admin click on addSimilarRow Icon -----------------
										Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if(addSimilarRowSignal!=null && addSimilarRowSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone=orderDTOToUpdate.getRowsList().get(indexRow);
				if(orderRowToClone!=null){
					if(!orderRowToClone.getIcon().equals("images/orders/itemValidated.png")){
						orderRowToClone.setQuantity(quantity); 
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingPrice(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trackingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd=DTOFactory.getOrderRowClone(orderRowToClone);
					orderDTOToUpdate.getRowsList().add(indexRow+1,orderRowToAdd);
					int indexOrder=0;
					int indexRow=0;
					for(OrdersDTO orderDTO:listOrdersDTO){
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow=0;
						for(OrdersRows orderRows:orderDTO.getRowsList()){
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				}
				return SUCCESS;
			}

			/*-------------------- When Admin click on Delete order Icon -------------
									Delete this order using index
			 -----------------------------------------------------------------------------*/
			
			if(deleteOrderSignal!=null && deleteOrderSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				List<OrdersDTO> listOrdersDTOAfterDelete=new ArrayList<OrdersDTO>();
				for(int i=0 ;i<listOrdersDTO.size();i++){
					if(i!=indexOrder || indexOrder==0)listOrdersDTOAfterDelete.add(listOrdersDTO.get(i));
				}
				int index=0;
				for(int i=0 ;i<listOrdersDTOAfterDelete.size();i++){
					listOrdersDTOAfterDelete.get(i).setIndex(index);
					index++;
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTOAfterDelete);
				listOrdersDTO=listOrdersDTOAfterDelete;
				return SUCCESS;
			}

			/*-------------------- When Admin check on Delete Row Icon -------------------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if(deleteRowSignal!=null && deleteRowSignal!=0L){
				ArrayList<OrdersRows>listRowsAfterDelete=new ArrayList<OrdersRows>();
				OrdersDTO orderDTO=listOrdersDTO.get(indexOrder);
				orderDTO=fillDataOrderDTO(orderDTO);
				if(orderDTO!=null && orderDTO.getRowsList().size()>1){
					for(int i=0 ;i<orderDTO.getRowsList().size();i++){
						if(i!=indexRow)listRowsAfterDelete.add(orderDTO.getRowsList().get(i));
					}
					int index=0;
					for(int i=0 ;i<listRowsAfterDelete.size();i++){
						listRowsAfterDelete.get(i).setIndex(index);
						index++;
					}
					orderDTO.setRowsList(listRowsAfterDelete);
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			

			/*-------------------- When Admin check left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if(checkProductPriceSignal!=null && checkProductPriceSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				/*
				orderDTOToUpdate.setClientLastName(clientLastName);
				orderDTOToUpdate.setClientFirstName(clientFirstName);
				orderDTOToUpdate.setClientOtherNames(clientOtherNames); 
				orderDTOToUpdate.setClientStreet(clientStreet);
				orderDTOToUpdate.setClientOtherStreet(clientOtherStreet);
				orderDTOToUpdate.setClientCity(clientCity);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientPostalCode(clientPostalCode);
				orderDTOToUpdate.setClientPhone(clientPhone);
				orderDTOToUpdate.setClientEmail(clientEmail);			
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);
				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToUpdate.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToUpdate.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				*/
				OrdersRows orderRowToUpadate=orderDTOToUpdate.getRowsList().get(indexRow);
				UserProductPriceDTO userProductPrice=productService.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if(userProductPrice==null){
					lsProductID=null;
					orderRowToUpadate.setCss("background-color:red;");
					addActionError(getText("loyauty.error.common.requiredLsProductOrder"));
					orderRowToUpadate.setProductDescription(""); 
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				}else{
					Double usrPrice=orderRowToUpadate.getUnitPrice();
					if(usrPrice==null)usrPrice=0D;
					if(usrPrice < userProductPrice.getPriceNum()){
						orderRowToUpadate.setCssPrice("background-color:red;");	
					}
					orderRowToUpadate.setProductDescription(userProductPrice.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice.getLsProductId());
					orderRowToUpadate.setLsPrice(userProductPrice.getPriceNum());
					if(userProductPrice.getUserId()!=null) {
						//currency
						Long userId = userProductPrice.getUserId();
						Long currencyId = 1L;
						Double currencyRate = 1D;
						Double currencyPrice = 0D;
						CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
						if(currencyDTO!=null && currencyDTO.getRate()!=null) {
							currencyId = currencyDTO.getId();
							if(currencyId!=1) {
								currencyRate = currencyDTO.getRate();
								currencyPrice = (double) Math.round((orderRowToUpadate.getLsPrice()*currencyRate)*100) / 100;
								orderRowToUpadate.setLsPrice(currencyPrice);
							}
						}
					}
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				return SUCCESS;
			}
			
			/*-------------------------------- SAVE ORDERS -------------------------------
						save in data bases just orders witch has print checked 
	 		 -----------------------------------------------------------------------------*/
			if(saveOrdersSignal!=null && saveOrdersSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				User user=userService.getUserByLogin(userLogin);
				OrdersDTO order=listOrdersDTO.get(0);
				order.setManOrder(true);
				order=fillDataOrderDTO(order);
				if(user!=null)order.setUserId(user.getId());
				boolean productNotFond=false;
				for(OrdersRows row:order.getRowsList()){
					if(row.getLsProductID()==null || row.getLsProductID().equals("")){
						productNotFond=true;
						break;
					}
				}
				requirdFieldError=null;
				session.setAttribute("requirdFieldError",null);
				productOrderNumber=order.getProductOrderNumber().replaceAll("^ +| +$|( )+", "$1");
				clientFirstName=order.getClientFirstName().replaceAll("^ +| +$|( )+", "$1");
				clientLastName=order.getClientLastName().replaceAll("^ +| +$|( )+", "$1");
				clientStreet=order.getClientStreet().replaceAll("^ +| +$|( )+", "$1");
				clientCity=order.getClientCity().replaceAll("^ +| +$|( )+", "$1");
				clientProvince=order.getClientProvince().replaceAll("^ +| +$|( )+", "$1");
				clientPostalCode=order.getClientPostalCode().replaceAll("^ +| +$|( )+", "$1");
				
				order.setProductOrderNumber(productOrderNumber);
				order.setClientFirstName(clientFirstName);
				order.setClientLastName(clientLastName);
				order.setClientStreet(clientStreet);
				order.setClientCity(clientCity);
				order.setClientProvince(clientProvince);
				order.setClientPostalCode(clientPostalCode);
				
				if(order.getProductOrderNumber()==null || order.getProductOrderNumber().equals("")||
						   order.getLsOrderId()==null || order.getLsOrderId().equals("") ||
						   order.getCreationDate()==null || productNotFond ||
						   order.getClientFirstName()==null || order.getClientFirstName().equals("")||
						   order.getClientLastName()==null || order.getClientLastName().equals("") ||
						   order.getClientStreet()==null || order.getClientStreet().equals("") ||
						   order.getClientCity()==null || order.getClientCity().equals("") || 
						   order.getClientProvince()==null || order.getClientProvince().equals("") ||
						   order.getClientPostalCode()==null || order.getClientPostalCode().equals("")){
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					addActionError(getText("loyauty.error.common.requiredFieldOrders"));
					requirdFieldError=1L;
					session.setAttribute("requirdFieldError",1L);
					return SUCCESS;
				}
				
				for(OrdersRows row:order.getRowsList()){
					if(row.getLsProductID()==null || row.getLsProductID().equals("")||
					   row.getQuantity()==null || row.getQuantity()==0D){
						requirdFieldError=1L;
					   session.setAttribute("requirdFieldError",1L);
					   addActionError(getText("loyauty.error.common.requiredFieldOrders"));
					   return SUCCESS;
					}
				}
				//add special handling shipping	+ currency
				for(OrdersDTO orDTO:listOrdersDTO){
					if(user!=null){
						//currency
						Long userId = user.getId();
						Long currencyId = 1L;
						String currencySymbol = "CAD";
						Double currencyRate = 1D;
						Double currencyUnitPrice = 0D;
						Double currencyTotalPrice = null;
						//Double currencyShippingPrice = null;
						Double unitPrice = null;
						CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
						if(currencyDTO!=null) {
							currencyId = currencyDTO.getId();
							if(currencyDTO.getSymbol()!=null) currencySymbol = currencyDTO.getSymbol();
							if(currencyDTO.getRate()!=null) currencyRate = currencyDTO.getRate();
						}
						
						Double totalPrice=null;
						orDTO.setSpecialHandlingName(user.getSpecialHandlingName());
						orDTO.setSpecialHandlingFee(user.getSpecialHandlingFee());
						if(orDTO.getRowsList().get(0).getQuantity()!=null && orDTO.getRowsList().get(0).getUnitPrice()!=null){
							unitPrice = orDTO.getRowsList().get(0).getUnitPrice();
							totalPrice= orDTO.getRowsList().get(0).getQuantity()*unitPrice;
							totalPrice = (double) Math.round(totalPrice * 100) / 100;
							if(currencyId!=1) {
								currencyUnitPrice = unitPrice;
								unitPrice = (double) Math.round((unitPrice/currencyRate)*100) / 100;
								orDTO.setUnitPrice(unitPrice);
								orDTO.getRowsList().get(0).setUnitPrice(unitPrice);
								currencyTotalPrice = totalPrice;
								totalPrice = (double) Math.round((totalPrice/currencyRate)*100) / 100;
								/*
								if(orDTO.getRowsList().get(0).getShippingPrice()!=null) {
									currencyShippingPrice = orDTO.getRowsList().get(0).getShippingPrice();
									Double shippingPrice = (double) Math.round((currencyShippingPrice/currencyRate)*100) / 100;
									orDTO.setShippingPrice(shippingPrice);
									orDTO.setShippingFee(shippingPrice);
									orDTO.setCurrencyShippingPrice(currencyShippingPrice);
									orDTO.getRowsList().get(0).setShippingPrice(shippingPrice);
									orDTO.getRowsList().get(0).setShippingFee(shippingPrice);
									orDTO.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
								}
								*/
							}
						}
						orDTO.setTotalPrice(totalPrice);
						orDTO.setCurrencyId(currencyId);
						orDTO.setCurrencySymbol(currencySymbol);
						orDTO.setCurrencyRate(currencyRate);
						orDTO.setCurrencyUnitPrice(currencyUnitPrice);
						orDTO.setCurrencyTotalPrice(currencyTotalPrice);
						
						for(OrdersRows row: orDTO.getRowsList()){
							row.setCurrencyId(currencyId);
							row.setCurrencySymbol(currencySymbol);
							row.setCurrencyRate(currencyRate);
							row.setCurrencyUnitPrice(currencyUnitPrice);
						}
					}	
				}
				listOrdersDTO=orderService.insertListOrders(listOrdersDTO);
				listOrdersDTO=new ArrayList<OrdersDTO>();
				if(listOrdersDTO.size()==0){
					frm = new SimpleDateFormat("yyyyMMdd");
					if(userLogin!=null && userLogin.length()>=2){
						initalClient=userLogin.substring(0, 2);
						initalClient=initalClient.toUpperCase();
					}
					//String lsOrderIdFirstPart="Man"+frm.format(today);
					String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
					String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
					OrdersDTO orderDTO=new OrdersDTO();
					//recovery userId
					if(user!=null)orderDTO.setUserId(user.getId());
					orderDTO.setLsOrderId(manLsOrderId);
					orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					OrdersRows orderRow=new OrdersRows();
					orderRow.setIcon("images/orders/itemNotValidated.png");
					orderDTO.getRowsList().add(orderRow);
					listOrdersDTO.add(orderDTO);
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				}
				message="Saving has completed successfuly";
				showSaveSuccessPop="display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
	 		 -----------------------------------------------------------------------------*/
			if(checkBoxPrintSignal!=null && checkBoxPrintSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				OrdersDTO orderDTOInList=listOrdersDTO.get(indexOrder);
				orderDTOInList=fillDataOrderDTO(orderDTOInList);
				orderDTOInList.setPrint(checkBoxPrint);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}


			/*-------------- When user click on the button OK of showSaveSuccessPop -------
						just hide dialogue popup: showSaveSuccessPop
	 		 ------------------------------------------------------------------------------*/
			if(okSaveSuccessPopSignal!=null && okSaveSuccessPopSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				showSaveSuccessPop="visibility:hidden;display:none;";
				return SUCCESS;
			}



			/*-------------- When user click on the image imgNewLsOrderId -----------------
								generate other LsOrderId
	 		 ------------------------------------------------------------------------------*/
			if(newLsOrderIdSignal!=null && newLsOrderIdSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				OrdersDTO orderDTO=listOrdersDTO.get(0);
				frm = new SimpleDateFormat("yyyyMMdd");
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				//String lsOrderIdFirstPart="Man"+frm.format(today);
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				orderDTO.setLsOrderId(manLsOrderId);
				return SUCCESS;
			}

		} catch (Exception e) {
			addActionError(getText("loyauty.error.common.userNotSelected"));
			e.printStackTrace();
			return "input";
		}
	return SUCCESS;
	}
	

	   /*=========================================================================================
								fill all fields of order without rows
		 =========================================================================================*/
		public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO){
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			//orderToEdit=listOrdersDTO.get(indexOrder);
			orderDTO.setClientLastName(clientLastName);
			orderDTO.setClientFirstName(clientFirstName);
			orderDTO.setClientOtherNames(clientOtherNames); 
			orderDTO.setClientStreet(clientStreet);
			orderDTO.setClientOtherStreet(clientOtherStreet);
			orderDTO.setClientCity(clientCity);
			orderDTO.setClientProvince(clientProvince);
			orderDTO.setClientProvince(clientProvince);
			orderDTO.setClientPostalCode(clientPostalCode);
			orderDTO.setClientPhone(clientPhone);
			orderDTO.setClientEmail(clientEmail);			
			orderDTO.setProductOrderNumber(productOrderNumber);
			
			
			if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strProductOrderDate);
					orderDTO.setProductOrderDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			
			if (((strCreationOrderDate)!=null)&&(!"".equals(strCreationOrderDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationOrderDate);
					orderDTO.setCreationDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			
			if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strRequiredDate);
					orderDTO.setRequiredDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			return orderDTO;
		}


		/*=========================  createUserLogo ===========================
		 				Create  Blank User Logo if not Exist
		  =================================================================*/
		public void createUserLogo(String source, String destination) throws IOException{
			File fileLogo=new File(destination);
			if(!fileLogo.exists()){
				InputStream in = new FileInputStream(source);
				OutputStream out = new FileOutputStream(destination);
				byte[] buf = new byte[1024];
				int len;
				while ((len = in.read(buf)) > 0) {
					out.write(buf, 0, len);
				}
				in.close();
				out.close();	
			}
		}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:16:30.676
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:30.676
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:30.676
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:16:30.677
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:30.677
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 13:16:30.706
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;

import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceException;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OperationsDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.core.dto.UsersPrivilegesDTO;
import com.loyauty.service.operations.OperationsService;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class ReportOrders extends LoyautyAction {
	private static final long serialVersionUID = -3811760851445730062L;
	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	private OperationsService operationsService;
	@Getter
	@Setter
	private String userLogin;
	@Getter
	@Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter
	@Setter
	List<OrdersDTO> listOrdersDTO;
	@Getter
	@Setter
	List<OrdersDTO> listStatus;
	@Getter
	@Setter
	private String lsOrderId;
	@Getter
	@Setter
	Long poYpop;
	@Getter
	@Setter
	Long poXpop;
	@Getter
	@Setter
	private Long pageTop = 0L;
	@Getter
	@Setter
	private Date creationDate;
	@Getter
	@Setter
	private Long findOrdersSignal;
	private String status;
	@Getter
	@Setter
	private Long sizeResult = 0L;
	@Getter
	@Setter
	private Long sorting;
	@Getter
	@Setter
	private Long sortingOrdersSignal;
	@Getter
	@Setter
	private Integer fieldForSorting;
	@Getter
	@Setter
	private Integer asc;
	@Getter
	@Setter
	private Integer scrollDivRowsLeft;
	@Getter
	@Setter
	private Integer scrollPageLeft;
	@Getter
	@Setter
	private Integer scrollDivRowsTop;
	@Getter
	@Setter
	private String strCreationDateStart;
	@Getter
	@Setter
	private String strCreationDateEnd;
	@Getter
	@Setter
	private Date creationDateStart;
	@Getter
	@Setter
	private Date creationDateEnd;
	private Date creationDateStartArg;
	private Date creationDateEndArg;
	@Getter
	@Setter
	private Integer selectedStatus;
	@Getter
	@Setter
	private Long editOrderSignal;
	@Getter
	@Setter
	private Long cancelSignal;
	@Getter
	@Setter
	private Integer indexOrder;
	@Getter
	@Setter
	private OrdersDTO orderToEdit;
	@Getter
	@Setter
	private String strProductOrderDate;
	@Getter
	@Setter
	private String lsProductID;
	@Getter
	@Setter
	Integer indexRow;
	@Getter
	@Setter
	private String showOrderDetailPop;
	@Getter
	@Setter
	private Long userId;
	@Getter
	@Setter
	private Long checkProductPriceSignal;
	@Getter
	@Setter
	private Long saveTemporaryRowSignal;
	@Getter
	@Setter
	private Long addSimilarRowSignal;
	@Getter
	@Setter
	private Long deleteRowSignal;
	@Getter
	@Setter
	private Long saveOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxPrint;

	// recovery Data Order
	@Getter
	@Setter
	private String clientLastName;
	@Getter
	@Setter
	private String clientFirstName;
	@Getter
	@Setter
	private String clientOtherNames;
	@Getter
	@Setter
	private String clientStreet;
	@Getter
	@Setter
	private String clientOtherStreet;
	@Getter
	@Setter
	private String clientCity;
	@Getter
	@Setter
	private String clientProvince;
	@Getter
	@Setter
	private String clientPostalCode;
	@Getter
	@Setter
	private String clientPhone;
	@Getter
	@Setter
	private String clientEmail;
//	@Getter
//	@Setter
//	private String productOrderNumber;
	@Getter
	@Setter
	private String strRequiredDate;

	// recovery data row
	@Getter
	@Setter
	private Double quantity;
	@Getter
	@Setter
	private String notes;
	@Getter
	@Setter
	private Double quantityToChange;
	@Getter
	@Setter
	private Double stock;
	@Getter
	@Setter
	private String productDescription;
	@Getter
	@Setter
	private Double unitPrice;
	@Getter
	@Setter
	private Double shippingFee;
	@Getter
	@Setter
	private String shippingCompany;
	@Getter
	@Setter
	private String companyHeader;

	@Getter
	@Setter
	private Long quantityToChangeSignal;
	@Getter
	@Setter
	private Long duplicateOrderSignal;
	@Getter
	@Setter
	private String strCreationDate;
	@Getter
	@Setter
	private String strCreationOrderDate;
	@Getter
	@Setter
	private User usr;
	@Getter
	@Setter
	private String showSaveSuccessPop;
	// showSaveSuccessPop="display:block;visibility:visible;";
	// showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter
	@Setter
	private String message;
	@Getter
	@Setter
	private Long okSaveSuccessPopSignal;
	@Getter
	@Setter
	private Long showRowShipping;
	@Getter
	@Setter
	private Long showOnlyEditNote;
	@Getter
	@Setter
	private Long saveShippingSignal;
	@Getter
	@Setter
	private Long saveOnlyNoteSignal;
	@Getter
	@Setter
	private String code;
	@Getter
	@Setter
	private Long cityId;
	@Getter
	@Setter
	private List<ProvinceDTO> listProvinces;
	private Hashtable<String, ProvinceDTO> hashProvinces;
	@Getter
	@Setter
	private Boolean orderNotSavedAtFirst;
	@Getter
	@Setter
	private String strShippedDate;
	@Getter
	@Setter
	private String strShippingPrice;
	@Getter
	@Setter
	private String showConfirmDeleteOrderPop;
	@Getter
	@Setter
	private Long deleteOrderSignal;
	@Getter
	@Setter
	private Long confirmDeleteSignal;
	@Getter
	@Setter
	private UsersPrivilegesDTO userPrivileges;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivShippedToInvoiced;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivChangeShippedStatus;
	@Getter
	@Setter
	private HashMap<Integer, String> hashStatus;
	@Getter
	@Setter
	private Long statusId;
	@Getter
	@Setter
	private String strPrint;
	@Getter
	@Setter
	private Integer testSignal;
	@Getter
	@Setter
	private String newStatus;
	Long invoicedOrdersRefresh;
	@Getter
	@Setter
	private Integer reportDateBetween;
	@Getter
	@Setter
	private Long dateBetweenSignal;
	@Getter
	@Setter
	private Long selectAllOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxItem;
	// ------Pagination
	@Getter
	@Setter
	Long pageIndexSignal;
	@Getter
	@Setter
	Long prevListPagesSignal;
	@Getter
	@Setter
	Long nextListPagesSignal;
	@Getter
	@Setter
	Long totalOrders;
	@Getter
	@Setter
	Integer nextListPages;
	@Getter
	@Setter
	Integer prevListPages;
	@Getter
	@Setter
	Integer indexSet = 0;
	@Getter
	@Setter
	Integer indexList;
	@Getter
	@Setter
	List<OrdersDTO> listIndexSet;
	@Getter
	@Setter
	Integer PAGE_ITEMS_COUNT = 100;
	
	//New Added Field in the search option as toggle functionality
	@Getter
	@Setter
	private String productOrderNumberSearch;
	@Getter
	@Setter
	private String trakingNumber;
	@Getter
	@Setter
	private String  clientOther;
	@Getter
	@Setter
	private String	 clientOrderNumber;
	//New Added Field in the search option as toggle functionality

	// ------Pagination

	/*
	 * ==========================================================================
	 * =============== Default constructor
	 * ======================================
	 * ===================================================
	 */
	public ReportOrders() throws ServiceLocatorException {
		super();
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		productService = getServiceLocator().getProductService();
		operationsService = getServiceLocator().getOperationsService();
	}

	/*
	 * ==========================================================================
	 * =============== method execute
	 * ============================================
	 * =============================================
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		System.out.println("Product Order Number: "+ productOrderNumberSearch);
		System.out.println("Tracking Number: "+ trakingNumber);
		System.out.println("Client Order ID: "+ clientOrderNumber);
		System.out.println("Client Other ID: "+ clientOther);
		
		HttpSession session = request.getSession(true);

		if (showOrderDetailPop == null)
			showOrderDetailPop = "visibility:hidden;display:none;";
		if (showConfirmDeleteOrderPop == null)
			showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
		if (showSaveSuccessPop == null)
			showSaveSuccessPop = "visibility:hidden;display:none;";
		if (poYpop == null)
			poYpop = 100L;
		if (poXpop == null)
			poXpop = 100L;
		Hashtable<String, OrdersDTO> hashOrders;
		if (selectedStatus == null)
			selectedStatus = -1;
		sizeResult = (Long) session.getAttribute("sizeResult");
		totalOrders = (Long) session.getAttribute("totalOrders");
		if (totalOrders == null)
			totalOrders = 0L;
		asc = (Integer) session.getAttribute("asc");
		if (asc == null)
			asc = 0;
		if (sizeResult == null)
			sizeResult = 0L;
		if (indexOrder == null)
			indexOrder = 0;
		userPrivileges = (UsersPrivilegesDTO) session.getAttribute("userPrivileges");
		usersPrivShippedToInvoiced = (UsersPrivilegesDTO) session.getAttribute("usersPrivShippedToInvoiced");
		usersPrivChangeShippedStatus = (UsersPrivilegesDTO) session
				.getAttribute("usersPrivChangeShippedStatus");
		hashStatus = (HashMap<Integer, String>) session
				.getAttribute("hashStatus");
		if (hashStatus == null) {
			hashStatus = new HashMap<Integer, String>();
			hashStatus.put(0, "");
			hashStatus.put(1, "open");
			hashStatus.put(2, "progress");
		}
		List<Integer> listIndexColumn = new ArrayList<Integer>();
		// fill list status
		listStatus = (ArrayList<OrdersDTO>) session.getAttribute("listStatus");
		if (listStatus == null) {
			listStatus = new ArrayList<OrdersDTO>();
			OrdersDTO orderDTOOpen = new OrdersDTO();
			orderDTOOpen.setStatus("open");
			orderDTOOpen.setId(0L);
			listStatus.add(orderDTOOpen);
			OrdersDTO orderDTOProgress = new OrdersDTO();
			orderDTOProgress.setStatus("progress");
			orderDTOProgress.setId(1L);
			listStatus.add(orderDTOProgress);
			if (usersPrivChangeShippedStatus != null) {
				OrdersDTO orderDTOShipped = new OrdersDTO();
				orderDTOShipped.setStatus("shipped");
				orderDTOShipped.setId(2L);
				listStatus.add(orderDTOShipped);
			}

		}

		try {

			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			// recovery provinces
			listProvinces = (List<ProvinceDTO>) session
					.getAttribute("listProvinces");
			if (listProvinces == null)
				listProvinces = productService.getAllProvinces();
			orderNotSavedAtFirst = (Boolean) session
					.getAttribute("listNotSavedAtFirst");
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession = (List<User>) session
					.getAttribute("usersListSession");
			if (usersListSession == null) {
				List<UserSessionDTO> listAllUsers = userService
						.getAllUsers(basicUserDTO);
				usersList = new ArrayList<User>();
				for (UserSessionDTO userDTO : listAllUsers) {
					User user = new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession", usersList);
			} else
				usersList = usersListSession;
			listOrdersDTO = (ArrayList<OrdersDTO>) session
					.getAttribute("listOrdersDTOReport");
			reportDateBetween = (Integer) session
					.getAttribute("reportDateBetween");
			if (reportDateBetween == null) {
				reportDateBetween = 0;
				session.setAttribute("reportDateBetween", reportDateBetween);
			}

			/*------ always check if the Admin select all orders ------------
					if The Admin select all orders change checkBoxItem value 
			  ---------------------------------------------------------------*/
			if (selectAllOrdersSignal != null && selectAllOrdersSignal != 0L) {
				if (checkBoxItem != null) {
					session.setAttribute("checkBoxItem", checkBoxItem);
					session.setAttribute("allOrdersSelectedSignal", 0L);
					if (checkBoxItem)
						session.setAttribute("allOrdersSelectedSignal", 1L);
				}
			}
			checkBoxItem = (Boolean) session.getAttribute("checkBoxItem");
			if (checkBoxItem == null)
				checkBoxItem = false;
			/*------ always recovery creationDate from strCreationDate ------
						always keep the user search options
			  ---------------------------------------------------------------*/
			creationDateStart = null;
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			if (((strCreationDateStart) != null)
					&& (!"".equals(strCreationDateStart))) {
				try {
					Date date = frm.parse(strCreationDateStart);
					creationDateStart = date;
					creationDateStartArg = date;
				} catch (Exception pe) {
					creationDateStart = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateStart == null) {
				Date date = frm.parse("01/01/1900");
				creationDateStartArg = date;
			}
			creationDateEnd = null;
			if (((strCreationDateEnd) != null)
					&& (!"".equals(strCreationDateEnd))) {
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationDateEnd);
					creationDateEnd = date;
					creationDateEndArg = date;
				} catch (Exception pe) {
					creationDateEnd = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateEnd == null) {
				creationDateEndArg = new Date();
			}

			/*------ always recovery Status from selectedStatus key ------
						always keep the status search options
			  ---------------------------------------------------------------*/
			status = getStatusSelected(selectedStatus);

			/*----------- always initialized listPages if not done ----------
				   		    and check if is there next listPages
			  ---------------------------------------------------------------*/
			nextListPages = (Integer) session.getAttribute("nextListPages");
			if (nextListPages == null)
				nextListPages = 0;
			if (indexSet == null || indexSet == -1) {
				indexSet = (Integer) session.getAttribute("indexSet");
				if (indexSet == null)
					indexSet = 0;
			}
			listIndexSet = (List<OrdersDTO>) session
					.getAttribute("listIndexSet");
			if (listIndexSet == null)
				initalizeListIndexSet(session, orderService);

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/

			if (dateBetweenSignal != null && dateBetweenSignal != 0L) {
				reportDateBetween = ((reportDateBetween == null || reportDateBetween == 0) ? 1
						: 0);
				listOrdersDTO = new ArrayList<OrdersDTO>();
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("reportDateBetween", reportDateBetween);
				return SUCCESS;
			}

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/
			if (pageIndexSignal != null && pageIndexSignal != 0L) {
				OrdersDTO orderDTO = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTO != null)
					orderDTO.setCssStyle("");
				OrdersDTO orderPageSelected = listIndexSet.get(indexList);
				orderPageSelected
						.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
				indexSet = orderPageSelected.getIndex() - 1;
				indexSet = indexSet * PAGE_ITEMS_COUNT;
				session.setAttribute("indexSet", indexSet);
				session.setAttribute("listIndexSet", listIndexSet);
				session.setAttribute("orderPageSelected", orderPageSelected);
			}

			/*----------------- When Admin Click on the nextListPages ------------------------------
						recreate listIndexSet started with index>index+10 and indexSet>indexSet+10
			 ---------------------------------------------------------------------------------------*/
			if (nextListPagesSignal != null && nextListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				OrdersDTO orderDTO = listIndexSet.get(listIndexSet.size() - 1);
				if (orderDTO != null)
					nextListPages = orderDTO.getIndex() + 1;
				Long totalOrders = orderService.getCountOrders(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status);
				String strcount = totalOrders.toString();
				Integer sizeList = Integer.parseInt(strcount)
						/ PAGE_ITEMS_COUNT;
				if (nextListPages <= sizeList + 1) {
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = nextListPages; i <= sizeList + 1
							&& i <= nextListPages + 10; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					if (nextListPages <= sizeList + 1) {
						indexSet = nextListPages - 1;
						OrdersDTO orderPageSelected = listIndexSet.get(0);
						orderPageSelected
								.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
						indexSet = indexSet * PAGE_ITEMS_COUNT;
						session.setAttribute("indexSet", indexSet);
						session.setAttribute("nextListPages", nextListPages);
						session.setAttribute("listIndexSet", listIndexSet);
						session.setAttribute("orderPageSelected",
								orderPageSelected);
					}
				}
			}

			/*----------------- When Admin Click on the previousListPages --------------------------
					recreate listIndexSet started with index< index-10 and indexSet<indexSet-10
			 ---------------------------------------------------------------------------------------*/
			if (prevListPagesSignal != null && prevListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				nextListPages = (Integer) session.getAttribute("nextListPages");
				if (nextListPages != null && nextListPages >= 11) {
					prevListPages = nextListPages - 11;
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = prevListPages; i < nextListPages; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					indexSet = prevListPages - 1;
					OrdersDTO orderPageSelected = listIndexSet.get(0);
					orderPageSelected
							.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
					indexSet = indexSet * PAGE_ITEMS_COUNT;
					nextListPages = prevListPages;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("indexSet", indexSet);
					session.setAttribute("listIndexSet", listIndexSet);
					session.setAttribute("orderPageSelected", orderPageSelected);
				}
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			hashProvinces = (Hashtable<String, ProvinceDTO>) session
					.getAttribute("hashProvinces");
			if (hashProvinces == null) {
				listProvinces = productService.getAllProvinces();
				Hashtable<String, ProvinceDTO> hashProvinces = new Hashtable<String, ProvinceDTO>();
				for (ProvinceDTO prov : listProvinces) {
					hashProvinces.put(prov.getCode(), prov);
				}
				session.setAttribute("hashProvinces", hashProvinces);
			}
			if (code != null && !code.equals("") && listOrdersDTO != null) {
				ProvinceDTO provinceDTO = hashProvinces.get(code);
				if (provinceDTO != null) {
					clientProvince = provinceDTO.getCode();
				}
			}// else listCities=new ArrayList<CityDTO>();
			if (listOrdersDTO != null && indexOrder != -1) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit != null) {
					orderToEdit.setClientProvince(code);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				}
			}

			/*------------------------------- Refresh listOrdersDTO------------------------------------
						Refresh listOrders before generation of invoiced orders XLS file 
				 ------------------------------------------------------------------------------------------*/
			invoicedOrdersRefresh = (Long) session
					.getAttribute("invoicedOrdersRefresh");
			if (invoicedOrdersRefresh != null && invoicedOrdersRefresh != 0L) {
				listIndexColumn = (ArrayList<Integer>) session
						.getAttribute("listIndexColumn");
				if (listIndexColumn == null)
					listIndexColumn = getNewListIndexColumn();
				lsOrderId = lsOrderId.toUpperCase();
				//Searching Functionality 
				
				//Create new object or Order to modify the search functinality
				OrdersDTO orderDTO=new OrdersDTO();
				orderDTO.setLsOrderId(lsOrderId);
				orderDTO.setUserLogin(userLogin);
				orderDTO.setStatus(newStatus);
				orderDTO.setProductOrderNumber(productOrderNumberSearch);
				orderDTO.setClientOrderNumber(clientOrderNumber);
				orderDTO.setClientOtherId(clientOther);
				
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween,orderDTO,listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				indexSet = 0;
				session.setAttribute("indexSet", indexSet);
				nextListPages = 0;
				session.setAttribute("nextListPages", nextListPages);
				session.setAttribute("selectedStatus", selectedStatus);
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("invoicedOrdersRefresh", 0L);
				return SUCCESS;
			}

			/*------------ When Admin click on the Button "Delete Order" in The OrderDtailPop --------------
								show other pop to confirm Order Delete
			  ----------------------------------------------------------------------------------------------*/
			if (deleteOrderSignal != null && deleteOrderSignal != 0L) {
				message = "Attention! if you click on \"Delete Order\" you can not restore it.";
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (confirmDeleteSignal != null && confirmDeleteSignal == 0L) { // Delete
																				// Order
																				// Request
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "display:block;visibility:visible;";
				} else if (confirmDeleteSignal == 1L) { // Delete Order
														// Confirmed
					orderService.deleteOrderByLsOrderId(orderToEdit);
					// Save this operation in table operation
					OperationsDTO operationDTO = new OperationsDTO();
					User userAdmin = (User) session.getAttribute("userAdmin");
					if (userAdmin != null)
						operationDTO.setUserId(userAdmin.getId());
					operationDTO.setOperationDate(new Date());
					operationDTO.setOperationType("Delete Order");
					String dataBefore = "[PARTNER NAME:"
							+ orderToEdit.getUserLogin() + "];";
					dataBefore += " [LS_ORDER_ID:" + orderToEdit.getLsOrderId()
							+ "];";
					dataBefore += " [PRODUCT_ORDER_NUMBER:"
							+ orderToEdit.getProductOrderNumber() + "];";
					dataBefore += " [CLIENT_FIRST_NAME:"
							+ orderToEdit.getClientFirstName() + "];";
					dataBefore += " [CLIENT_LAST_NAME:"
							+ orderToEdit.getClientLastName() + "];";
					dataBefore += " [CLIENT_POSTAL_CODE:"
							+ orderToEdit.getClientPostalCode() + "];";
					dataBefore += " [LS_PRODUCT_ID:"
							+ orderToEdit.getLsProductID() + "];";
					dataBefore += " [UNIT_PRICE:" + orderToEdit.getUnitPrice()
							+ "];";
					dataBefore += " [STATUS:" + orderToEdit.getStatus() + "];";
					operationDTO.setDataBefore(dataBefore);
					operationDTO.setDataBefore(operationDTO.getDataBefore());
					operationDTO.setDataAfter("");
					operationsService.insertOperation(operationDTO);
					// Remove order from the list orders
					listOrdersDTO.remove(orderToEdit);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					showOrderDetailPop = "visibility:hidden;display:none;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
					// initialize index orders
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				} else { // Cancel Order Delete
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
				}
				return SUCCESS;
			}

			/*------ When Admin click the "Edit link" in the Order Table for Edit NOTE -----
							show only field Edit Note
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showOnlyEditNote != null && showOnlyEditNote != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowOnlyEditNote(0L);
					order.setCssRow("");
				}
				orderToEdit.setShowOnlyEditNote(1L);
				orderToEdit.setCssRow("background-color:#FF9966;");
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (ArrayList<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save Edit Note in the Orders Table" ----------
													save Only  notes
			  -------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOnlyNoteSignal != null && saveOnlyNoteSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						orderToEdit.setNotes(notes);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						orderToEdit.setCssRow("");
						// Save Note
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click the "Edit link" in the Order Table -------------
								show fields to edit shipping parameters
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showRowShipping != null && showRowShipping != 0L) {

				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowRowShipping(0L);
					order.setCssRow("");
				}
				// only Admins who has Active = true of action name='All' can
				// change shipping settings
				// of orders shipped or invoiced
				if (usersPrivChangeShippedStatus == null
						&& orderToEdit.getStatus() != null
						&& (orderToEdit.getStatus().equals("shipped") || orderToEdit
								.getStatus().equals("invoiced"))) {
					showRowShipping = 0L;
					return SUCCESS;
				}

				if (orderToEdit != null) {
					orderToEdit.setShowRowShipping(1L);
					orderToEdit.setShowOnlyEditNote(1L);
					orderToEdit.setCssRow("background-color:#FF9966;");
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (ArrayList<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				if (orderToEdit.getStatus().equals("open")) {
					statusId = 0L;
				} else if (orderToEdit.getStatus().equals("progress")) {
					statusId = 1L;
				} else if (orderToEdit.getStatus().equals("shipped")) {
					statusId = 2L;
				} else if (orderToEdit.getStatus().equals("invoiced")) {
					statusId = 3L;
				} else if (orderToEdit.getStatus().equals("canceled")) {
					statusId = 4L;
				}
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save in the Orders Table" ----------
							save all shipping parameters and notes
			 ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveShippingSignal != null && saveShippingSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						Date shippedDateToEdit = null;
						frm = new SimpleDateFormat("dd/MM/yyyy");
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))) {
							strShippedDate = strShippedDate.replaceAll(" ", "");
							try {
								Date date = frm.parse(strShippedDate);
								shippedDateToEdit = date;
							} catch (Exception pe) {
								shippedDateToEdit = null;
							}
						}
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))
								&& strShippedDate.length() <= 8)
							shippedDateToEdit = orderToEdit.getShippedDate();
						Double shippingPrice = null;
						// Double currencyShippingPrice=null;
						if (strShippingPrice != null
								&& !strShippingPrice.equals("")) {
							strShippingPrice = strShippingPrice.replaceAll(" ",
									"");
							int index = strShippingPrice.indexOf(",");
							if (index >= 0) {
								String strUnitPrice1 = strShippingPrice
										.substring(0, index);
								String strUnitPrice2 = strShippingPrice
										.substring(index + 1,
												strShippingPrice.length());
								strShippingPrice = strUnitPrice1 + "."
										+ strUnitPrice2;
							}

							try {
								shippingPrice = Double
										.parseDouble(strShippingPrice);
								/*
								 * if(shippingPrice!=null &&
								 * orderToEdit.getCurrencyId()!=null &&
								 * orderToEdit.getCurrencyId()!=1 &&
								 * orderToEdit.getCurrencyRate()!=null) {
								 * currencyShippingPrice = shippingPrice *
								 * orderToEdit.getCurrencyRate();
								 * currencyShippingPrice = (double)
								 * Math.round(currencyShippingPrice*100)/100; }
								 */
							} catch (Exception pe) {
								shippingPrice = null;
							}
						}

						if (trakingNumber != null)
							trakingNumber = trakingNumber.replaceAll(
									"^ +| +$|( )+", "$1");
						if (shippingCompany != null)
							shippingCompany = shippingCompany.replaceAll(
									"^ +| +$|( )+", "$1");
						orderToEdit.setShippingPrice(shippingPrice);
						// orderToEdit.setCurrencyShippingPrice(currencyShippingPrice);
						// orderToEdit.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
						orderToEdit.setShippedDate(shippedDateToEdit);
						orderToEdit.setNotes(notes);
						if (newStatus != null && !newStatus.equals(""))
							orderToEdit.setStatus(newStatus);
						orderToEdit.setShippingCompany(shippingCompany);
						orderToEdit.setTrackingNumber(trakingNumber);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						OrdersRows row = orderToEdit.getRowsList().get(0);
						row.setShippingPrice(shippingPrice);
						row.setShippingCompany(shippingCompany);
						row.setTrackingNumber(trakingNumber);
						orderToEdit.setCssRow("");

						if (newStatus != null && !newStatus.equals("")) { // if
																			// admin
																			// click
																			// on
																			// the
																			// save
																			// behind
																			// status
							orderService.updateStatusByLsOrderId(
									orderToEdit.getLsOrderId(), newStatus);
							orderToEdit.setStatus(newStatus);
							if (!newStatus.equals("shipped")
									&& !newStatus.equals("invoiced")
									&& !newStatus.equals("canceled")) {
								orderToEdit.setShippingPrice(null);
								orderToEdit.setTrackingNumber(null);
								orderToEdit.setShippedDate(null);
							}

						} else {// if admin click on the save other than Status
							if (orderToEdit.getShippedDate() != null
									&& orderToEdit.getTrackingNumber() != null
									&& !orderToEdit.getTrackingNumber().equals(
											"")
									&& orderToEdit.getShippingCompany() != null
									&& !orderToEdit.getShippingCompany()
											.equals("")
									&& orderToEdit.getShippingPrice() != null
									&& orderToEdit.getStatus() != null) {
								if (orderToEdit.getStatus().equals("open")
										|| orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"shipped");
									orderToEdit.setStatus("shipped");
								}
							} else {
								if (usersPrivChangeShippedStatus != null
										&& !orderToEdit.getStatus().equals(
												"open")
										&& !orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"progress");
									orderToEdit.setStatus("progress");
								}
							}
						}
						// if admin click on the save other then status(save
						// notes, save shipping company ...)
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click on icon findOrders.png ----------
								check user and complete infos client
			 ----------------------------------------------------------------*/
			if (findOrdersSignal != null
					&& findOrdersSignal != 0L
					|| (pageIndexSignal != null && pageIndexSignal != 0L)
					|| (nextListPagesSignal != null && nextListPagesSignal != 0L)
					|| (prevListPagesSignal != null && prevListPagesSignal != 0L)) {
				// session.setAttribute("allOrdersSelectedSignal",0L);
				// if admin click on search icon initialize checkBoxItem to
				// false
				if (findOrdersSignal != null && findOrdersSignal != 0L) {
					session.setAttribute("allOrdersSelectedSignal", 0L);
					checkBoxItem = false;
					session.setAttribute("checkBoxItem", checkBoxItem);
					indexSet = 0;
					session.setAttribute("indexSet", indexSet);
					nextListPages = 0;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("selectedStatus", selectedStatus);

				}
				// if admin navigate on pages keep the previous sorting
				if (((pageIndexSignal != null && pageIndexSignal != 0L)
						|| (nextListPagesSignal != null && nextListPagesSignal != 0L) || (prevListPagesSignal != null && prevListPagesSignal != 0L))) {
					listIndexColumn = (ArrayList<Integer>) session
							.getAttribute("listIndexColumn");
					if (listIndexColumn == null)
						listIndexColumn = getNewListIndexColumn();
				} else { // prepare new sorting
					listIndexColumn = getNewListIndexColumn();
				}

				lsOrderId = lsOrderId.toUpperCase();
				// if(findOrdersSignal!=null &&
				// findOrdersSignal!=0L)initalizeListIndexSet(session,orderService
				// );
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);

				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("sizeResult", sizeResult);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				return SUCCESS;
			}

			/*------------ When Admin click on the icon sorting of column ----------
							seach result with option of sorting list
			 -----------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& sortingOrdersSignal != null && sortingOrdersSignal != 0L) {
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				asc = (asc == 1 ? -1 : 1);
				int nextElement = listIndexColumn.get(0);
				fieldForSorting = asc * fieldForSorting;
				listIndexColumn.set(0, fieldForSorting);
				for (int i = 1; i < listIndexColumn.size(); i++) {
					int element = listIndexColumn.get(i);
					listIndexColumn.set(i, nextElement);
					nextElement = element;
				}
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				int balance = 0;
				int OrderIndex = 0;
				for (OrdersDTO orDTO : listOrdersDTO) {
					balance = (balance == 1 ? 0 : 1);
					if (balance == 1) {
						orDTO.setCssStyle("background-color: rgb(245,249,252);border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					} else {
						orDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					}
					orDTO.setIndex(OrderIndex);
					OrderIndex++;
				}
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("asc", asc);
				return SUCCESS;
			}

			/*------ when Admin click on the lsOrder link in table -----------
					show popup detail and allow admin to update Order
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& editOrderSignal != null && editOrderSignal != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit == null)
					orderToEdit = new OrdersDTO();
				if (orderToEdit.getProductOrderDate() == null)
					strProductOrderDate = "";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*--- when Admin click on the cancel Button of orderDetailPop ---
					we mast just hide popup OrderDetail
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& cancelSignal != null && cancelSignal != 0L) {
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}

			/*-------------------- When Admin left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& checkProductPriceSignal != null
					&& checkProductPriceSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToUpadate = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				UserProductPriceDTO userProductPrice = productService
						.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if (userProductPrice == null) {
					orderRowToUpadate.setCss("background-color:red;");
					orderRowToUpadate.setProductDescription("");
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				} else {
					Double usrPrice = orderRowToUpadate.getUnitPrice();
					if (usrPrice == null)
						usrPrice = 0D;
					if (usrPrice < userProductPrice.getPriceNum()) {
						orderRowToUpadate.setCssPrice("background-color:red;");
					}
					orderRowToUpadate.setProductDescription(userProductPrice
							.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice
							.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice
							.getLsProductId());
					orderRowToUpadate
							.setLsPrice(userProductPrice.getPriceNum());
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = orderDTOToUpdate;
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*----------------- When Admin check on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveTemporaryRowSignal != null
					&& saveTemporaryRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToSaveMemory = orderDTOToUpdate
						.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if (orderRowToSaveMemory != null) {
					orderRowToSaveMemory.setQuantity(quantity);
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory
							.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory
							.setCssPrice("background-color:#FF6666;");
					orderRowToSaveMemory
							.setCssQuantity("background-color:#FF6666;");
					if (quantity != null && quantity > 0D)
						orderRowToSaveMemory.setCssQuantity("");
					if (unitPrice != null
							&& orderRowToSaveMemory.getLsPrice() != null
							&& unitPrice >= orderRowToSaveMemory.getLsPrice())
						orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trakingNumber);
					if (orderRowToSaveMemory.getCurrencyId() != null
							&& orderRowToSaveMemory.getCurrencyId() != 1
							&& orderRowToSaveMemory.getCurrencyRate() != null) {
						if (unitPrice != null) {
							orderRowToSaveMemory
									.setCurrencyUnitPrice(unitPrice);
							unitPrice = unitPrice
									/ orderRowToSaveMemory.getCurrencyRate();
							unitPrice = (double) Math.round(unitPrice * 100) / 100;
							orderRowToSaveMemory.setUnitPrice(unitPrice);
						}
						/*
						 * if(shippingFee!=null) {
						 * orderRowToSaveMemory.setCurrencyShippingPrice
						 * (shippingFee); shippingFee =
						 * shippingFee/orderRowToSaveMemory.getCurrencyRate();
						 * shippingFee = (double)
						 * Math.round(shippingFee*100)/100;
						 * orderRowToSaveMemory.setShippingPrice(shippingFee); }
						 */
					}
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				// Change totalPrice also
				if (orderToEdit.getRowsList().get(0) != null
						&& orderToEdit.getRowsList().get(0).getQuantity() != null
						&& orderToEdit.getRowsList().get(0)
								.getQuantityToSplit() != null
						&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
					Double priceTotal = orderToEdit.getRowsList().get(0)
							.getUnitPrice()
							* orderToEdit.getRowsList().get(0)
									.getQuantityToSplit();
					priceTotal = (double) Math.round(priceTotal * 100) / 100;
					orderToEdit.setTotalPrice(priceTotal);
				}
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------- When Admin click on addSimilarRow Icon on the OrderDetailPop --------
								Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& addSimilarRowSignal != null && addSimilarRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				// generate lsOrderId to new order
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				if (orderRowToClone != null) {
					if (!orderRowToClone.getIcon().equals(
							"images/orders/itemValidated.png")) {
						orderRowToClone.setQuantity(quantity);
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone
								.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trakingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd = DTOFactory
							.getOrderRowClone(orderRowToClone);
					orderRowToAdd.setId(-1L);
					// Add currencyId
					if (orderRowToClone.getCurrencyId() != null)
						orderRowToAdd.setCurrencyId(orderRowToClone
								.getCurrencyId());

					orderDTOToUpdate.getRowsList().add(indexRow + 1,
							orderRowToAdd);
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------- When Admin click on Delete Row Icon of orderDetail Popup-----------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& deleteRowSignal != null && deleteRowSignal != 0L) {
				OrdersDTO orderDTO = listOrdersDTO.get(indexOrder);
				orderDTO = fillDataOrderDTO(orderDTO);
				int nb = orderService.nbOrderRowsNotDeleted(orderDTO
						.getRowsList());
				if (orderDTO != null && orderDTO.getRowsList().size() > 1) {
					for (int i = 0; i < orderDTO.getRowsList().size(); i++) {
						if (i == indexRow && nb > 1) {
							orderDTO.getRowsList().get(i).setToDelete(1);
							break;
						}
					}
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ when Admin click on the button save of orderDetail ------------------
					 save order and hide pup  
			  ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOrdersSignal != null && saveOrdersSignal != 0L) {
				session.setAttribute("orderNotSavedAtFirst", null);
				orderToEdit = listOrdersDTO.get(indexOrder);
				orderToEdit = fillDataOrderDTO(orderToEdit);

				// add special handling shipping
				User user = null;
				if (orderToEdit.getUserLogin() != null)
					user = userService.getUserByLogin(orderToEdit
							.getUserLogin());
				if (user != null) {
					Double totalPrice = null;
					orderToEdit.setSpecialHandlingName(user
							.getSpecialHandlingName());
					orderToEdit.setSpecialHandlingFee(user
							.getSpecialHandlingFee());
					if (orderToEdit.getRowsList().get(0).getQuantity() != null
							&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
						totalPrice = orderToEdit.getRowsList().get(0)
								.getQuantity()
								* orderToEdit.getRowsList().get(0)
										.getUnitPrice();
						totalPrice = (double) Math.round(totalPrice * 100) / 100;
					}

					orderToEdit.setTotalPrice(totalPrice);
				}

				orderService.updateOrderByLsOrderId(orderToEdit);
				for (OrdersRows row : orderToEdit.getRowsList()) {
					if (row.getId() == -1)
						row.setId(0L);
				}
				OrdersRows row = orderToEdit.getRowsList().get(0);
				if (row != null) {
					orderToEdit.getShippedDate();
					orderToEdit.setLsPrice(row.getLsPrice());
					orderToEdit.setLsProductID(row.getLsProductID());
					orderToEdit.setProductDescription(row
							.getProductDescription());
					orderToEdit.setQuantity(row.getQuantity());
				}
				orderToEdit = DTOFactory.getOrderDTOConsideredMissingInfo(
						orderToEdit, hashProvinces);
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				message = "Saving has completed successfuly";
				showSaveSuccessPop = "display:block;visibility:visible;";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ When user change Quantity to split in orderDetailPop -----------
					 prepare order to split from two other orders witch
				 	 one must have a lsOrder with underscore 
			 ------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& quantityToChangeSignal != null
					&& quantityToChangeSignal != 0L) {
				OrdersDTO orderToChangeQt = listOrdersDTO.get(indexOrder);
				OrdersRows orderRow = orderToChangeQt.getRowsList().get(
						indexRow);
				orderToChangeQt = fillDataOrderDTO(orderToChangeQt);
				if (quantityToChange < orderRow.getQuantity())
					orderRow.setQuantityToSplit(quantityToChange);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- Duplicate Order ----------------------------------------
							Create order in just in memory
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& duplicateOrderSignal != null
					&& duplicateOrderSignal != 0L) {
				OrdersDTO orderToClone = listOrdersDTO.get(indexOrder);
				orderToClone = fillDataOrderDTO(orderToClone);
				hashOrders = new Hashtable<String, OrdersDTO>();
				for (OrdersDTO ord : listOrdersDTO) {
					hashOrders.put(ord.getLsOrderId(), ord);
				}
				OrdersDTO orderClone = DTOFactory
						.getOrderDTOSplitted(orderToClone);
				if (orderClone != null) {
					orderClone.setDuplicate(true);
					String lsOrder = orderClone.getLsOrderId();
					String strlsOrder = orderService.generateLsOrderId(lsOrder,
							hashOrders);
					orderClone.setLsOrderId(strlsOrder);// rgb(116,180,209)
					orderClone
							.setCssStyle("background-color:#FFFF99;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					orderToEdit = orderClone;
					orderToEdit.setBackgroundColor("background-color:#FFFF99;");
					listOrdersDTO.add(indexOrder + 1, orderClone);
					indexOrder = 0;
					for (OrdersDTO ord : listOrdersDTO) {
						ord.setIndex(indexOrder);
						indexOrder++;
					}
					orderService.updateOrderByLsOrderId(orderToClone);
					orderService.insertOrderWithRows(orderClone);
					orderClone.setDuplicate(false);
					for (OrdersRows row : orderClone.getRowsList()) {
						if (row.getId() < 0L)
							row.setId(0L);
					}
					if (listOrdersDTO.size() > 0) {
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				} else
					orderToEdit = orderToClone;
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& okSaveSuccessPopSignal != null
					&& okSaveSuccessPopSignal != 0L) {
				showSaveSuccessPop = "visibility:hidden;display:none;";
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}

	/*
	 * ==========================================================================
	 * =============== fill all fields of order without rows
	 * ====================
	 * =====================================================================
	 */
	public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO) {
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		orderDTO.setClientLastName(clientLastName);
		orderDTO.setClientFirstName(clientFirstName);
		orderDTO.setClientOtherNames(clientOtherNames);
		orderDTO.setClientStreet(clientStreet);
		orderDTO.setClientOtherStreet(clientOtherStreet);
		orderDTO.setClientCity(clientCity);
		orderDTO.setClientProvince(code);
		orderDTO.setClientPostalCode(clientPostalCode);
		orderDTO.setClientPhone(clientPhone);
		orderDTO.setClientEmail(clientEmail);
		orderDTO.setProductOrderNumber(productOrderNumberSearch);
		orderDTO.setCompanyHeader(companyHeader);
		if (((strProductOrderDate) != null)
				&& (!"".equals(strProductOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strProductOrderDate);
				orderDTO.setProductOrderDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strCreationOrderDate) != null)
				&& (!"".equals(strCreationOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strCreationOrderDate);
				orderDTO.setCreationDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strRequiredDate) != null) && (!"".equals(strRequiredDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strRequiredDate);
				orderDTO.setRequiredDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}
		return orderDTO;
	}

	/*
	 * ==========================================================================
	 * =============== initialize ListIndexSet
	 * ==================================
	 * =======================================================
	 */
	public void initalizeListIndexSet(HttpSession session,
			OrdersService orderService) throws ServiceException {
		listIndexSet = new ArrayList<OrdersDTO>();
		totalOrders = orderService.getCountOrders(creationDateStartArg,
				creationDateEndArg, reportDateBetween, userLogin, lsOrderId,
				status);
		String strcount = totalOrders.toString();
		Integer sizeList = Integer.parseInt(strcount) / PAGE_ITEMS_COUNT;
		nextListPages = 1;
		session.setAttribute("nextListPages", nextListPages);
		for (int i = 1; i <= sizeList + 1 && i <= 11; i++) {
			OrdersDTO ord = new OrdersDTO();
			ord.setCssStyle("");
			ord.setIndex(i);
			listIndexSet.add(ord);
		}
		indexSet = 0;
		session.setAttribute("indexSet", indexSet);
		session.setAttribute("totalOrders", totalOrders);
		session.setAttribute("listIndexSet", listIndexSet);

	}

	/*
	 * ==========================================================================
	 * =============== initialize listIndexColumn
	 * ================================
	 * =========================================================
	 */
	List<Integer> getNewListIndexColumn() {
		List<Integer> reult = new ArrayList<Integer>();
		for (int i = 0; i <= 34; i++) {
			if (i != 2 && i <= 13) {
				reult.add(i);
				if (i != 0)
					reult.add(-i);
			}
			if (i == 30 || i == 31 || i == 34) {
				reult.add(i);
				reult.add(-i);
			}
		}
		return reult;
	}

	/*
	 * ==========================================================================
	 * =============== getStatus Selected by Admin for searching
	 * ================
	 * =========================================================================
	 */
	public String getStatusSelected(Integer StatusIndex) {
		String result = "";
		switch (StatusIndex) {
		case 0:
			result = "open";
			break;
		case 1:
			result = "progress";
			break;
		case 2:
			result = "shipped";
			break;
		case 3:
			result = "invoiced";
			break;
		case 4:
			result = "canceled";
			break;
		default:
			result = "";
		}
		return result;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 13:16:30.707
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:30.707
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:30.708
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 13:16:30.708
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-31 13:16:30.709
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.ui 4 0 2015-04-01 09:39:05.733
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:927)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:162)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:67)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:80)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:276)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:452)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:205)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4066)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3657)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2640)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2604)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2438)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:671)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:664)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:115)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:369)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:620)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:575)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1408)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:12.456
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.common;

import java.util.ArrayList;
import java.util.List;

import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.web.WebConstants;
import com.loyauty.web.struts.action.LoyautyAction;

public class ShowCommonDataTable extends LoyautyAction {
	
	@Getter @Setter
	private String sectionTitle;
	@Getter @Setter
	private int pageType;
	@Getter @Setter
	private List<String> thLabels;
	
	public ShowCommonDataTable() throws ServiceLocatorException {
		super();		
	}
	
	@Override  
	public String execute() throws Exception {
				
		setSectionTitle(sectionTitle);
		setPageType(pageType);
		thLabels = new ArrayList<String>();		
		switch(pageType) {		
			case WebConstants.USER_LIST :
					 setSectionTitle(getText("loyauty.common.text.short.acount_list"));
					 thLabels.add(getText("loyauty.common.text.short.user_account"));
					 thLabels.add(getText("loyauty.common.text.short.email"));
					 thLabels.add(getText("loyauty.common.text.short.user_code"));
					 thLabels.add(getText("loyauty.common.text.short.active"));	
					 thLabels.add(getText("loyauty.common.text.short.client_category"));
					 thLabels.add(getText("loyauty.common.text.short.action"));
					 break;
			case WebConstants.BRAND_LIST : 
					 setSectionTitle(getText("loyauty.common.text.short.brand_list"));
					 thLabels.add(getText("loyauty.common.text.short.id"));
					 thLabels.add(getText("loyauty.common.text.short.name"));
					 thLabels.add(getText("loyauty.common.text.short.creation_date"));
					 thLabels.add(getText("loyauty.common.text.short.Satisfaction"));
					 thLabels.add(getText("loyauty.common.text.short.action"));
					 break;
			case WebConstants.CATEGORY_LIST : 
					 setSectionTitle(getText("loyauty.common.text.short.category_list")); 
					 thLabels.add(getText("loyauty.common.text.short.id"));
					 thLabels.add(getText("loyauty.common.text.short.category_code"));
					 thLabels.add(getText("loyauty.common.text.short.name"));
					 thLabels.add(getText("loyauty.common.text.short.category_group"));
					 thLabels.add(getText("loyauty.common.text.short.action"));
					 break;
			case WebConstants.PRODUCT_LIST : 
					 setSectionTitle(getText("loyauty.common.text.short.product_list"));
					 thLabels.add(getText("loyauty.common.text.short.product"));
					 thLabels.add(getText("loyauty.common.text.short.brand"));
					 thLabels.add(getText("loyauty.common.text.short.category"));
					 thLabels.add(getText("loyauty.common.text.short.action"));
					 break;
			case WebConstants.MAIN_SPECIFICATION_LIST : 
					setSectionTitle(getText("loyauty.common.text.short.main_specification_list"));
					thLabels.add(getText("loyauty.common.text.short.id"));
			 		thLabels.add(getText("loyauty.common.text.short.category"));
			 		thLabels.add(getText("loyauty.common.text.short.specification"));
			 		thLabels.add(getText("loyauty.common.text.short.status"));
			 		thLabels.add(getText("loyauty.common.text.short.action"));
			 		break;
			case WebConstants.BRAND_LIST_VIEW : 
				 	setSectionTitle(getText("loyauty.common.text.short.brand_list"));
				 	thLabels.add(getText("loyauty.common.text.short.id"));
				 	thLabels.add(getText("loyauty.common.text.short.name"));
				 	thLabels.add(getText("loyauty.common.text.short.creation_date"));
				 	thLabels.add(getText("loyauty.common.text.short.action"));
				 	break;
			case WebConstants.CATEGORY_LIST_VIEW : 
				 setSectionTitle(getText("loyauty.common.text.short.brand_list"));
				 setSectionTitle(getText("loyauty.common.text.short.category_list")); 
				 thLabels.add(getText("loyauty.common.text.short.id"));
				 thLabels.add(getText("loyauty.common.text.short.category_code"));
				 thLabels.add(getText("loyauty.common.text.short.name"));
				 thLabels.add(getText("loyauty.common.text.short.category_group"));
				 thLabels.add(getText("loyauty.common.text.short.action"));
				 break;
			case WebConstants.SPECIFICATION_LIST_VIEW :
				setSectionTitle(getText("loyauty.common.text.short.main_specification_list"));
				thLabels.add(getText("loyauty.common.text.short.id"));
		 		thLabels.add(getText("loyauty.common.text.short.category"));
		 		thLabels.add(getText("loyauty.common.text.short.specification"));
		 		thLabels.add(getText("loyauty.common.text.short.status"));
		 		thLabels.add(getText("loyauty.common.text.short.action"));
		 		break;
			case WebConstants.USER_LIST_VIEW :
				 setSectionTitle(getText("loyauty.common.text.short.acount_list"));
				 thLabels.add(getText("loyauty.common.text.short.user_account"));
				 thLabels.add(getText("loyauty.common.text.short.email"));
				 thLabels.add(getText("loyauty.common.text.short.user_code"));
				 thLabels.add(getText("loyauty.common.text.short.active"));					 
				 thLabels.add(getText("loyauty.common.text.short.action"));
				 break;
			default : break;
		}
			
		return getSuccessResult();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:12.459
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.460
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.460
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:12.461
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.461
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:12.529
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.CityDTO;
import com.loyauty.service.core.dto.CurrencyDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;


public class CreateOrdersManual extends LoyautyAction {
	private static final long serialVersionUID = -1238269595572206024L;

	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	@Getter @Setter
	private String userLogin;
	@Getter @Setter
	private Long userId;
	@Getter @Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter @Setter
	private File orderFile;
	@Getter @Setter
	List<OrdersDTO>listOrdersDTO;
	Hashtable<String, OrdersDTO>hashOrders;
	@Getter @Setter
	private String orderSelected;
	@Getter @Setter
	private Long saveOrdersSignal;
	@Getter @Setter
	private Long confirmSaveOrdersSignal;
	@Getter @Setter
	private String lsOrderId;
	@Getter @Setter
	private String message;
	@Getter @Setter
	Integer indexOrder;
	@Getter @Setter
	Integer indexRow;
	@Getter @Setter
	private Long checkBoxPrintSignal;
	@Getter @Setter
	private Boolean checkBoxPrintEtem;
	@Getter @Setter
	private Boolean checkBoxPrint;
	@Getter @Setter
	private Long pageTop=0L;
	@Getter @Setter
	private Long saved;
	@Getter @Setter
	private String showNotificationPop="visibility:hidden;display:none;";
	@Getter @Setter
	private Long addOrderSignal;
	@Getter @Setter
	private Long addSimilarOrderSignal;
	@Getter @Setter
	private Long deleteOrderSignal;
	@Getter @Setter
	private Long deleteRowSignal;
	@Getter @Setter
	private Long userLoginChangedSignal;
	@Getter @Setter
	private Long saveTemporarySignal;
	@Getter @Setter
	private Long addSimilarRowSignal;
	@Getter @Setter
	private Long saveTemporaryRowSignal;
	@Getter @Setter
	private Long checkProductPriceSignal;
	@Getter @Setter
	private Long userIdFindedSignal;
	@Getter @Setter
	private String userLogo;
	//recovery Data Order
	@Getter @Setter
	private String clientLastName;
	@Getter @Setter
	private String clientFirstName;
	@Getter @Setter
	private String clientOtherNames;
	@Getter @Setter
	private String clientStreet;
	@Getter @Setter
	private String  clientOtherStreet;
	@Getter @Setter
	private String  clientCity;
	@Getter @Setter
	private String  clientProvince;
	@Getter @Setter
	private String  clientPostalCode;
	@Getter @Setter
	private String  clientPhone;
	@Getter @Setter
	private String  clientEmail;
	@Getter @Setter
	private String productOrderNumber;
	@Getter @Setter
	private String strProductOrderDate;
	@Getter @Setter
	private String strRequiredDate;
	
	//recovery data row
	@Getter @Setter
	private Double quantity ;
	@Getter @Setter
	private String lsProductID;
	@Getter @Setter
	private Double stock;
	@Getter @Setter
	private String productDescription;
	@Getter @Setter
	private Double unitPrice;
	@Getter @Setter
	private Double shippingFee;
	@Getter @Setter
	private String shippingCompany;
	@Getter @Setter
	private String trackingNumber;
	@Getter @Setter
	private String strCreationOrderDate;
	@Getter @Setter
	private Date creationOrderDate; 
	@Getter @Setter
	private String showSaveSuccessPop="visibility:hidden;display:none;";
	//showSaveSuccessPop="display:block;visibility:visible;";
	//showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter @Setter
	private Long okSaveSuccessPopSignal;
	@Getter @Setter
	private Long requirdFieldError;
	@Getter @Setter
	private Long newLsOrderIdSignal;
	@Getter @Setter
	private List<ProvinceDTO>listProvinces;
	@Getter @Setter 
	private String  code;
	//@Getter @Setter
	//private List<CityDTO>listCities;
	private Hashtable<String, ProvinceDTO>hashProvinces;
	//private Hashtable<String, CityDTO>hashCities;
	//@Getter @Setter
	//private Long provinceChangedSignal;
	private Date today ;
	
	@Getter @Setter
	private Long currencyAlertPopSignal;
	
	@Getter @Setter
	private String currencySymbol;
	
	public  CreateOrdersManual() throws ServiceLocatorException {
		super();	
		productService = getServiceLocator().getProductService();   
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		hashOrders=new Hashtable<String, OrdersDTO>();
		//listProvinces=new ArrayList<ProvinceDTO>();
		today=new Date();
	}

	/*=========================================================================================
	 											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked", "unused" })
	@Override
	public String execute() throws Exception {
		HttpSession session = request.getSession(true);
		OrdersDTO orderDTOToAdd;
		userLogo=(String)session.getAttribute("userLogo");
		requirdFieldError=(Long)session.getAttribute("requirdFieldError");
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		SimpleDateFormat frmForLsOrderId = new SimpleDateFormat("yyyyMMdd");
		OrdersDTO orderDTOToUpdate;
		String initalClient="";
		try {
			//recovery provinces
			listProvinces=(List<ProvinceDTO>)session.getAttribute("listProvinces");
			if(listProvinces==null){
				listProvinces=productService.getAllProvinces();
				session.setAttribute("listProvinces",listProvinces);
			}
			if (((strCreationOrderDate)!=null)&&(!"".equals(strCreationOrderDate))){
				try {
					creationOrderDate = frm.parse(strCreationOrderDate);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession=(List<User>)session.getAttribute("usersListSession");
			if(usersListSession==null){
				List<UserSessionDTO> listAllUsers= userService.getAllUsers(basicUserDTO);
				usersList=new ArrayList<User>();
				for(UserSessionDTO userDTO:listAllUsers){
					User user=new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession",usersList);
			}else usersList=usersListSession;


			/*-------------------- recovery orders list ------------------------------------
						displaying at least one item in the orders list if it is empty
			  -----------------------------------------------------------------------------*/
			
			if(userIdFindedSignal==null || userIdFindedSignal==0L){
				userId=(Long)session.getAttribute("userId");
				if(userId!=null){
					UserDTO userFind=userService.getUserInformation(userId);
					userLogin=userFind.getLogin();
				}
			}
			
			listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
			if(listOrdersDTO==null)listOrdersDTO =new ArrayList<OrdersDTO>();
			if(listOrdersDTO.size()==0){
				//String lsOrderIdFirstPart="Man"+frm.format(today);
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				OrdersDTO orderDTO=new OrdersDTO();
				orderDTO.setLsOrderId(manLsOrderId);
				orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
				OrdersRows orderRow=new OrdersRows();
				orderRow.setIcon("images/orders/itemNotValidated.png");
				orderDTO.getRowsList().add(orderRow);
				listOrdersDTO.add(orderDTO);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
			}else{
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				OrdersDTO ordDTO=listOrdersDTO.get(0);
				ordDTO.setLsOrderId(manLsOrderId);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			//if(provinceChangedSignal!=null && provinceChangedSignal!=0L){
				hashProvinces=(Hashtable<String, ProvinceDTO>)session.getAttribute("hashProvinces");
				if(code!=null && !code.equals("")){
					ProvinceDTO provinceDTO=hashProvinces.get(code);
					if(provinceDTO!=null){
						clientProvince=provinceDTO.getCode();
						//listCities=provinceDTO.getListCities();
					}
				}//else listCities=new ArrayList<CityDTO>();
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				orderDTOToUpdate.setClientCity(clientCity);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				//return SUCCESS;
			//}

			/*-------------------- When Admin Find User Login ---------------------------
						change all value of userid list of orders
			 -----------------------------------------------------------------------------*/
			if(userIdFindedSignal!=null && userIdFindedSignal!=0L){
				User user=userService.getUserByLogin(userLogin);
				OrdersDTO orderDTO=listOrdersDTO.get(0);
				orderDTO=fillDataOrderDTO(orderDTO);
				userLogo=null;
				userId=null;
				if(user!=null){
					orderDTO.setUserId(user.getId());
					userId=user.getId();
					currencySymbol = "CAD";
					CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
					if(currencyDTO!=null && currencyDTO.getId()!=1) {
						currencyAlertPopSignal = 1L;
						if(currencyDTO.getSymbol()!=null) currencySymbol = currencyDTO.getSymbol();
					} else currencyAlertPopSignal=0L;
					for(OrdersDTO ord:listOrdersDTO){
						ord.setUserId(user.getId());
						ord.setUserLogin(userLogin);
					}
	    			//show user logo
	    			userLogo="./images/orders/usersLogos/"+userLogin+".png";
				}else userLogin=null;

				String filePath = session.getServletContext().getRealPath("/");
				//String LogoDestination = filePath + "images/orders/usersLogos/"+userLogin+".png";
				//File f=new File(LogoDestination);
				//if(!f.exists())userId=null;

    			//if userLogo dosn't exist give him a blank logo
    			createUserLogo(filePath +"images/orders/usersLogos/BLANK.png", filePath +"images/orders/usersLogos/"+userLogin+".png");
    			
    			session.setAttribute("userLogo",userLogo);
				session.setAttribute("userId",userId);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			if(userId==null)userLogin="";

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			/*if(provinceChangedSignal!=null && provinceChangedSignal!=0L){
				hashProvinces=(Hashtable<String, ProvinceDTO>)session.getAttribute("hashProvinces");
				if(code!=null){
					listCities=hashProvinces.get(code).getListCities();
				}else listCities=new ArrayList<CityDTO>();
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				//orderDTOToUpdate.setClientCity(clientCity)
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				//return SUCCESS;
			//}*/
			
			/*----------------- When Admin check on Add Similar order Icon or save Temporary -------
									Create a copy of order selected
			 ---------------------------------------------------------------------------------------*/
			if(((addSimilarOrderSignal!=null && addSimilarOrderSignal!=0L)||(saveTemporarySignal!=null && saveTemporarySignal!=0L)) && indexOrder>=0){
				orderDTOToAdd=listOrdersDTO.get(indexOrder);
				if(orderDTOToAdd==null)orderDTOToAdd=new OrdersDTO();
				if((saveTemporarySignal!=null && saveTemporarySignal!=0L))orderDTOToAdd.setLsOrderId(lsOrderId);
				orderDTOToAdd.setCreationDate(creationOrderDate); 
				orderDTOToAdd.setClientLastName(clientLastName);
				orderDTOToAdd.setClientFirstName(clientFirstName);
				orderDTOToAdd.setClientOtherNames(clientOtherNames); 
				orderDTOToAdd.setClientStreet(clientStreet);
				orderDTOToAdd.setClientOtherStreet(clientOtherStreet);
				orderDTOToAdd.setClientCity(clientCity);
				orderDTOToAdd.setClientProvince(clientProvince);
				orderDTOToAdd.setClientProvince(clientProvince);
				orderDTOToAdd.setClientPostalCode(clientPostalCode);
				orderDTOToAdd.setClientPhone(clientPhone);
				orderDTOToAdd.setClientEmail(clientEmail);			
				orderDTOToAdd.setProductOrderNumber(productOrderNumber);
				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToAdd.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToAdd.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				User user=userService.getUserByLogin(userLogin);
				if(user!=null){
					UserDTO userDTO=userService.getUserInformation(user.getId());
					orderDTOToAdd.setUserLogin(userLogin);
					orderDTOToAdd.setUserId(userDTO.getId());
				}
				if(addSimilarOrderSignal!=null && addSimilarOrderSignal!=0L){ 
					OrdersDTO orderDTOClone = DTOFactory.getOrderDTOClone(orderDTOToAdd);
					orderDTOClone.setCssStyle("background-color:white;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					listOrdersDTO.add(orderDTOClone);
				}
				int indexOrder=0;
				for(OrdersDTO orderDTO:listOrdersDTO){
					orderDTO.setIndex(indexOrder);
					indexOrder++;
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			
			/*----------------- When Admin click on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if(saveTemporaryRowSignal!=null && saveTemporaryRowSignal!=0L){
				
				orderDTOToUpdate=listOrdersDTO.get(0);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				/*
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);
				orderDTOToUpdate.setCreationDate(creationOrderDate);
				orderDTOToUpdate.setClientLastName(clientLastName);
				orderDTOToUpdate.setClientFirstName(clientFirstName);
				orderDTOToUpdate.setClientOtherNames(clientOtherNames); 
				orderDTOToUpdate.setClientStreet(clientStreet);
				orderDTOToUpdate.setClientOtherStreet(clientOtherStreet);
				orderDTOToUpdate.setClientCity(clientCity);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientPostalCode(clientPostalCode);
				orderDTOToUpdate.setClientPhone(clientPhone);
				orderDTOToUpdate.setClientEmail(clientEmail);			
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);

				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToUpdate.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToUpdate.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				*/
				OrdersRows orderRowToSaveMemory=orderDTOToUpdate.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if(orderRowToSaveMemory!=null){
					orderRowToSaveMemory.setQuantity(quantity); 
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory.setCssPrice("background-color:red;");
					if(unitPrice!=null && orderRowToSaveMemory.getLsPrice()!=null
					  && unitPrice>=orderRowToSaveMemory.getLsPrice())
					  orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trackingNumber);	
					int indexOrder=0;
					int indexRow=0;
					for(OrdersDTO orderDTO:listOrdersDTO){
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow=0;
						for(OrdersRows orderRows:orderDTO.getRowsList()){
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				}

				return SUCCESS;
			}
			
			/*-------------------- When Admin click on addSimilarRow Icon -----------------
										Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if(addSimilarRowSignal!=null && addSimilarRowSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone=orderDTOToUpdate.getRowsList().get(indexRow);
				if(orderRowToClone!=null){
					if(!orderRowToClone.getIcon().equals("images/orders/itemValidated.png")){
						orderRowToClone.setQuantity(quantity); 
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingPrice(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trackingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd=DTOFactory.getOrderRowClone(orderRowToClone);
					orderDTOToUpdate.getRowsList().add(indexRow+1,orderRowToAdd);
					int indexOrder=0;
					int indexRow=0;
					for(OrdersDTO orderDTO:listOrdersDTO){
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow=0;
						for(OrdersRows orderRows:orderDTO.getRowsList()){
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				}
				return SUCCESS;
			}

			/*-------------------- When Admin click on Delete order Icon -------------
									Delete this order using index
			 -----------------------------------------------------------------------------*/
			
			if(deleteOrderSignal!=null && deleteOrderSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				List<OrdersDTO> listOrdersDTOAfterDelete=new ArrayList<OrdersDTO>();
				for(int i=0 ;i<listOrdersDTO.size();i++){
					if(i!=indexOrder || indexOrder==0)listOrdersDTOAfterDelete.add(listOrdersDTO.get(i));
				}
				int index=0;
				for(int i=0 ;i<listOrdersDTOAfterDelete.size();i++){
					listOrdersDTOAfterDelete.get(i).setIndex(index);
					index++;
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTOAfterDelete);
				listOrdersDTO=listOrdersDTOAfterDelete;
				return SUCCESS;
			}

			/*-------------------- When Admin check on Delete Row Icon -------------------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if(deleteRowSignal!=null && deleteRowSignal!=0L){
				ArrayList<OrdersRows>listRowsAfterDelete=new ArrayList<OrdersRows>();
				OrdersDTO orderDTO=listOrdersDTO.get(indexOrder);
				orderDTO=fillDataOrderDTO(orderDTO);
				if(orderDTO!=null && orderDTO.getRowsList().size()>1){
					for(int i=0 ;i<orderDTO.getRowsList().size();i++){
						if(i!=indexRow)listRowsAfterDelete.add(orderDTO.getRowsList().get(i));
					}
					int index=0;
					for(int i=0 ;i<listRowsAfterDelete.size();i++){
						listRowsAfterDelete.get(i).setIndex(index);
						index++;
					}
					orderDTO.setRowsList(listRowsAfterDelete);
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}
			

			/*-------------------- When Admin check left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if(checkProductPriceSignal!=null && checkProductPriceSignal!=0L){
				orderDTOToUpdate=listOrdersDTO.get(indexOrder);
				orderDTOToUpdate=fillDataOrderDTO(orderDTOToUpdate);
				/*
				orderDTOToUpdate.setClientLastName(clientLastName);
				orderDTOToUpdate.setClientFirstName(clientFirstName);
				orderDTOToUpdate.setClientOtherNames(clientOtherNames); 
				orderDTOToUpdate.setClientStreet(clientStreet);
				orderDTOToUpdate.setClientOtherStreet(clientOtherStreet);
				orderDTOToUpdate.setClientCity(clientCity);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientProvince(clientProvince);
				orderDTOToUpdate.setClientPostalCode(clientPostalCode);
				orderDTOToUpdate.setClientPhone(clientPhone);
				orderDTOToUpdate.setClientEmail(clientEmail);			
				orderDTOToUpdate.setProductOrderNumber(productOrderNumber);
				if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strProductOrderDate);
	    				orderDTOToUpdate.setProductOrderDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
	    			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
	    			try {
	    				Date date = sdf.parse(strRequiredDate);
	    				orderDTOToUpdate.setRequiredDate(date);
	    			}
	    			catch (Exception pe) {
	    				addActionError("Please enter a date in the correct format");
	    			}
	    		}
				*/
				OrdersRows orderRowToUpadate=orderDTOToUpdate.getRowsList().get(indexRow);
				UserProductPriceDTO userProductPrice=productService.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if(userProductPrice==null){
					lsProductID=null;
					orderRowToUpadate.setCss("background-color:red;");
					addActionError(getText("loyauty.error.common.requiredLsProductOrder"));
					orderRowToUpadate.setProductDescription(""); 
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				}else{
					Double usrPrice=orderRowToUpadate.getUnitPrice();
					if(usrPrice==null)usrPrice=0D;
					if(usrPrice < userProductPrice.getPriceNum()){
						orderRowToUpadate.setCssPrice("background-color:red;");	
					}
					orderRowToUpadate.setProductDescription(userProductPrice.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice.getLsProductId());
					orderRowToUpadate.setLsPrice(userProductPrice.getPriceNum());
					if(userProductPrice.getUserId()!=null) {
						//currency
						Long userId = userProductPrice.getUserId();
						Long currencyId = 1L;
						Double currencyRate = 1D;
						Double currencyPrice = 0D;
						CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
						if(currencyDTO!=null && currencyDTO.getRate()!=null) {
							currencyId = currencyDTO.getId();
							if(currencyId!=1) {
								currencyRate = currencyDTO.getRate();
								currencyPrice = (double) Math.round((orderRowToUpadate.getLsPrice()*currencyRate)*100) / 100;
								orderRowToUpadate.setLsPrice(currencyPrice);
							}
						}
					}
				}
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				listOrdersDTO=(List<OrdersDTO>)session.getAttribute("listOrdersDTOMan");
				return SUCCESS;
			}
			
			/*-------------------------------- SAVE ORDERS -------------------------------
						save in data bases just orders witch has print checked 
	 		 -----------------------------------------------------------------------------*/
			if(saveOrdersSignal!=null && saveOrdersSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				User user=userService.getUserByLogin(userLogin);
				OrdersDTO order=listOrdersDTO.get(0);
				order.setManOrder(true);
				order=fillDataOrderDTO(order);
				if(user!=null)order.setUserId(user.getId());
				boolean productNotFond=false;
				for(OrdersRows row:order.getRowsList()){
					if(row.getLsProductID()==null || row.getLsProductID().equals("")){
						productNotFond=true;
						break;
					}
				}
				requirdFieldError=null;
				session.setAttribute("requirdFieldError",null);
				productOrderNumber=order.getProductOrderNumber().replaceAll("^ +| +$|( )+", "$1");
				clientFirstName=order.getClientFirstName().replaceAll("^ +| +$|( )+", "$1");
				clientLastName=order.getClientLastName().replaceAll("^ +| +$|( )+", "$1");
				clientStreet=order.getClientStreet().replaceAll("^ +| +$|( )+", "$1");
				clientCity=order.getClientCity().replaceAll("^ +| +$|( )+", "$1");
				clientProvince=order.getClientProvince().replaceAll("^ +| +$|( )+", "$1");
				clientPostalCode=order.getClientPostalCode().replaceAll("^ +| +$|( )+", "$1");
				
				order.setProductOrderNumber(productOrderNumber);
				order.setClientFirstName(clientFirstName);
				order.setClientLastName(clientLastName);
				order.setClientStreet(clientStreet);
				order.setClientCity(clientCity);
				order.setClientProvince(clientProvince);
				order.setClientPostalCode(clientPostalCode);
				
				if(order.getProductOrderNumber()==null || order.getProductOrderNumber().equals("")||
						   order.getLsOrderId()==null || order.getLsOrderId().equals("") ||
						   order.getCreationDate()==null || productNotFond ||
						   order.getClientFirstName()==null || order.getClientFirstName().equals("")||
						   order.getClientLastName()==null || order.getClientLastName().equals("") ||
						   order.getClientStreet()==null || order.getClientStreet().equals("") ||
						   order.getClientCity()==null || order.getClientCity().equals("") || 
						   order.getClientProvince()==null || order.getClientProvince().equals("") ||
						   order.getClientPostalCode()==null || order.getClientPostalCode().equals("")){
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					addActionError(getText("loyauty.error.common.requiredFieldOrders"));
					requirdFieldError=1L;
					session.setAttribute("requirdFieldError",1L);
					return SUCCESS;
				}
				
				for(OrdersRows row:order.getRowsList()){
					if(row.getLsProductID()==null || row.getLsProductID().equals("")||
					   row.getQuantity()==null || row.getQuantity()==0D){
						requirdFieldError=1L;
					   session.setAttribute("requirdFieldError",1L);
					   addActionError(getText("loyauty.error.common.requiredFieldOrders"));
					   return SUCCESS;
					}
				}
				//add special handling shipping	+ currency
				for(OrdersDTO orDTO:listOrdersDTO){
					if(user!=null){
						//currency
						Long userId = user.getId();
						Long currencyId = 1L;
						String currencySymbol = "CAD";
						Double currencyRate = 1D;
						Double currencyUnitPrice = 0D;
						Double currencyTotalPrice = null;
						//Double currencyShippingPrice = null;
						Double unitPrice = null;
						CurrencyDTO currencyDTO = orderService.getCurrencyIdByUserId(userId);
						if(currencyDTO!=null) {
							currencyId = currencyDTO.getId();
							if(currencyDTO.getSymbol()!=null) currencySymbol = currencyDTO.getSymbol();
							if(currencyDTO.getRate()!=null) currencyRate = currencyDTO.getRate();
						}
						
						Double totalPrice=null;
						orDTO.setSpecialHandlingName(user.getSpecialHandlingName());
						orDTO.setSpecialHandlingFee(user.getSpecialHandlingFee());
						if(orDTO.getRowsList().get(0).getQuantity()!=null && orDTO.getRowsList().get(0).getUnitPrice()!=null){
							unitPrice = orDTO.getRowsList().get(0).getUnitPrice();
							totalPrice= orDTO.getRowsList().get(0).getQuantity()*unitPrice;
							totalPrice = (double) Math.round(totalPrice * 100) / 100;
							if(currencyId!=1) {
								currencyUnitPrice = unitPrice;
								unitPrice = (double) Math.round((unitPrice/currencyRate)*100) / 100;
								orDTO.setUnitPrice(unitPrice);
								orDTO.getRowsList().get(0).setUnitPrice(unitPrice);
								currencyTotalPrice = totalPrice;
								totalPrice = (double) Math.round((totalPrice/currencyRate)*100) / 100;
								/*
								if(orDTO.getRowsList().get(0).getShippingPrice()!=null) {
									currencyShippingPrice = orDTO.getRowsList().get(0).getShippingPrice();
									Double shippingPrice = (double) Math.round((currencyShippingPrice/currencyRate)*100) / 100;
									orDTO.setShippingPrice(shippingPrice);
									orDTO.setShippingFee(shippingPrice);
									orDTO.setCurrencyShippingPrice(currencyShippingPrice);
									orDTO.getRowsList().get(0).setShippingPrice(shippingPrice);
									orDTO.getRowsList().get(0).setShippingFee(shippingPrice);
									orDTO.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
								}
								*/
							}
						}
						orDTO.setTotalPrice(totalPrice);
						orDTO.setCurrencyId(currencyId);
						orDTO.setCurrencySymbol(currencySymbol);
						orDTO.setCurrencyRate(currencyRate);
						orDTO.setCurrencyUnitPrice(currencyUnitPrice);
						orDTO.setCurrencyTotalPrice(currencyTotalPrice);
						
						for(OrdersRows row: orDTO.getRowsList()){
							row.setCurrencyId(currencyId);
							row.setCurrencySymbol(currencySymbol);
							row.setCurrencyRate(currencyRate);
							row.setCurrencyUnitPrice(currencyUnitPrice);
						}
					}	
				}
				listOrdersDTO=orderService.insertListOrders(listOrdersDTO);
				listOrdersDTO=new ArrayList<OrdersDTO>();
				if(listOrdersDTO.size()==0){
					frm = new SimpleDateFormat("yyyyMMdd");
					if(userLogin!=null && userLogin.length()>=2){
						initalClient=userLogin.substring(0, 2);
						initalClient=initalClient.toUpperCase();
					}
					//String lsOrderIdFirstPart="Man"+frm.format(today);
					String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
					String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
					OrdersDTO orderDTO=new OrdersDTO();
					//recovery userId
					if(user!=null)orderDTO.setUserId(user.getId());
					orderDTO.setLsOrderId(manLsOrderId);
					orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					OrdersRows orderRow=new OrdersRows();
					orderRow.setIcon("images/orders/itemNotValidated.png");
					orderDTO.getRowsList().add(orderRow);
					listOrdersDTO.add(orderDTO);
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				}
				message="Saving has completed successfuly";
				showSaveSuccessPop="display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
	 		 -----------------------------------------------------------------------------*/
			if(checkBoxPrintSignal!=null && checkBoxPrintSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				OrdersDTO orderDTOInList=listOrdersDTO.get(indexOrder);
				orderDTOInList=fillDataOrderDTO(orderDTOInList);
				orderDTOInList.setPrint(checkBoxPrint);
				session.setAttribute("listOrdersDTOMan",listOrdersDTO);
				return SUCCESS;
			}


			/*-------------- When user click on the button OK of showSaveSuccessPop -------
						just hide dialogue popup: showSaveSuccessPop
	 		 ------------------------------------------------------------------------------*/
			if(okSaveSuccessPopSignal!=null && okSaveSuccessPopSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				showSaveSuccessPop="visibility:hidden;display:none;";
				return SUCCESS;
			}



			/*-------------- When user click on the image imgNewLsOrderId -----------------
								generate other LsOrderId
	 		 ------------------------------------------------------------------------------*/
			if(newLsOrderIdSignal!=null && newLsOrderIdSignal!=0L){
				listOrdersDTO=	(ArrayList<OrdersDTO>) session.getAttribute("listOrdersDTOMan");
				OrdersDTO orderDTO=listOrdersDTO.get(0);
				frm = new SimpleDateFormat("yyyyMMdd");
				if(userLogin!=null && userLogin.length()>=2){
					initalClient=userLogin.substring(0, 2);
					initalClient=initalClient.toUpperCase();
				}
				//String lsOrderIdFirstPart="Man"+frm.format(today);
				String lsOrderIdFirstPart=initalClient+"M"+frmForLsOrderId.format(today);
				String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
				orderDTO.setLsOrderId(manLsOrderId);
				return SUCCESS;
			}

		} catch (Exception e) {
			addActionError(getText("loyauty.error.common.userNotSelected"));
			e.printStackTrace();
			return "input";
		}
	return SUCCESS;
	}
	

	   /*=========================================================================================
								fill all fields of order without rows
		 =========================================================================================*/
		public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO){
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			//orderToEdit=listOrdersDTO.get(indexOrder);
			orderDTO.setClientLastName(clientLastName);
			orderDTO.setClientFirstName(clientFirstName);
			orderDTO.setClientOtherNames(clientOtherNames); 
			orderDTO.setClientStreet(clientStreet);
			orderDTO.setClientOtherStreet(clientOtherStreet);
			orderDTO.setClientCity(clientCity);
			orderDTO.setClientProvince(clientProvince);
			orderDTO.setClientProvince(clientProvince);
			orderDTO.setClientPostalCode(clientPostalCode);
			orderDTO.setClientPhone(clientPhone);
			orderDTO.setClientEmail(clientEmail);			
			orderDTO.setProductOrderNumber(productOrderNumber);
			
			
			if (((strProductOrderDate)!=null)&&(!"".equals(strProductOrderDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strProductOrderDate);
					orderDTO.setProductOrderDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			
			if (((strCreationOrderDate)!=null)&&(!"".equals(strCreationOrderDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationOrderDate);
					orderDTO.setCreationDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			
			if (((strRequiredDate)!=null)&&(!"".equals(strRequiredDate))){
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strRequiredDate);
					orderDTO.setRequiredDate(date);
				}
				catch (Exception pe) {
					addActionError("Please enter a date in the correct format");
				}
			}
			return orderDTO;
		}


		/*=========================  createUserLogo ===========================
		 				Create  Blank User Logo if not Exist
		  =================================================================*/
		public void createUserLogo(String source, String destination) throws IOException{
			File fileLogo=new File(destination);
			if(!fileLogo.exists()){
				InputStream in = new FileInputStream(source);
				OutputStream out = new FileOutputStream(destination);
				byte[] buf = new byte[1024];
				int len;
				while ((len = in.read(buf)) > 0) {
					out.write(buf, 0, len);
				}
				in.close();
				out.close();	
			}
		}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:12.530
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.530
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.530
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:12.531
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.531
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:12.535
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.ajax;

import java.io.File;
import java.io.FileInputStream;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import lombok.Getter;
import lombok.Setter;

import org.apache.commons.lang.time.DateFormatUtils;
import com.loyauty.enums.UserProductStatus;

import com.loyauty.exception.ServiceException;
import com.loyauty.exception.ServiceLocatorException;

import com.loyauty.service.brand.BrandService;
import com.loyauty.service.category.CategoryService;
import com.loyauty.service.common.CommonService;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.BrandDTO;
import com.loyauty.service.core.dto.CategoryDTO;
import com.loyauty.service.core.dto.CommonDTO;
import com.loyauty.service.core.dto.ProductDTO;
import com.loyauty.service.core.dto.QueryDTO;
import com.loyauty.service.core.dto.SpecificationDTO;
import com.loyauty.service.core.dto.UserProductDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.specification.SpecificationService;
import com.loyauty.service.user.UserService;
import com.loyauty.util.CommonUtils;
import com.loyauty.web.exception.LoyautyAjaxActionException;
import com.loyauty.web.struts.action.LoyautyListActionSupport;




public class AdminPageAjax<T> extends LoyautyListActionSupport {
	
	private static final long serialVersionUID = 1L;
	
	private static final String LOYALTY_DATE_FORMAT_DD_MMMM_YYYY_KEY = "loyauty.date.format.dd-MM-YYYY";
	
	private UserService userService;
	private CommonService commonService;
	private BrandService brandService;
	private CategoryService categoryService;
	private ProductService productService;
	private SpecificationService specificationService;
	
	private static String AA_DATA = "aaData";
	private static String USER_DISCOUNT = "userDiscount";
	private static final String CODE_BRAND = "codeBrand";
	
	private static int USER_TYPE = 2;	
	
	@Getter @Setter
	private int typePage; 
	@Getter @Setter
	private long brandId;
	@Getter @Setter
	private long categoryId;
	@Getter @Setter
	private boolean discontinued;
	@Getter @Setter
	private boolean disabled;
	@Getter @Setter
	private long userId;	

	@Getter @Setter
	private String value;
	@Getter @Setter
	private String oldValue;
	@Getter @Setter
	private long productId;	
	@Getter @Setter
	List<UserSessionDTO> dataLinks;
	
	@Getter
	private int userProductStatus;

	@Getter @Setter
	private Integer userStatus;
	
	public AdminPageAjax() {		
	}
	
	
	@Override  
	public String execute() throws Exception {
		System.out.println("I am at AdminPageAjax");
		
		dataLinks = new ArrayList<UserSessionDTO>();
		BasicUserDTO basicUserDTO = new BasicUserDTO();
		userService = this.getServiceLocator().getUserService();
		basicUserDTO.setTypeId(USER_TYPE);
		try{
			if(userStatus==null)userStatus=-1;
			switch (userStatus) {
			case 1:
				basicUserDTO.setActive(true);			
				dataLinks = userService.getAllUserAccounts(basicUserDTO);
				break;
			case 2:
				basicUserDTO.setActive(false);			
				dataLinks = userService.getAllUserAccounts(basicUserDTO);
				break;	
			default:
				dataLinks = userService.getAllUsers(basicUserDTO);
				break;
			}

			 return SUCCESS;
		}catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
			return ERROR;
		}

	}
		
	@SuppressWarnings("unchecked")
	public String accountsList() throws LoyautyAjaxActionException, ServiceException {		
		dataLinks = new ArrayList<UserSessionDTO>();
		try {			
			userService = this.getServiceLocator().getUserService();
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			dataLinks = userService.getAllUsers(basicUserDTO);
			for(BasicUserDTO bu:dataLinks){
				if(bu.getClientCategoryName()==null)bu.setClientCategoryName("");
			}
		}catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataLinks);
		setResult(map);		
		return SUCCESS;
	}
	
	@SuppressWarnings("unchecked")
	public String populateCategoryAndDiscount() throws LoyautyAjaxActionException, ServiceException {		
		List<CommonDTO> dataLinks = null;
		String discount = null;
		try {			
			commonService = this.getServiceLocator().getCommonService();	
			userService = this.getServiceLocator().getUserService();
			productService =  this.getServiceLocator().getProductService();			
			dataLinks = internationalizeName(commonService.getCategoriesByBrand(brandId));
		} catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataLinks);
		map.put(USER_DISCOUNT, (T) discount);
		setResult(map);		
		return  SUCCESS;		
	}
	
	private List<CommonDTO> internationalizeName(List<CategoryDTO> list){
		
		List<CommonDTO> commonListDTO = new ArrayList<CommonDTO>();
		CommonDTO commonDTO;
		for(CategoryDTO cat : list){
			commonDTO = CommonDTO.valueOf(cat.getId(), getText(cat.getCode()));			
			commonListDTO.add(commonDTO);
		}		
		return commonListDTO;		
	}	
	
	@SuppressWarnings("unchecked")
	public String getProductAndDiscountByCategory() throws LoyautyAjaxActionException, ServiceException {
		List<CommonDTO> dataLinks = null;
		String discount = null;
		try {
			commonService = this.getServiceLocator().getCommonService();	
			userService = this.getServiceLocator().getUserService();
			productService = this.getServiceLocator().getProductService();			
			dataLinks = internationalizeName(commonService.getCategoriesByBrand(brandId));			
		} catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataLinks);
		map.put(USER_DISCOUNT, (T) discount);
		setResult(map);
		
		return  SUCCESS;		
	}	
	
	@SuppressWarnings("unchecked")
	public String brandList() throws LoyautyAjaxActionException, ServiceException {	
				
		List<BrandDTO> dataLinks = new ArrayList<BrandDTO>();
		try {			
			brandService = this.getServiceLocator().getBrandService();
			dataLinks = brandService.getAllBrand();
			for(BrandDTO dto : dataLinks) {
				dto.setLocalizedCreationDate(DateFormatUtils.format(dto.getCreationDate(), getText(LOYALTY_DATE_FORMAT_DD_MMMM_YYYY_KEY)));
			}
		}catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataLinks);
		setResult(map);
		
		return  SUCCESS;
		
	}
	
	@SuppressWarnings("unchecked")
	public String categoryList() throws LoyautyAjaxActionException, ServiceException {	
				
		List<CategoryDTO> dataLinks = new ArrayList<CategoryDTO>();
		try {			
			categoryService = this.getServiceLocator().getCategoryService();
			dataLinks = categoryService.getAllCategory();
		}catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataLinks);
		setResult(map);
		
		return  SUCCESS;		
	}	
	
	@SuppressWarnings("unchecked")
	public String getMainSpecificationByCategory() throws LoyautyAjaxActionException, ServiceException {	
				
		List<SpecificationDTO> dataLinks = new ArrayList<SpecificationDTO>();
		try {			
			productService = this.getServiceLocator().getProductService();
			dataLinks = productService.getMainSpecificationByCategory(categoryId);
		}catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataLinks);
		setResult(map);
		
		return  SUCCESS;
		
	}
	
	
	@SuppressWarnings("unchecked")
	public String populateCategory() throws LoyautyAjaxActionException, ServiceException {	
		
		List<CommonDTO> dataLinks = null;
		String code = new String();
		try {			
			
			commonService = getServiceLocator().getCommonService();	
			brandService = getServiceLocator().getBrandService();
			
			dataLinks = internationalizeName(commonService.getCategoriesByBrand(brandId));
			code = brandService.getBrand(brandId).getCode();
						
		}catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		} catch (Exception e) {}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataLinks);
		map.put(CODE_BRAND, (T)code);
		setResult(map);
		
		return  SUCCESS;		
	}	
	
	@SuppressWarnings("unchecked")
	public String setManuelPrices() throws LoyautyAjaxActionException, ServiceException {	
		
		try {			
			double val = Double.valueOf(value);
			productService = this.getServiceLocator().getProductService();
			UserProductDTO producDTO = new UserProductDTO();
			producDTO.setUserId(userId);
			producDTO.setId(productId);
			producDTO.setUserPrice(value);			
			productService.updateSellingPriceProduct(producDTO);
			setResult(val);		
			
		}catch(NumberFormatException se){
			log.debug("Number Conversion Exception pb", se);				
			setResult(oldValue.isEmpty()?"NaN" : Double.valueOf(oldValue));
		}catch(ServiceLocatorException se){			
			log.debug("Service Locator Exception pb", se);				
			setResult(oldValue.isEmpty()?"NaN" : Double.valueOf(oldValue));
		}catch(ServiceException se){
			log.debug("Service Exception pb", se);
			setResult(oldValue.isEmpty()?"NaN" : Double.valueOf(oldValue));
		}catch(Exception se){
			log.debug("Exception pb", se);
			setResult(oldValue.isEmpty()?"NaN" : Double.valueOf(oldValue));
		}		
		return  SUCCESS;	
	}
	
	@SuppressWarnings("unchecked")
	public String setuserproductstatus() throws LoyautyAjaxActionException, ServiceException {	
		
		try {
			
			Boolean val = Boolean.valueOf(value);			
			productService = this.getServiceLocator().getProductService();	
			UserProductDTO producDTO = new UserProductDTO();
			producDTO.setUserId(userId);
			producDTO.setId(productId);
			if(Boolean.valueOf(value))
				producDTO.setUserProductStatus(UserProductStatus.ACTIVE);
			else
				producDTO.setUserProductStatus(UserProductStatus.INACTIVE);
			productService.updateUserProductStatus(producDTO);
			setResult(val);		
			
		} catch(NumberFormatException se){
			log.debug("Number Conversion Exception pb", se);				
			setResult(oldValue.isEmpty()?"NaN" : Boolean.valueOf(oldValue));
		} catch(ServiceLocatorException se){			
			log.debug("Service Locator Exception pb", se);				
			setResult(oldValue.isEmpty()?"NaN" : Boolean.valueOf(oldValue));
		
		} catch(Exception se){
			log.debug("Exception pb", se);
			setResult(oldValue.isEmpty()?"NaN" : Boolean.valueOf(oldValue));
		}		
		
		return  SUCCESS;
		
	}
	
	@SuppressWarnings("unchecked")
	public String productList() throws LoyautyAjaxActionException, ServiceException {				
		List<ProductDTO> dataList = new ArrayList<ProductDTO>();
		try {			
			productService = this.getServiceLocator().getProductService();
			dataList = productService.getAllProdcut();
		}catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataList);
		setResult(map);
		return  SUCCESS;		
	}
	
	@SuppressWarnings("unchecked")
	public String productListQuery() throws LoyautyAjaxActionException, ServiceException {	
		
		List<ProductDTO> dataList = new ArrayList<ProductDTO>();
		try {
			productService = this.getServiceLocator().getProductService();
			
			// = new ProductDTO();
			BrandDTO brandDTO = BrandDTO.valueOf(brandId);
			CategoryDTO catDTO = CategoryDTO.valueOf(categoryId);
			QueryDTO queryDTO = new QueryDTO.Builder(brandDTO, catDTO, discontinued, disabled).build();
			// ProductDTO dto = new ProductDTO.Builder(new Long(0), brandDTO, catDTO).build();
			dataList = productService.getAllProductQuery(queryDTO);
						
		} catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataList);
		setResult(map);
		
		return  SUCCESS;		
	}
	
	@SuppressWarnings("unchecked")
	public String getMainSpecificationList() throws LoyautyAjaxActionException, ServiceException {	
				
		List<SpecificationDTO> dataList = new ArrayList<SpecificationDTO>();
		try {
			specificationService = this.getServiceLocator().getSpecificationService();
			dataList = specificationService.getAllMainSpecification();
		}catch(ServiceLocatorException sle){
			log.debug("Service Locator Exception pb", sle);			
		}
		//serialize result
		Map<String, T> map = new HashMap<String, T>();
		map.put(AA_DATA, (T) dataList);
		setResult(map);
		
		return  SUCCESS;		
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:12.536
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.536
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.536
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:12.537
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.538
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:12.539
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action;

import java.util.HashMap;

import javax.servlet.http.HttpServletRequest;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;

import org.apache.log4j.Logger;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.interceptor.ServletRequestAware;

import com.loyauty.service.ServiceLocator;
import com.loyauty.service.core.dto.UserDTO;
import com.loyauty.service.core.dto.UsersPrivilegesDTO;
import com.loyauty.util.exception.ExceptionHandler;
import com.loyauty.web.MessageKeyConstants;
import com.loyauty.web.util.LocaleUtils;
import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.Preparable;

/**
 * This is the basic GameJab action where common properties and methods should go.
 *  
 * @author Muthanna
 *
 */

public class LoyautyAction extends ActionSupport implements ServletRequestAware, Preparable {

	private static final String NAMESPACES_SEPARATOR = "/";

	protected Logger log = Logger.getLogger(this.getClass());
	
	protected HttpServletRequest request;
	
	@Getter	@Setter
	private boolean ajax = false;
	@Getter	@Setter
	private String currentLanguage;
	@Getter	@Setter
	private String pageTitleKey;
	@Getter	@Setter
	private String pageKeywordsKey;
	@Getter	@Setter
	private String pageDescriptionKey;
	@Getter	@Setter
	protected UserDTO superAdmin;
	@Getter @Setter
	protected UsersPrivilegesDTO userPrivileges;
	@Getter @Setter
	protected UsersPrivilegesDTO  usersPrivOrdersMapping;
	@Getter @Setter
	protected UsersPrivilegesDTO usersPrivProductClassificat;
	@Getter @Setter
	protected UsersPrivilegesDTO usersPrivCanadaPostVerified;
	@Getter @Setter
	protected UsersPrivilegesDTO usersPrivCurrency;
	
	@Getter(AccessLevel.PROTECTED)
	@Setter(AccessLevel.PRIVATE)
	private ServiceLocator serviceLocator;
	
	public LoyautyAction() {
		setServiceLocator(ServiceLocator.getInstance());
	}
	
	@Override
	public void prepare() throws Exception {
		/*
		 * filling of message keys header information
		 */
		superAdmin=(UserDTO)request.getSession(true).getAttribute("superAdmin");
		userPrivileges=(UsersPrivilegesDTO)request.getSession(true).getAttribute("userPrivileges");
		usersPrivOrdersMapping=(UsersPrivilegesDTO)request.getSession(true).getAttribute("usersPrivOrdersMapping");
		usersPrivProductClassificat=(UsersPrivilegesDTO)request.getSession(true).getAttribute("usersPrivProductClassificat");
		usersPrivCanadaPostVerified=(UsersPrivilegesDTO)request.getSession(true).getAttribute("usersPrivCanadaPostVerified");
		usersPrivCurrency=(UsersPrivilegesDTO)request.getSession(true).getAttribute("usersPrivCurrency");
		String headerKey = null;
		String namesSpace = ServletActionContext.getActionMapping().getNamespace();
		String actionName = ServletActionContext.getActionMapping().getName();
		if (namesSpace != null && !namesSpace.equals(NAMESPACES_SEPARATOR)) {
			headerKey = namesSpace.replace(NAMESPACES_SEPARATOR, ".");
		}
		if (actionName != null) {
			headerKey = (headerKey!=null?headerKey+".":".") + actionName;
		}
		request.getSession(true).setAttribute("fileNamesWithStatus", null);
		setPageTitleKey(MessageKeyConstants.PAGE_HEADER_TITLE_KEY+headerKey);
		setPageKeywordsKey(MessageKeyConstants.PAGE_HEADER_KEYWORDS_KEY+headerKey);
		setPageDescriptionKey(MessageKeyConstants.PAGE_HEADER_DESCRIPTION_KEY+headerKey);
		currentLanguage = LocaleUtils.getSessionLanguage(request);

	}
	
	/**
	 * Use this method when if an Action can be use in a Ajax way.
	 * If the action succeed, it chooses to return "success" in the classic way and "none" in a Ajax way.
	 * method do the choice with an "ajax=true" parameter in the request 
	 * @return "success" in the classic way and "none" in a Ajax way.
	 */
	public String getSuccessResult() {
		if (ajax) {
			return NONE;
		} else {
			return SUCCESS;
		}
	}
	
	/**
	 * Use this method when if an Action can be use in a Ajax way.
	 * If the action failed, it chooses to return "input" in the classic way and "none" in a Ajax way.
	 * method do the choice with an "ajax=true" parameter in the request 
	 * @return "success" in the classic way and "none" in a Ajax way.
	 */
	public String getInputResult() {
		if (ajax) {
			return NONE;
		} else {
			return INPUT;
		}
	}
	
	
	public String getRedirectResult() {
		if (ajax) {
			return NONE;
		} else {
			return "next";
		}
	}
	
	@Override
	public void setServletRequest(HttpServletRequest request) {
		this.request = request;
	}
	
	public void managerException(Exception e, String desc, String var)
	{
		try{
			ExceptionHandler.handleException(e, desc, var);
		}
		catch (Exception ex) {
			log.error(e.getMessage());
		}
	}
	
	public void managerException(Exception e, Class c, String var)
	{
		try{
			ExceptionHandler.handleException(e, c, null, var);
		}
		catch (Exception ex) {
			log.error(e.getMessage());
		}	
	}
	
	public void managerException(Exception e,Class c, String desc, String var)
	{
		try{
			ExceptionHandler.handleException(e, c, desc, var);}
		catch (Exception ex) {
			log.error(e.getMessage());
		}	
	}
	
	public void managerException(Exception e)
	{
		try{
			ExceptionHandler.handleException(e, null, null);
		}
		catch (Exception ex) {
			log.error(e.getMessage());
		}
	}
	
	public void managerException(Exception e , String var)
	{
		try{
			ExceptionHandler.handleException(e, null, var);
		}
		catch (Exception ex) {
			log.error(e.getMessage());
		}
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:12.540
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.540
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.540
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:12.541
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.541
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:12.558
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.service.core.dto;

import java.util.ArrayList;
import java.util.Date;

import com.loyauty.model.OrdersRows;

import lombok.Data;
import lombok.ToString;

@Data @ToString(callSuper=true) 
public class OrdersDTO extends  BasicDTO{
	private static final long serialVersionUID = -4362825927629396152L;
	private String 	cssRow="";
	private Long 	showRowShipping=0L;
	private Long 	showOnlyEditNote=0L;
	private Long 	count;
	private Boolean toUpdate=false;
	private Boolean manOrder=false;
	private Boolean duplicate=false;
	private Long 	infoMissing=0L;
	private Long 	saved=0L;
	private Boolean print;
	private String 	cssPrice;
	private String 	cssStyle;
	private String 	backgroundColor="";
	private Integer index=0;
	private Long   	clientProfileId;
	private Long  	userId;
	private String 	userLogin;
	private String 	lsOrderId;
	private String 	companyHeader;
	private String 	productOrderNumber;//poNumber
	private String	 clientOrderNumber;
	private Date 	productOrderDate; //poDate
	private Date 	requiredDate;
	private String	clientNumber;//clientNumber
	private String  clientOtherId;
	private String 	clientProductNumber;// code product given 
	private String 	clientFirstName;//clientFirstName 
	private String 	clientLastName; //clientLastName
	private String 	clientOtherNames;
	private String 	clientStreet; //clientAdress
	private String 	clientOtherStreet;//clientAdressOther
	private String 	clientCity;//clientCity
	private Double  quantityOriginal; // we use this variable to calculate quantities of products duplicated
	private String 	clientPostalCode;//clientPostalCode
	private String 	clientProvince;//clientProvince	
	private Long 	provinceNotFound;//clientProvince	
	private String 	clientPhone;//clientPhone
	private String 	clientEmail;//clientEmail	
	//private String  orderFileName;
	private String  orderFileInfo; //for rideau
	private Date 	creationDate;
	private Date    invoicedDate;
	//Special Handling
	private String specialHandlingName;
	private Double specialHandlingFee;
	private Double totalPrice;

	private ArrayList<OrdersRows> rowsList=new ArrayList<OrdersRows>();

	//rows info
	private String 	notes;
	private String 	cstProductNumber;
	private Double 	unitPrice;
	private String 	shippingCompany;
	private Date 	shippedDate;
	private String 	trackingNumber;
	private Double 	shippingPrice;
	private Double 	shippingFee;
	private String 	billed;
	private Double 	quantity;
	private Long 	productId;
	private String 	status;
	private String 	productDescription;
	private Double 	stock;
	private String 	lsProductID;
	private String  providedLsProductId; //ls_product_id provided by client
	private Double 	lsPrice;
	private Long 	orderId;
	
	//Currency
	private Long	currencyId;
	private String	currencySymbol;
	private Double	currencyRate;
	private Double 	currencyPrice;
	private Double 	currencyUnitPrice;
	private Double 	currencyTotalPrice;
	private Double 	currencyShippingPrice;
	
	//shipping_insurance_multiplier
	private Double shippingInsuranceMultiplier;
	
	private String notation="nothing";
	
	//ETA  secondEtaFieldName  secondEtaFieldValue
	private String etaFieldName;
	private String etaFieldValue;
	
	private String secondEtaFieldName;
	private String secondEtaFieldValue;
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:471)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:12.559
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:471)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:471)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.559
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:471)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.559
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:471)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:12.560
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:471)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:471)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.560
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:471)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:12.564
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;

import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceException;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OperationsDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.core.dto.UsersPrivilegesDTO;
import com.loyauty.service.operations.OperationsService;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class ReportOrders extends LoyautyAction {
	private static final long serialVersionUID = -3811760851445730062L;
	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	private OperationsService operationsService;
	@Getter
	@Setter
	private String userLogin;
	@Getter
	@Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter
	@Setter
	List<OrdersDTO> listOrdersDTO;
	@Getter
	@Setter
	List<OrdersDTO> listStatus;
	@Getter
	@Setter
	private String lsOrderId;
	@Getter
	@Setter
	Long poYpop;
	@Getter
	@Setter
	Long poXpop;
	@Getter
	@Setter
	private Long pageTop = 0L;
	@Getter
	@Setter
	private Date creationDate;
	@Getter
	@Setter
	private Long findOrdersSignal;
	private String status;
	@Getter
	@Setter
	private Long sizeResult = 0L;
	@Getter
	@Setter
	private Long sorting;
	@Getter
	@Setter
	private Long sortingOrdersSignal;
	@Getter
	@Setter
	private Integer fieldForSorting;
	@Getter
	@Setter
	private Integer asc;
	@Getter
	@Setter
	private Integer scrollDivRowsLeft;
	@Getter
	@Setter
	private Integer scrollPageLeft;
	@Getter
	@Setter
	private Integer scrollDivRowsTop;
	@Getter
	@Setter
	private String strCreationDateStart;
	@Getter
	@Setter
	private String strCreationDateEnd;
	@Getter
	@Setter
	private Date creationDateStart;
	@Getter
	@Setter
	private Date creationDateEnd;
	private Date creationDateStartArg;
	private Date creationDateEndArg;
	@Getter
	@Setter
	private Integer selectedStatus;
	@Getter
	@Setter
	private Long editOrderSignal;
	@Getter
	@Setter
	private Long cancelSignal;
	@Getter
	@Setter
	private Integer indexOrder;
	@Getter
	@Setter
	private OrdersDTO orderToEdit;
	@Getter
	@Setter
	private String strProductOrderDate;
	@Getter
	@Setter
	private String lsProductID;
	@Getter
	@Setter
	Integer indexRow;
	@Getter
	@Setter
	private String showOrderDetailPop;
	@Getter
	@Setter
	private Long userId;
	@Getter
	@Setter
	private Long checkProductPriceSignal;
	@Getter
	@Setter
	private Long saveTemporaryRowSignal;
	@Getter
	@Setter
	private Long addSimilarRowSignal;
	@Getter
	@Setter
	private Long deleteRowSignal;
	@Getter
	@Setter
	private Long saveOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxPrint;

	// recovery Data Order
	@Getter
	@Setter
	private String clientLastName;
	@Getter
	@Setter
	private String clientFirstName;
	@Getter
	@Setter
	private String clientOtherNames;
	@Getter
	@Setter
	private String clientStreet;
	@Getter
	@Setter
	private String clientOtherStreet;
	@Getter
	@Setter
	private String clientCity;
	@Getter
	@Setter
	private String clientProvince;
	@Getter
	@Setter
	private String clientPostalCode;
	@Getter
	@Setter
	private String clientPhone;
	@Getter
	@Setter
	private String clientEmail;
//	@Getter
//	@Setter
//	private String productOrderNumber;
	@Getter
	@Setter
	private String strRequiredDate;

	// recovery data row
	@Getter
	@Setter
	private Double quantity;
	@Getter
	@Setter
	private String notes;
	@Getter
	@Setter
	private Double quantityToChange;
	@Getter
	@Setter
	private Double stock;
	@Getter
	@Setter
	private String productDescription;
	@Getter
	@Setter
	private Double unitPrice;
	@Getter
	@Setter
	private Double shippingFee;
	@Getter
	@Setter
	private String shippingCompany;
	@Getter
	@Setter
	private String companyHeader;

	@Getter
	@Setter
	private Long quantityToChangeSignal;
	@Getter
	@Setter
	private Long duplicateOrderSignal;
	@Getter
	@Setter
	private String strCreationDate;
	@Getter
	@Setter
	private String strCreationOrderDate;
	@Getter
	@Setter
	private User usr;
	@Getter
	@Setter
	private String showSaveSuccessPop;
	// showSaveSuccessPop="display:block;visibility:visible;";
	// showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter
	@Setter
	private String message;
	@Getter
	@Setter
	private Long okSaveSuccessPopSignal;
	@Getter
	@Setter
	private Long showRowShipping;
	@Getter
	@Setter
	private Long showOnlyEditNote;
	@Getter
	@Setter
	private Long saveShippingSignal;
	@Getter
	@Setter
	private Long saveOnlyNoteSignal;
	@Getter
	@Setter
	private String code;
	@Getter
	@Setter
	private Long cityId;
	@Getter
	@Setter
	private List<ProvinceDTO> listProvinces;
	private Hashtable<String, ProvinceDTO> hashProvinces;
	@Getter
	@Setter
	private Boolean orderNotSavedAtFirst;
	@Getter
	@Setter
	private String strShippedDate;
	@Getter
	@Setter
	private String strShippingPrice;
	@Getter
	@Setter
	private String showConfirmDeleteOrderPop;
	@Getter
	@Setter
	private Long deleteOrderSignal;
	@Getter
	@Setter
	private Long confirmDeleteSignal;
	@Getter
	@Setter
	private UsersPrivilegesDTO userPrivileges;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivShippedToInvoiced;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivChangeShippedStatus;
	@Getter
	@Setter
	private HashMap<Integer, String> hashStatus;
	@Getter
	@Setter
	private Long statusId;
	@Getter
	@Setter
	private String strPrint;
	@Getter
	@Setter
	private Integer testSignal;
	@Getter
	@Setter
	private String newStatus;
	Long invoicedOrdersRefresh;
	@Getter
	@Setter
	private Integer reportDateBetween;
	@Getter
	@Setter
	private Long dateBetweenSignal;
	@Getter
	@Setter
	private Long selectAllOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxItem;
	// ------Pagination
	@Getter
	@Setter
	Long pageIndexSignal;
	@Getter
	@Setter
	Long prevListPagesSignal;
	@Getter
	@Setter
	Long nextListPagesSignal;
	@Getter
	@Setter
	Long totalOrders;
	@Getter
	@Setter
	Integer nextListPages;
	@Getter
	@Setter
	Integer prevListPages;
	@Getter
	@Setter
	Integer indexSet = 0;
	@Getter
	@Setter
	Integer indexList;
	@Getter
	@Setter
	List<OrdersDTO> listIndexSet;
	@Getter
	@Setter
	Integer PAGE_ITEMS_COUNT = 100;
	
	//New Added Field in the search option as toggle functionality
	@Getter
	@Setter
	private String productOrderNumberSearch;
	@Getter
	@Setter
	private String trakingNumber;
	@Getter
	@Setter
	private String  clientOther;
	@Getter
	@Setter
	private String	 clientOrderNumber;
	//New Added Field in the search option as toggle functionality

	// ------Pagination

	/*
	 * ==========================================================================
	 * =============== Default constructor
	 * ======================================
	 * ===================================================
	 */
	public ReportOrders() throws ServiceLocatorException {
		super();
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		productService = getServiceLocator().getProductService();
		operationsService = getServiceLocator().getOperationsService();
	}

	/*
	 * ==========================================================================
	 * =============== method execute
	 * ============================================
	 * =============================================
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		System.out.println("Product Order Number: "+ productOrderNumberSearch);
		System.out.println("Tracking Number: "+ trakingNumber);
		System.out.println("Client Order ID: "+ clientOrderNumber);
		System.out.println("Client Other ID: "+ clientOther);
		
		//Create new object or Order to modify the search functinality
		OrdersDTO orderDTOObj=new OrdersDTO();
		orderDTOObj.setLsOrderId(lsOrderId);
		orderDTOObj.setUserLogin(userLogin);
		orderDTOObj.setStatus(status);
		orderDTOObj.setProductOrderNumber(productOrderNumberSearch);
		orderDTOObj.setClientOrderNumber(clientOrderNumber);
		orderDTOObj.setClientOtherId(clientOther);
		
		HttpSession session = request.getSession(true);

		if (showOrderDetailPop == null)
			showOrderDetailPop = "visibility:hidden;display:none;";
		if (showConfirmDeleteOrderPop == null)
			showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
		if (showSaveSuccessPop == null)
			showSaveSuccessPop = "visibility:hidden;display:none;";
		if (poYpop == null)
			poYpop = 100L;
		if (poXpop == null)
			poXpop = 100L;
		Hashtable<String, OrdersDTO> hashOrders;
		if (selectedStatus == null)
			selectedStatus = -1;
		sizeResult = (Long) session.getAttribute("sizeResult");
		totalOrders = (Long) session.getAttribute("totalOrders");
		if (totalOrders == null)
			totalOrders = 0L;
		asc = (Integer) session.getAttribute("asc");
		if (asc == null)
			asc = 0;
		if (sizeResult == null)
			sizeResult = 0L;
		if (indexOrder == null)
			indexOrder = 0;
		userPrivileges = (UsersPrivilegesDTO) session.getAttribute("userPrivileges");
		usersPrivShippedToInvoiced = (UsersPrivilegesDTO) session.getAttribute("usersPrivShippedToInvoiced");
		usersPrivChangeShippedStatus = (UsersPrivilegesDTO) session
				.getAttribute("usersPrivChangeShippedStatus");
		hashStatus = (HashMap<Integer, String>) session
				.getAttribute("hashStatus");
		if (hashStatus == null) {
			hashStatus = new HashMap<Integer, String>();
			hashStatus.put(0, "");
			hashStatus.put(1, "open");
			hashStatus.put(2, "progress");
		}
		List<Integer> listIndexColumn = new ArrayList<Integer>();
		// fill list status
		listStatus = (ArrayList<OrdersDTO>) session.getAttribute("listStatus");
		if (listStatus == null) {
			listStatus = new ArrayList<OrdersDTO>();
			OrdersDTO orderDTOOpen = new OrdersDTO();
			orderDTOOpen.setStatus("open");
			orderDTOOpen.setId(0L);
			listStatus.add(orderDTOOpen);
			OrdersDTO orderDTOProgress = new OrdersDTO();
			orderDTOProgress.setStatus("progress");
			orderDTOProgress.setId(1L);
			listStatus.add(orderDTOProgress);
			if (usersPrivChangeShippedStatus != null) {
				OrdersDTO orderDTOShipped = new OrdersDTO();
				orderDTOShipped.setStatus("shipped");
				orderDTOShipped.setId(2L);
				listStatus.add(orderDTOShipped);
			}

		}

		try {

			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			// recovery provinces
			listProvinces = (List<ProvinceDTO>) session
					.getAttribute("listProvinces");
			if (listProvinces == null)
				listProvinces = productService.getAllProvinces();
			orderNotSavedAtFirst = (Boolean) session
					.getAttribute("listNotSavedAtFirst");
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession = (List<User>) session
					.getAttribute("usersListSession");
			if (usersListSession == null) {
				List<UserSessionDTO> listAllUsers = userService
						.getAllUsers(basicUserDTO);
				usersList = new ArrayList<User>();
				for (UserSessionDTO userDTO : listAllUsers) {
					User user = new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession", usersList);
			} else
				usersList = usersListSession;
			listOrdersDTO = (ArrayList<OrdersDTO>) session
					.getAttribute("listOrdersDTOReport");
			reportDateBetween = (Integer) session
					.getAttribute("reportDateBetween");
			if (reportDateBetween == null) {
				reportDateBetween = 0;
				session.setAttribute("reportDateBetween", reportDateBetween);
			}

			/*------ always check if the Admin select all orders ------------
					if The Admin select all orders change checkBoxItem value 
			  ---------------------------------------------------------------*/
			if (selectAllOrdersSignal != null && selectAllOrdersSignal != 0L) {
				if (checkBoxItem != null) {
					session.setAttribute("checkBoxItem", checkBoxItem);
					session.setAttribute("allOrdersSelectedSignal", 0L);
					if (checkBoxItem)
						session.setAttribute("allOrdersSelectedSignal", 1L);
				}
			}
			checkBoxItem = (Boolean) session.getAttribute("checkBoxItem");
			if (checkBoxItem == null)
				checkBoxItem = false;
			/*------ always recovery creationDate from strCreationDate ------
						always keep the user search options
			  ---------------------------------------------------------------*/
			creationDateStart = null;
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			if (((strCreationDateStart) != null)
					&& (!"".equals(strCreationDateStart))) {
				try {
					Date date = frm.parse(strCreationDateStart);
					creationDateStart = date;
					creationDateStartArg = date;
				} catch (Exception pe) {
					creationDateStart = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateStart == null) {
				Date date = frm.parse("01/01/1900");
				creationDateStartArg = date;
			}
			creationDateEnd = null;
			if (((strCreationDateEnd) != null)
					&& (!"".equals(strCreationDateEnd))) {
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationDateEnd);
					creationDateEnd = date;
					creationDateEndArg = date;
				} catch (Exception pe) {
					creationDateEnd = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateEnd == null) {
				creationDateEndArg = new Date();
			}

			/*------ always recovery Status from selectedStatus key ------
						always keep the status search options
			  ---------------------------------------------------------------*/
			status = getStatusSelected(selectedStatus);

			/*----------- always initialized listPages if not done ----------
				   		    and check if is there next listPages
			  ---------------------------------------------------------------*/
			nextListPages = (Integer) session.getAttribute("nextListPages");
			if (nextListPages == null)
				nextListPages = 0;
			if (indexSet == null || indexSet == -1) {
				indexSet = (Integer) session.getAttribute("indexSet");
				if (indexSet == null)
					indexSet = 0;
			}
			listIndexSet = (List<OrdersDTO>) session
					.getAttribute("listIndexSet");
			if (listIndexSet == null)
				initalizeListIndexSet(session, orderService);

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/

			if (dateBetweenSignal != null && dateBetweenSignal != 0L) {
				reportDateBetween = ((reportDateBetween == null || reportDateBetween == 0) ? 1
						: 0);
				listOrdersDTO = new ArrayList<OrdersDTO>();
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("reportDateBetween", reportDateBetween);
				return SUCCESS;
			}

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/
			if (pageIndexSignal != null && pageIndexSignal != 0L) {
				OrdersDTO orderDTO = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTO != null)
					orderDTO.setCssStyle("");
				OrdersDTO orderPageSelected = listIndexSet.get(indexList);
				orderPageSelected
						.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
				indexSet = orderPageSelected.getIndex() - 1;
				indexSet = indexSet * PAGE_ITEMS_COUNT;
				session.setAttribute("indexSet", indexSet);
				session.setAttribute("listIndexSet", listIndexSet);
				session.setAttribute("orderPageSelected", orderPageSelected);
			}

			/*----------------- When Admin Click on the nextListPages ------------------------------
						recreate listIndexSet started with index>index+10 and indexSet>indexSet+10
			 ---------------------------------------------------------------------------------------*/
			if (nextListPagesSignal != null && nextListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				OrdersDTO orderDTO = listIndexSet.get(listIndexSet.size() - 1);
				if (orderDTO != null)
					nextListPages = orderDTO.getIndex() + 1;
				Long totalOrders = orderService.getCountOrders(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status);
				String strcount = totalOrders.toString();
				Integer sizeList = Integer.parseInt(strcount)
						/ PAGE_ITEMS_COUNT;
				if (nextListPages <= sizeList + 1) {
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = nextListPages; i <= sizeList + 1
							&& i <= nextListPages + 10; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					if (nextListPages <= sizeList + 1) {
						indexSet = nextListPages - 1;
						OrdersDTO orderPageSelected = listIndexSet.get(0);
						orderPageSelected
								.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
						indexSet = indexSet * PAGE_ITEMS_COUNT;
						session.setAttribute("indexSet", indexSet);
						session.setAttribute("nextListPages", nextListPages);
						session.setAttribute("listIndexSet", listIndexSet);
						session.setAttribute("orderPageSelected",
								orderPageSelected);
					}
				}
			}

			/*----------------- When Admin Click on the previousListPages --------------------------
					recreate listIndexSet started with index< index-10 and indexSet<indexSet-10
			 ---------------------------------------------------------------------------------------*/
			if (prevListPagesSignal != null && prevListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				nextListPages = (Integer) session.getAttribute("nextListPages");
				if (nextListPages != null && nextListPages >= 11) {
					prevListPages = nextListPages - 11;
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = prevListPages; i < nextListPages; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					indexSet = prevListPages - 1;
					OrdersDTO orderPageSelected = listIndexSet.get(0);
					orderPageSelected
							.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
					indexSet = indexSet * PAGE_ITEMS_COUNT;
					nextListPages = prevListPages;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("indexSet", indexSet);
					session.setAttribute("listIndexSet", listIndexSet);
					session.setAttribute("orderPageSelected", orderPageSelected);
				}
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			hashProvinces = (Hashtable<String, ProvinceDTO>) session
					.getAttribute("hashProvinces");
			if (hashProvinces == null) {
				listProvinces = productService.getAllProvinces();
				Hashtable<String, ProvinceDTO> hashProvinces = new Hashtable<String, ProvinceDTO>();
				for (ProvinceDTO prov : listProvinces) {
					hashProvinces.put(prov.getCode(), prov);
				}
				session.setAttribute("hashProvinces", hashProvinces);
			}
			if (code != null && !code.equals("") && listOrdersDTO != null) {
				ProvinceDTO provinceDTO = hashProvinces.get(code);
				if (provinceDTO != null) {
					clientProvince = provinceDTO.getCode();
				}
			}// else listCities=new ArrayList<CityDTO>();
			if (listOrdersDTO != null && indexOrder != -1) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit != null) {
					orderToEdit.setClientProvince(code);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				}
			}

			/*------------------------------- Refresh listOrdersDTO------------------------------------
						Refresh listOrders before generation of invoiced orders XLS file 
				 ------------------------------------------------------------------------------------------*/
			invoicedOrdersRefresh = (Long) session
					.getAttribute("invoicedOrdersRefresh");
			if (invoicedOrdersRefresh != null && invoicedOrdersRefresh != 0L) {
				listIndexColumn = (ArrayList<Integer>) session
						.getAttribute("listIndexColumn");
				if (listIndexColumn == null)
					listIndexColumn = getNewListIndexColumn();
				lsOrderId = lsOrderId.toUpperCase();
				
				//Old Searching Functionality				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween,orderDTOObj,listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				//New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				indexSet = 0;
				session.setAttribute("indexSet", indexSet);
				nextListPages = 0;
				session.setAttribute("nextListPages", nextListPages);
				session.setAttribute("selectedStatus", selectedStatus);
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("invoicedOrdersRefresh", 0L);
				return SUCCESS;
			}

			/*------------ When Admin click on the Button "Delete Order" in The OrderDtailPop --------------
								show other pop to confirm Order Delete
			  ----------------------------------------------------------------------------------------------*/
			if (deleteOrderSignal != null && deleteOrderSignal != 0L) {
				message = "Attention! if you click on \"Delete Order\" you can not restore it.";
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (confirmDeleteSignal != null && confirmDeleteSignal == 0L) { // Delete
																				// Order
																				// Request
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "display:block;visibility:visible;";
				} else if (confirmDeleteSignal == 1L) { // Delete Order
														// Confirmed
					orderService.deleteOrderByLsOrderId(orderToEdit);
					// Save this operation in table operation
					OperationsDTO operationDTO = new OperationsDTO();
					User userAdmin = (User) session.getAttribute("userAdmin");
					if (userAdmin != null)
						operationDTO.setUserId(userAdmin.getId());
					operationDTO.setOperationDate(new Date());
					operationDTO.setOperationType("Delete Order");
					String dataBefore = "[PARTNER NAME:"
							+ orderToEdit.getUserLogin() + "];";
					dataBefore += " [LS_ORDER_ID:" + orderToEdit.getLsOrderId()
							+ "];";
					dataBefore += " [PRODUCT_ORDER_NUMBER:"
							+ orderToEdit.getProductOrderNumber() + "];";
					dataBefore += " [CLIENT_FIRST_NAME:"
							+ orderToEdit.getClientFirstName() + "];";
					dataBefore += " [CLIENT_LAST_NAME:"
							+ orderToEdit.getClientLastName() + "];";
					dataBefore += " [CLIENT_POSTAL_CODE:"
							+ orderToEdit.getClientPostalCode() + "];";
					dataBefore += " [LS_PRODUCT_ID:"
							+ orderToEdit.getLsProductID() + "];";
					dataBefore += " [UNIT_PRICE:" + orderToEdit.getUnitPrice()
							+ "];";
					dataBefore += " [STATUS:" + orderToEdit.getStatus() + "];";
					operationDTO.setDataBefore(dataBefore);
					operationDTO.setDataBefore(operationDTO.getDataBefore());
					operationDTO.setDataAfter("");
					operationsService.insertOperation(operationDTO);
					// Remove order from the list orders
					listOrdersDTO.remove(orderToEdit);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					showOrderDetailPop = "visibility:hidden;display:none;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
					// initialize index orders
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				} else { // Cancel Order Delete
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
				}
				return SUCCESS;
			}

			/*------ When Admin click the "Edit link" in the Order Table for Edit NOTE -----
							show only field Edit Note
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showOnlyEditNote != null && showOnlyEditNote != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowOnlyEditNote(0L);
					order.setCssRow("");
				}
				orderToEdit.setShowOnlyEditNote(1L);
				orderToEdit.setCssRow("background-color:#FF9966;");
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (ArrayList<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save Edit Note in the Orders Table" ----------
													save Only  notes
			  -------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOnlyNoteSignal != null && saveOnlyNoteSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						orderToEdit.setNotes(notes);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						orderToEdit.setCssRow("");
						// Save Note
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click the "Edit link" in the Order Table -------------
								show fields to edit shipping parameters
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showRowShipping != null && showRowShipping != 0L) {

				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowRowShipping(0L);
					order.setCssRow("");
				}
				// only Admins who has Active = true of action name='All' can
				// change shipping settings
				// of orders shipped or invoiced
				if (usersPrivChangeShippedStatus == null
						&& orderToEdit.getStatus() != null
						&& (orderToEdit.getStatus().equals("shipped") || orderToEdit
								.getStatus().equals("invoiced"))) {
					showRowShipping = 0L;
					return SUCCESS;
				}

				if (orderToEdit != null) {
					orderToEdit.setShowRowShipping(1L);
					orderToEdit.setShowOnlyEditNote(1L);
					orderToEdit.setCssRow("background-color:#FF9966;");
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (ArrayList<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				if (orderToEdit.getStatus().equals("open")) {
					statusId = 0L;
				} else if (orderToEdit.getStatus().equals("progress")) {
					statusId = 1L;
				} else if (orderToEdit.getStatus().equals("shipped")) {
					statusId = 2L;
				} else if (orderToEdit.getStatus().equals("invoiced")) {
					statusId = 3L;
				} else if (orderToEdit.getStatus().equals("canceled")) {
					statusId = 4L;
				}
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save in the Orders Table" ----------
							save all shipping parameters and notes
			 ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveShippingSignal != null && saveShippingSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						Date shippedDateToEdit = null;
						frm = new SimpleDateFormat("dd/MM/yyyy");
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))) {
							strShippedDate = strShippedDate.replaceAll(" ", "");
							try {
								Date date = frm.parse(strShippedDate);
								shippedDateToEdit = date;
							} catch (Exception pe) {
								shippedDateToEdit = null;
							}
						}
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))
								&& strShippedDate.length() <= 8)
							shippedDateToEdit = orderToEdit.getShippedDate();
						Double shippingPrice = null;
						// Double currencyShippingPrice=null;
						if (strShippingPrice != null
								&& !strShippingPrice.equals("")) {
							strShippingPrice = strShippingPrice.replaceAll(" ",
									"");
							int index = strShippingPrice.indexOf(",");
							if (index >= 0) {
								String strUnitPrice1 = strShippingPrice
										.substring(0, index);
								String strUnitPrice2 = strShippingPrice
										.substring(index + 1,
												strShippingPrice.length());
								strShippingPrice = strUnitPrice1 + "."
										+ strUnitPrice2;
							}

							try {
								shippingPrice = Double
										.parseDouble(strShippingPrice);
								/*
								 * if(shippingPrice!=null &&
								 * orderToEdit.getCurrencyId()!=null &&
								 * orderToEdit.getCurrencyId()!=1 &&
								 * orderToEdit.getCurrencyRate()!=null) {
								 * currencyShippingPrice = shippingPrice *
								 * orderToEdit.getCurrencyRate();
								 * currencyShippingPrice = (double)
								 * Math.round(currencyShippingPrice*100)/100; }
								 */
							} catch (Exception pe) {
								shippingPrice = null;
							}
						}

						if (trakingNumber != null)
							trakingNumber = trakingNumber.replaceAll(
									"^ +| +$|( )+", "$1");
						if (shippingCompany != null)
							shippingCompany = shippingCompany.replaceAll(
									"^ +| +$|( )+", "$1");
						orderToEdit.setShippingPrice(shippingPrice);
						// orderToEdit.setCurrencyShippingPrice(currencyShippingPrice);
						// orderToEdit.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
						orderToEdit.setShippedDate(shippedDateToEdit);
						orderToEdit.setNotes(notes);
						if (newStatus != null && !newStatus.equals(""))
							orderToEdit.setStatus(newStatus);
						orderToEdit.setShippingCompany(shippingCompany);
						orderToEdit.setTrackingNumber(trakingNumber);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						OrdersRows row = orderToEdit.getRowsList().get(0);
						row.setShippingPrice(shippingPrice);
						row.setShippingCompany(shippingCompany);
						row.setTrackingNumber(trakingNumber);
						orderToEdit.setCssRow("");

						if (newStatus != null && !newStatus.equals("")) { // if
																			// admin
																			// click
																			// on
																			// the
																			// save
																			// behind
																			// status
							orderService.updateStatusByLsOrderId(
									orderToEdit.getLsOrderId(), newStatus);
							orderToEdit.setStatus(newStatus);
							if (!newStatus.equals("shipped")
									&& !newStatus.equals("invoiced")
									&& !newStatus.equals("canceled")) {
								orderToEdit.setShippingPrice(null);
								orderToEdit.setTrackingNumber(null);
								orderToEdit.setShippedDate(null);
							}

						} else {// if admin click on the save other than Status
							if (orderToEdit.getShippedDate() != null
									&& orderToEdit.getTrackingNumber() != null
									&& !orderToEdit.getTrackingNumber().equals(
											"")
									&& orderToEdit.getShippingCompany() != null
									&& !orderToEdit.getShippingCompany()
											.equals("")
									&& orderToEdit.getShippingPrice() != null
									&& orderToEdit.getStatus() != null) {
								if (orderToEdit.getStatus().equals("open")
										|| orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"shipped");
									orderToEdit.setStatus("shipped");
								}
							} else {
								if (usersPrivChangeShippedStatus != null
										&& !orderToEdit.getStatus().equals(
												"open")
										&& !orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"progress");
									orderToEdit.setStatus("progress");
								}
							}
						}
						// if admin click on the save other then status(save
						// notes, save shipping company ...)
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click on icon findOrders.png ----------
								check user and complete infos client
			 ----------------------------------------------------------------*/
			if (findOrdersSignal != null
					&& findOrdersSignal != 0L
					|| (pageIndexSignal != null && pageIndexSignal != 0L)
					|| (nextListPagesSignal != null && nextListPagesSignal != 0L)
					|| (prevListPagesSignal != null && prevListPagesSignal != 0L)) {
				// session.setAttribute("allOrdersSelectedSignal",0L);
				// if admin click on search icon initialize checkBoxItem to
				// false
				if (findOrdersSignal != null && findOrdersSignal != 0L) {
					session.setAttribute("allOrdersSelectedSignal", 0L);
					checkBoxItem = false;
					session.setAttribute("checkBoxItem", checkBoxItem);
					indexSet = 0;
					session.setAttribute("indexSet", indexSet);
					nextListPages = 0;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("selectedStatus", selectedStatus);

				}
				// if admin navigate on pages keep the previous sorting
				if (((pageIndexSignal != null && pageIndexSignal != 0L)
						|| (nextListPagesSignal != null && nextListPagesSignal != 0L) || (prevListPagesSignal != null && prevListPagesSignal != 0L))) {
					listIndexColumn = (ArrayList<Integer>) session
							.getAttribute("listIndexColumn");
					if (listIndexColumn == null)
						listIndexColumn = getNewListIndexColumn();
				} else { // prepare new sorting
					listIndexColumn = getNewListIndexColumn();
				}

				lsOrderId = lsOrderId.toUpperCase();
				// if(findOrdersSignal!=null &&
				// findOrdersSignal!=0L)initalizeListIndexSet(session,orderService
				// );
				
				
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
//				//New Searching Functionality
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, orderDTOObj, listIndexColumn,
//						PAGE_ITEMS_COUNT, indexSet);
				
				
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);

				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("sizeResult", sizeResult);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				return SUCCESS;
			}

			/*------------ When Admin click on the icon sorting of column ----------
							seach result with option of sorting list
			 -----------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& sortingOrdersSignal != null && sortingOrdersSignal != 0L) {
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				asc = (asc == 1 ? -1 : 1);
				int nextElement = listIndexColumn.get(0);
				fieldForSorting = asc * fieldForSorting;
				listIndexColumn.set(0, fieldForSorting);
				for (int i = 1; i < listIndexColumn.size(); i++) {
					int element = listIndexColumn.get(i);
					listIndexColumn.set(i, nextElement);
					nextElement = element;
				}
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				// New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, orderDTOObj, listIndexColumn,
						PAGE_ITEMS_COUNT, indexSet);
				
				int balance = 0;
				int OrderIndex = 0;
				for (OrdersDTO orDTO : listOrdersDTO) {
					balance = (balance == 1 ? 0 : 1);
					if (balance == 1) {
						orDTO.setCssStyle("background-color: rgb(245,249,252);border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					} else {
						orDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					}
					orDTO.setIndex(OrderIndex);
					OrderIndex++;
				}
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("asc", asc);
				return SUCCESS;
			}

			/*------ when Admin click on the lsOrder link in table -----------
					show popup detail and allow admin to update Order
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& editOrderSignal != null && editOrderSignal != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit == null)
					orderToEdit = new OrdersDTO();
				if (orderToEdit.getProductOrderDate() == null)
					strProductOrderDate = "";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*--- when Admin click on the cancel Button of orderDetailPop ---
					we mast just hide popup OrderDetail
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& cancelSignal != null && cancelSignal != 0L) {
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}

			/*-------------------- When Admin left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& checkProductPriceSignal != null
					&& checkProductPriceSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToUpadate = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				UserProductPriceDTO userProductPrice = productService
						.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if (userProductPrice == null) {
					orderRowToUpadate.setCss("background-color:red;");
					orderRowToUpadate.setProductDescription("");
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				} else {
					Double usrPrice = orderRowToUpadate.getUnitPrice();
					if (usrPrice == null)
						usrPrice = 0D;
					if (usrPrice < userProductPrice.getPriceNum()) {
						orderRowToUpadate.setCssPrice("background-color:red;");
					}
					orderRowToUpadate.setProductDescription(userProductPrice
							.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice
							.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice
							.getLsProductId());
					orderRowToUpadate
							.setLsPrice(userProductPrice.getPriceNum());
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = orderDTOToUpdate;
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*----------------- When Admin check on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveTemporaryRowSignal != null
					&& saveTemporaryRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToSaveMemory = orderDTOToUpdate
						.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if (orderRowToSaveMemory != null) {
					orderRowToSaveMemory.setQuantity(quantity);
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory
							.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory
							.setCssPrice("background-color:#FF6666;");
					orderRowToSaveMemory
							.setCssQuantity("background-color:#FF6666;");
					if (quantity != null && quantity > 0D)
						orderRowToSaveMemory.setCssQuantity("");
					if (unitPrice != null
							&& orderRowToSaveMemory.getLsPrice() != null
							&& unitPrice >= orderRowToSaveMemory.getLsPrice())
						orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trakingNumber);
					if (orderRowToSaveMemory.getCurrencyId() != null
							&& orderRowToSaveMemory.getCurrencyId() != 1
							&& orderRowToSaveMemory.getCurrencyRate() != null) {
						if (unitPrice != null) {
							orderRowToSaveMemory
									.setCurrencyUnitPrice(unitPrice);
							unitPrice = unitPrice
									/ orderRowToSaveMemory.getCurrencyRate();
							unitPrice = (double) Math.round(unitPrice * 100) / 100;
							orderRowToSaveMemory.setUnitPrice(unitPrice);
						}
						/*
						 * if(shippingFee!=null) {
						 * orderRowToSaveMemory.setCurrencyShippingPrice
						 * (shippingFee); shippingFee =
						 * shippingFee/orderRowToSaveMemory.getCurrencyRate();
						 * shippingFee = (double)
						 * Math.round(shippingFee*100)/100;
						 * orderRowToSaveMemory.setShippingPrice(shippingFee); }
						 */
					}
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				// Change totalPrice also
				if (orderToEdit.getRowsList().get(0) != null
						&& orderToEdit.getRowsList().get(0).getQuantity() != null
						&& orderToEdit.getRowsList().get(0)
								.getQuantityToSplit() != null
						&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
					Double priceTotal = orderToEdit.getRowsList().get(0)
							.getUnitPrice()
							* orderToEdit.getRowsList().get(0)
									.getQuantityToSplit();
					priceTotal = (double) Math.round(priceTotal * 100) / 100;
					orderToEdit.setTotalPrice(priceTotal);
				}
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------- When Admin click on addSimilarRow Icon on the OrderDetailPop --------
								Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& addSimilarRowSignal != null && addSimilarRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				// generate lsOrderId to new order
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				if (orderRowToClone != null) {
					if (!orderRowToClone.getIcon().equals(
							"images/orders/itemValidated.png")) {
						orderRowToClone.setQuantity(quantity);
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone
								.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trakingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd = DTOFactory
							.getOrderRowClone(orderRowToClone);
					orderRowToAdd.setId(-1L);
					// Add currencyId
					if (orderRowToClone.getCurrencyId() != null)
						orderRowToAdd.setCurrencyId(orderRowToClone
								.getCurrencyId());

					orderDTOToUpdate.getRowsList().add(indexRow + 1,
							orderRowToAdd);
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------- When Admin click on Delete Row Icon of orderDetail Popup-----------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& deleteRowSignal != null && deleteRowSignal != 0L) {
				OrdersDTO orderDTO = listOrdersDTO.get(indexOrder);
				orderDTO = fillDataOrderDTO(orderDTO);
				int nb = orderService.nbOrderRowsNotDeleted(orderDTO
						.getRowsList());
				if (orderDTO != null && orderDTO.getRowsList().size() > 1) {
					for (int i = 0; i < orderDTO.getRowsList().size(); i++) {
						if (i == indexRow && nb > 1) {
							orderDTO.getRowsList().get(i).setToDelete(1);
							break;
						}
					}
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ when Admin click on the button save of orderDetail ------------------
					 save order and hide pup  
			  ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOrdersSignal != null && saveOrdersSignal != 0L) {
				session.setAttribute("orderNotSavedAtFirst", null);
				orderToEdit = listOrdersDTO.get(indexOrder);
				orderToEdit = fillDataOrderDTO(orderToEdit);

				// add special handling shipping
				User user = null;
				if (orderToEdit.getUserLogin() != null)
					user = userService.getUserByLogin(orderToEdit
							.getUserLogin());
				if (user != null) {
					Double totalPrice = null;
					orderToEdit.setSpecialHandlingName(user
							.getSpecialHandlingName());
					orderToEdit.setSpecialHandlingFee(user
							.getSpecialHandlingFee());
					if (orderToEdit.getRowsList().get(0).getQuantity() != null
							&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
						totalPrice = orderToEdit.getRowsList().get(0)
								.getQuantity()
								* orderToEdit.getRowsList().get(0)
										.getUnitPrice();
						totalPrice = (double) Math.round(totalPrice * 100) / 100;
					}

					orderToEdit.setTotalPrice(totalPrice);
				}

				orderService.updateOrderByLsOrderId(orderToEdit);
				for (OrdersRows row : orderToEdit.getRowsList()) {
					if (row.getId() == -1)
						row.setId(0L);
				}
				OrdersRows row = orderToEdit.getRowsList().get(0);
				if (row != null) {
					orderToEdit.getShippedDate();
					orderToEdit.setLsPrice(row.getLsPrice());
					orderToEdit.setLsProductID(row.getLsProductID());
					orderToEdit.setProductDescription(row
							.getProductDescription());
					orderToEdit.setQuantity(row.getQuantity());
				}
				orderToEdit = DTOFactory.getOrderDTOConsideredMissingInfo(
						orderToEdit, hashProvinces);
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				// New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, orderDTOObj, listIndexColumn,
						PAGE_ITEMS_COUNT, indexSet);
				
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				message = "Saving has completed successfuly";
				showSaveSuccessPop = "display:block;visibility:visible;";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ When user change Quantity to split in orderDetailPop -----------
					 prepare order to split from two other orders witch
				 	 one must have a lsOrder with underscore 
			 ------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& quantityToChangeSignal != null
					&& quantityToChangeSignal != 0L) {
				OrdersDTO orderToChangeQt = listOrdersDTO.get(indexOrder);
				OrdersRows orderRow = orderToChangeQt.getRowsList().get(
						indexRow);
				orderToChangeQt = fillDataOrderDTO(orderToChangeQt);
				if (quantityToChange < orderRow.getQuantity())
					orderRow.setQuantityToSplit(quantityToChange);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- Duplicate Order ----------------------------------------
							Create order in just in memory
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& duplicateOrderSignal != null
					&& duplicateOrderSignal != 0L) {
				OrdersDTO orderToClone = listOrdersDTO.get(indexOrder);
				orderToClone = fillDataOrderDTO(orderToClone);
				hashOrders = new Hashtable<String, OrdersDTO>();
				for (OrdersDTO ord : listOrdersDTO) {
					hashOrders.put(ord.getLsOrderId(), ord);
				}
				OrdersDTO orderClone = DTOFactory
						.getOrderDTOSplitted(orderToClone);
				if (orderClone != null) {
					orderClone.setDuplicate(true);
					String lsOrder = orderClone.getLsOrderId();
					String strlsOrder = orderService.generateLsOrderId(lsOrder,
							hashOrders);
					orderClone.setLsOrderId(strlsOrder);// rgb(116,180,209)
					orderClone
							.setCssStyle("background-color:#FFFF99;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					orderToEdit = orderClone;
					orderToEdit.setBackgroundColor("background-color:#FFFF99;");
					listOrdersDTO.add(indexOrder + 1, orderClone);
					indexOrder = 0;
					for (OrdersDTO ord : listOrdersDTO) {
						ord.setIndex(indexOrder);
						indexOrder++;
					}
					orderService.updateOrderByLsOrderId(orderToClone);
					orderService.insertOrderWithRows(orderClone);
					orderClone.setDuplicate(false);
					for (OrdersRows row : orderClone.getRowsList()) {
						if (row.getId() < 0L)
							row.setId(0L);
					}
					if (listOrdersDTO.size() > 0) {
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				} else
					orderToEdit = orderToClone;
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& okSaveSuccessPopSignal != null
					&& okSaveSuccessPopSignal != 0L) {
				showSaveSuccessPop = "visibility:hidden;display:none;";
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}

	/*
	 * ==========================================================================
	 * =============== fill all fields of order without rows
	 * ====================
	 * =====================================================================
	 */
	public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO) {
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		orderDTO.setClientLastName(clientLastName);
		orderDTO.setClientFirstName(clientFirstName);
		orderDTO.setClientOtherNames(clientOtherNames);
		orderDTO.setClientStreet(clientStreet);
		orderDTO.setClientOtherStreet(clientOtherStreet);
		orderDTO.setClientCity(clientCity);
		orderDTO.setClientProvince(code);
		orderDTO.setClientPostalCode(clientPostalCode);
		orderDTO.setClientPhone(clientPhone);
		orderDTO.setClientEmail(clientEmail);
		orderDTO.setProductOrderNumber(productOrderNumberSearch);
		orderDTO.setCompanyHeader(companyHeader);
		if (((strProductOrderDate) != null)
				&& (!"".equals(strProductOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strProductOrderDate);
				orderDTO.setProductOrderDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strCreationOrderDate) != null)
				&& (!"".equals(strCreationOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strCreationOrderDate);
				orderDTO.setCreationDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strRequiredDate) != null) && (!"".equals(strRequiredDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strRequiredDate);
				orderDTO.setRequiredDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}
		return orderDTO;
	}

	/*
	 * ==========================================================================
	 * =============== initialize ListIndexSet
	 * ==================================
	 * =======================================================
	 */
	public void initalizeListIndexSet(HttpSession session,
			OrdersService orderService) throws ServiceException {
		listIndexSet = new ArrayList<OrdersDTO>();
		totalOrders = orderService.getCountOrders(creationDateStartArg,
				creationDateEndArg, reportDateBetween, userLogin, lsOrderId,
				status);
		String strcount = totalOrders.toString();
		Integer sizeList = Integer.parseInt(strcount) / PAGE_ITEMS_COUNT;
		nextListPages = 1;
		session.setAttribute("nextListPages", nextListPages);
		for (int i = 1; i <= sizeList + 1 && i <= 11; i++) {
			OrdersDTO ord = new OrdersDTO();
			ord.setCssStyle("");
			ord.setIndex(i);
			listIndexSet.add(ord);
		}
		indexSet = 0;
		session.setAttribute("indexSet", indexSet);
		session.setAttribute("totalOrders", totalOrders);
		session.setAttribute("listIndexSet", listIndexSet);

	}

	/*
	 * ==========================================================================
	 * =============== initialize listIndexColumn
	 * ================================
	 * =========================================================
	 */
	List<Integer> getNewListIndexColumn() {
		List<Integer> reult = new ArrayList<Integer>();
		for (int i = 0; i <= 34; i++) {
			if (i != 2 && i <= 13) {
				reult.add(i);
				if (i != 0)
					reult.add(-i);
			}
			if (i == 30 || i == 31 || i == 34) {
				reult.add(i);
				reult.add(-i);
			}
		}
		return reult;
	}

	/*
	 * ==========================================================================
	 * =============== getStatus Selected by Admin for searching
	 * ================
	 * =========================================================================
	 */
	public String getStatusSelected(Integer StatusIndex) {
		String result = "";
		switch (StatusIndex) {
		case 0:
			result = "open";
			break;
		case 1:
			result = "progress";
			break;
		case 2:
			result = "shipped";
			break;
		case 3:
			result = "invoiced";
			break;
		case 4:
			result = "canceled";
			break;
		default:
			result = "";
		}
		return result;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:12.567
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 16 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.567
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.568
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:12.568
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 16 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:12.569
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:134)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:410)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:13.107
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpSession;

import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.web.struts.action.LoyautyAction;
import com.sun.xml.internal.ws.api.ha.StickyFeature;

public class GetOrdersByPOSumit extends LoyautyAction {
	private static final long serialVersionUID = 2352657794009174955L;

	private static OrdersService orderService;
	
	@Getter @Setter
	private Integer sumit;
	
	
	@Getter @Setter
	private List<OrdersDTO> ordersListSumit;
	
	@Getter @Setter
	private OrdersDTO ordersDTO;
	@Getter @Setter
	private String productOrderNumber;
	
	public  GetOrdersByPOSumit() throws ServiceLocatorException {
		super();	
		orderService = getServiceLocator().getOrderService();
		ordersListSumit=new ArrayList<OrdersDTO>();
		ordersDTO=new OrdersDTO();

	}
	/*=========================================================================================
											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		
		System.out.println("I am at GetOrdersByPOSumit Action:Execute Method");

		try {
			ordersDTO.setProductOrderNumber(productOrderNumber);
			ordersListSumit=orderService.getOrdersByProductOrderNumberSumit(ordersDTO);
//			ordersListSumit = orderService.getAllOrders();
			HttpSession session = request.getSession(true);

		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}


}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:13.107
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:13.108
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:13.108
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:13.109
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:13.109
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:13.138
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class GoToOrders extends LoyautyAction {
	private static final long serialVersionUID = 2352657794009174955L;

	private UserService userService;
	private static ProductService productService;
	private static OrdersService orderService;
	private Date today;
	@Getter @Setter
	private List<OrdersDTO>listOrdersDTO;
	@Getter @Setter
	private List<User> usersList;
	@Getter @Setter
	private Long init;
	@Getter @Setter
	private Date creationDate ;
	@Getter @Setter
	private Date creationDateStart ;
	@Getter @Setter
	List<ProvinceDTO>listProvinces;
	@Getter @Setter
	private Integer reportDateBetween;
	@Getter @Setter
	private Integer invoicingDateBetween;
	@Getter @Setter 
	private String  code;

	private static int USER_TYPE = 2;

	public  GoToOrders() throws ServiceLocatorException {
		super();	
		userService = getServiceLocator().getUserService();
		productService = getServiceLocator().getProductService();
		orderService = getServiceLocator().getOrderService();
		today=new Date();
		usersList=new ArrayList<User>();
		listOrdersDTO=new ArrayList<OrdersDTO>();
	}
	/*=========================================================================================
											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		
		System.out.println("I am at Handeling Page");

		try {
			HttpSession session = request.getSession(true);
			listProvinces=productService.getAllProvinces();
			session.setAttribute("reportDateBetween",0);
			session.setAttribute("invoicingDateBetween",0);
			session.setAttribute("indexSet",0);  
			session.setAttribute("nextListPages",0);
			session.setAttribute("checkBoxItem",false);
			session.setAttribute("invoicedOrdersRefresh",0L);
			new ReportOrders().initalizeListIndexSet(session, orderService);
			session.setAttribute("totalInvoicedOrders",0L);
			session.setAttribute("totalOrders",0L);
			Hashtable<String, ProvinceDTO> hashProvinces=new Hashtable<String, ProvinceDTO>();
			for(ProvinceDTO prov:listProvinces){
				hashProvinces.put(prov.getCode(), prov);
			}
			session.setAttribute("hashProvinces",hashProvinces);
			//------------------ recovery users list ---------------------------
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession=(List<User>)session.getAttribute("usersListSession");
			if(usersListSession==null){
				List<UserSessionDTO> listAllUsers= userService.getAllUsers(basicUserDTO);
				for(UserSessionDTO userDTO:listAllUsers){
					User user=new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession",usersList);
			}else usersList=usersListSession;
			session.setAttribute("listOrdersDTOMan",null);
			session.setAttribute("listOrdersDTOAuto",null);
			if(init!=null && init!=0){
				int call=Integer.parseInt(init.toString());
				switch (call) {
				case 1:
					SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
					String lsOrderIdFirstPart="Man"+sdf.format(today);
					String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
					OrdersDTO orderDTO=new OrdersDTO();
					orderDTO.setLsOrderId(manLsOrderId);
					orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					OrdersRows orderRow=new OrdersRows();
					orderRow.setIcon("images/orders/itemNotValidated.png");
					orderDTO.getRowsList().add(orderRow);
					listOrdersDTO.add(orderDTO);
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					break;
				case 2:
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}


}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:13.139
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:13.139
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:13.140
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:13.140
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:13.140
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:14.156
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;

import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceException;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OperationsDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.core.dto.UsersPrivilegesDTO;
import com.loyauty.service.operations.OperationsService;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class ReportOrders extends LoyautyAction {
	private static final long serialVersionUID = -3811760851445730062L;
	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	private OperationsService operationsService;
	@Getter
	@Setter
	private String userLogin;
	@Getter
	@Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter
	@Setter
	List<OrdersDTO> listOrdersDTO;
	@Getter
	@Setter
	List<OrdersDTO> listStatus;
	@Getter
	@Setter
	private String lsOrderId;
	@Getter
	@Setter
	Long poYpop;
	@Getter
	@Setter
	Long poXpop;
	@Getter
	@Setter
	private Long pageTop = 0L;
	@Getter
	@Setter
	private Date creationDate;
	@Getter
	@Setter
	private Long findOrdersSignal;
	private String status;
	@Getter
	@Setter
	private Long sizeResult = 0L;
	@Getter
	@Setter
	private Long sorting;
	@Getter
	@Setter
	private Long sortingOrdersSignal;
	@Getter
	@Setter
	private Integer fieldForSorting;
	@Getter
	@Setter
	private Integer asc;
	@Getter
	@Setter
	private Integer scrollDivRowsLeft;
	@Getter
	@Setter
	private Integer scrollPageLeft;
	@Getter
	@Setter
	private Integer scrollDivRowsTop;
	@Getter
	@Setter
	private String strCreationDateStart;
	@Getter
	@Setter
	private String strCreationDateEnd;
	@Getter
	@Setter
	private Date creationDateStart;
	@Getter
	@Setter
	private Date creationDateEnd;
	private Date creationDateStartArg;
	private Date creationDateEndArg;
	@Getter
	@Setter
	private Integer selectedStatus;
	@Getter
	@Setter
	private Long editOrderSignal;
	@Getter
	@Setter
	private Long cancelSignal;
	@Getter
	@Setter
	private Integer indexOrder;
	@Getter
	@Setter
	private OrdersDTO orderToEdit;
	@Getter
	@Setter
	private String strProductOrderDate;
	@Getter
	@Setter
	private String lsProductID;
	@Getter
	@Setter
	Integer indexRow;
	@Getter
	@Setter
	private String showOrderDetailPop;
	@Getter
	@Setter
	private Long userId;
	@Getter
	@Setter
	private Long checkProductPriceSignal;
	@Getter
	@Setter
	private Long saveTemporaryRowSignal;
	@Getter
	@Setter
	private Long addSimilarRowSignal;
	@Getter
	@Setter
	private Long deleteRowSignal;
	@Getter
	@Setter
	private Long saveOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxPrint;

	// recovery Data Order
	@Getter
	@Setter
	private String clientLastName;
	@Getter
	@Setter
	private String clientFirstName;
	@Getter
	@Setter
	private String clientOtherNames;
	@Getter
	@Setter
	private String clientStreet;
	@Getter
	@Setter
	private String clientOtherStreet;
	@Getter
	@Setter
	private String clientCity;
	@Getter
	@Setter
	private String clientProvince;
	@Getter
	@Setter
	private String clientPostalCode;
	@Getter
	@Setter
	private String clientPhone;
	@Getter
	@Setter
	private String clientEmail;
//	@Getter
//	@Setter
//	private String productOrderNumber;
	@Getter
	@Setter
	private String strRequiredDate;

	// recovery data row
	@Getter
	@Setter
	private Double quantity;
	@Getter
	@Setter
	private String notes;
	@Getter
	@Setter
	private Double quantityToChange;
	@Getter
	@Setter
	private Double stock;
	@Getter
	@Setter
	private String productDescription;
	@Getter
	@Setter
	private Double unitPrice;
	@Getter
	@Setter
	private Double shippingFee;
	@Getter
	@Setter
	private String shippingCompany;
	@Getter
	@Setter
	private String companyHeader;

	@Getter
	@Setter
	private Long quantityToChangeSignal;
	@Getter
	@Setter
	private Long duplicateOrderSignal;
	@Getter
	@Setter
	private String strCreationDate;
	@Getter
	@Setter
	private String strCreationOrderDate;
	@Getter
	@Setter
	private User usr;
	@Getter
	@Setter
	private String showSaveSuccessPop;
	// showSaveSuccessPop="display:block;visibility:visible;";
	// showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter
	@Setter
	private String message;
	@Getter
	@Setter
	private Long okSaveSuccessPopSignal;
	@Getter
	@Setter
	private Long showRowShipping;
	@Getter
	@Setter
	private Long showOnlyEditNote;
	@Getter
	@Setter
	private Long saveShippingSignal;
	@Getter
	@Setter
	private Long saveOnlyNoteSignal;
	@Getter
	@Setter
	private String code;
	@Getter
	@Setter
	private Long cityId;
	@Getter
	@Setter
	private List<ProvinceDTO> listProvinces;
	private Hashtable<String, ProvinceDTO> hashProvinces;
	@Getter
	@Setter
	private Boolean orderNotSavedAtFirst;
	@Getter
	@Setter
	private String strShippedDate;
	@Getter
	@Setter
	private String strShippingPrice;
	@Getter
	@Setter
	private String showConfirmDeleteOrderPop;
	@Getter
	@Setter
	private Long deleteOrderSignal;
	@Getter
	@Setter
	private Long confirmDeleteSignal;
	@Getter
	@Setter
	private UsersPrivilegesDTO userPrivileges;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivShippedToInvoiced;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivChangeShippedStatus;
	@Getter
	@Setter
	private HashMap<Integer, String> hashStatus;
	@Getter
	@Setter
	private Long statusId;
	@Getter
	@Setter
	private String strPrint;
	@Getter
	@Setter
	private Integer testSignal;
	@Getter
	@Setter
	private String newStatus;
	Long invoicedOrdersRefresh;
	@Getter
	@Setter
	private Integer reportDateBetween;
	@Getter
	@Setter
	private Long dateBetweenSignal;
	@Getter
	@Setter
	private Long selectAllOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxItem;
	// ------Pagination
	@Getter
	@Setter
	Long pageIndexSignal;
	@Getter
	@Setter
	Long prevListPagesSignal;
	@Getter
	@Setter
	Long nextListPagesSignal;
	@Getter
	@Setter
	Long totalOrders;
	@Getter
	@Setter
	Integer nextListPages;
	@Getter
	@Setter
	Integer prevListPages;
	@Getter
	@Setter
	Integer indexSet = 0;
	@Getter
	@Setter
	Integer indexList;
	@Getter
	@Setter
	List<OrdersDTO> listIndexSet;
	@Getter
	@Setter
	Integer PAGE_ITEMS_COUNT = 100;
	
	//New Added Field in the search option as toggle functionality
	@Getter
	@Setter
	private String productOrderNumberSearch;
	@Getter
	@Setter
	private String trakingNumber;
	@Getter
	@Setter
	private String  clientOther;
	@Getter
	@Setter
	private String	 clientOrderNumber;
	//New Added Field in the search option as toggle functionality

	// ------Pagination

	/*
	 * ==========================================================================
	 * =============== Default constructor
	 * ======================================
	 * ===================================================
	 */
	public ReportOrders() throws ServiceLocatorException {
		super();
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		productService = getServiceLocator().getProductService();
		operationsService = getServiceLocator().getOperationsService();
	}

	/*
	 * ==========================================================================
	 * =============== method execute
	 * ============================================
	 * =============================================
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		System.out.println("Product Order Number: "+ productOrderNumberSearch);
		System.out.println("Tracking Number: "+ trakingNumber);
		System.out.println("Client Order ID: "+ clientOrderNumber);
		System.out.println("Client Other ID: "+ clientOther);
		
		//Create new object or Order to modify the search functinality
		OrdersDTO orderDTOObj=new OrdersDTO();
		orderDTOObj.setLsOrderId(lsOrderId);
		orderDTOObj.setUserLogin(userLogin);
		orderDTOObj.setStatus(status);
		orderDTOObj.setProductOrderNumber(productOrderNumberSearch);
		orderDTOObj.setClientOrderNumber(clientOrderNumber);
		orderDTOObj.setClientOtherId(clientOther);
		
		HttpSession session = request.getSession(true);

		if (showOrderDetailPop == null)
			showOrderDetailPop = "visibility:hidden;display:none;";
		if (showConfirmDeleteOrderPop == null)
			showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
		if (showSaveSuccessPop == null)
			showSaveSuccessPop = "visibility:hidden;display:none;";
		if (poYpop == null)
			poYpop = 100L;
		if (poXpop == null)
			poXpop = 100L;
		Hashtable<String, OrdersDTO> hashOrders;
		if (selectedStatus == null)
			selectedStatus = -1;
		sizeResult = (Long) session.getAttribute("sizeResult");
		totalOrders = (Long) session.getAttribute("totalOrders");
		if (totalOrders == null)
			totalOrders = 0L;
		asc = (Integer) session.getAttribute("asc");
		if (asc == null)
			asc = 0;
		if (sizeResult == null)
			sizeResult = 0L;
		if (indexOrder == null)
			indexOrder = 0;
		userPrivileges = (UsersPrivilegesDTO) session.getAttribute("userPrivileges");
		usersPrivShippedToInvoiced = (UsersPrivilegesDTO) session.getAttribute("usersPrivShippedToInvoiced");
		usersPrivChangeShippedStatus = (UsersPrivilegesDTO) session
				.getAttribute("usersPrivChangeShippedStatus");
		hashStatus = (HashMap<Integer, String>) session
				.getAttribute("hashStatus");
		if (hashStatus == null) {
			hashStatus = new HashMap<Integer, String>();
			hashStatus.put(0, "");
			hashStatus.put(1, "open");
			hashStatus.put(2, "progress");
		}
		List<Integer> listIndexColumn = new ArrayList<Integer>();
		// fill list status
		listStatus = (ArrayList<OrdersDTO>) session.getAttribute("listStatus");
		if (listStatus == null) {
			listStatus = new ArrayList<OrdersDTO>();
			OrdersDTO orderDTOOpen = new OrdersDTO();
			orderDTOOpen.setStatus("open");
			orderDTOOpen.setId(0L);
			listStatus.add(orderDTOOpen);
			OrdersDTO orderDTOProgress = new OrdersDTO();
			orderDTOProgress.setStatus("progress");
			orderDTOProgress.setId(1L);
			listStatus.add(orderDTOProgress);
			if (usersPrivChangeShippedStatus != null) {
				OrdersDTO orderDTOShipped = new OrdersDTO();
				orderDTOShipped.setStatus("shipped");
				orderDTOShipped.setId(2L);
				listStatus.add(orderDTOShipped);
			}

		}

		try {

			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			// recovery provinces
			listProvinces = (List<ProvinceDTO>) session
					.getAttribute("listProvinces");
			if (listProvinces == null)
				listProvinces = productService.getAllProvinces();
			orderNotSavedAtFirst = (Boolean) session
					.getAttribute("listNotSavedAtFirst");
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession = (List<User>) session
					.getAttribute("usersListSession");
			if (usersListSession == null) {
				List<UserSessionDTO> listAllUsers = userService
						.getAllUsers(basicUserDTO);
				usersList = new ArrayList<User>();
				for (UserSessionDTO userDTO : listAllUsers) {
					User user = new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession", usersList);
			} else
				usersList = usersListSession;
			listOrdersDTO = (ArrayList<OrdersDTO>) session
					.getAttribute("listOrdersDTOReport");
			reportDateBetween = (Integer) session
					.getAttribute("reportDateBetween");
			if (reportDateBetween == null) {
				reportDateBetween = 0;
				session.setAttribute("reportDateBetween", reportDateBetween);
			}

			/*------ always check if the Admin select all orders ------------
					if The Admin select all orders change checkBoxItem value 
			  ---------------------------------------------------------------*/
			if (selectAllOrdersSignal != null && selectAllOrdersSignal != 0L) {
				if (checkBoxItem != null) {
					session.setAttribute("checkBoxItem", checkBoxItem);
					session.setAttribute("allOrdersSelectedSignal", 0L);
					if (checkBoxItem)
						session.setAttribute("allOrdersSelectedSignal", 1L);
				}
			}
			checkBoxItem = (Boolean) session.getAttribute("checkBoxItem");
			if (checkBoxItem == null)
				checkBoxItem = false;
			/*------ always recovery creationDate from strCreationDate ------
						always keep the user search options
			  ---------------------------------------------------------------*/
			creationDateStart = null;
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			if (((strCreationDateStart) != null)
					&& (!"".equals(strCreationDateStart))) {
				try {
					Date date = frm.parse(strCreationDateStart);
					creationDateStart = date;
					creationDateStartArg = date;
				} catch (Exception pe) {
					creationDateStart = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateStart == null) {
				Date date = frm.parse("01/01/1900");
				creationDateStartArg = date;
			}
			creationDateEnd = null;
			if (((strCreationDateEnd) != null)
					&& (!"".equals(strCreationDateEnd))) {
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationDateEnd);
					creationDateEnd = date;
					creationDateEndArg = date;
				} catch (Exception pe) {
					creationDateEnd = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateEnd == null) {
				creationDateEndArg = new Date();
			}

			/*------ always recovery Status from selectedStatus key ------
						always keep the status search options
			  ---------------------------------------------------------------*/
			status = getStatusSelected(selectedStatus);

			/*----------- always initialized listPages if not done ----------
				   		    and check if is there next listPages
			  ---------------------------------------------------------------*/
			nextListPages = (Integer) session.getAttribute("nextListPages");
			if (nextListPages == null)
				nextListPages = 0;
			if (indexSet == null || indexSet == -1) {
				indexSet = (Integer) session.getAttribute("indexSet");
				if (indexSet == null)
					indexSet = 0;
			}
			listIndexSet = (List<OrdersDTO>) session
					.getAttribute("listIndexSet");
			if (listIndexSet == null)
				initalizeListIndexSet(session, orderService);

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/

			if (dateBetweenSignal != null && dateBetweenSignal != 0L) {
				reportDateBetween = ((reportDateBetween == null || reportDateBetween == 0) ? 1
						: 0);
				listOrdersDTO = new ArrayList<OrdersDTO>();
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("reportDateBetween", reportDateBetween);
				return SUCCESS;
			}

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/
			if (pageIndexSignal != null && pageIndexSignal != 0L) {
				OrdersDTO orderDTO = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTO != null)
					orderDTO.setCssStyle("");
				OrdersDTO orderPageSelected = listIndexSet.get(indexList);
				orderPageSelected
						.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
				indexSet = orderPageSelected.getIndex() - 1;
				indexSet = indexSet * PAGE_ITEMS_COUNT;
				session.setAttribute("indexSet", indexSet);
				session.setAttribute("listIndexSet", listIndexSet);
				session.setAttribute("orderPageSelected", orderPageSelected);
			}

			/*----------------- When Admin Click on the nextListPages ------------------------------
						recreate listIndexSet started with index>index+10 and indexSet>indexSet+10
			 ---------------------------------------------------------------------------------------*/
			if (nextListPagesSignal != null && nextListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				OrdersDTO orderDTO = listIndexSet.get(listIndexSet.size() - 1);
				if (orderDTO != null)
					nextListPages = orderDTO.getIndex() + 1;
				Long totalOrders = orderService.getCountOrders(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status);
				String strcount = totalOrders.toString();
				Integer sizeList = Integer.parseInt(strcount)
						/ PAGE_ITEMS_COUNT;
				if (nextListPages <= sizeList + 1) {
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = nextListPages; i <= sizeList + 1
							&& i <= nextListPages + 10; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					if (nextListPages <= sizeList + 1) {
						indexSet = nextListPages - 1;
						OrdersDTO orderPageSelected = listIndexSet.get(0);
						orderPageSelected
								.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
						indexSet = indexSet * PAGE_ITEMS_COUNT;
						session.setAttribute("indexSet", indexSet);
						session.setAttribute("nextListPages", nextListPages);
						session.setAttribute("listIndexSet", listIndexSet);
						session.setAttribute("orderPageSelected",
								orderPageSelected);
					}
				}
			}

			/*----------------- When Admin Click on the previousListPages --------------------------
					recreate listIndexSet started with index< index-10 and indexSet<indexSet-10
			 ---------------------------------------------------------------------------------------*/
			if (prevListPagesSignal != null && prevListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				nextListPages = (Integer) session.getAttribute("nextListPages");
				if (nextListPages != null && nextListPages >= 11) {
					prevListPages = nextListPages - 11;
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = prevListPages; i < nextListPages; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					indexSet = prevListPages - 1;
					OrdersDTO orderPageSelected = listIndexSet.get(0);
					orderPageSelected
							.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
					indexSet = indexSet * PAGE_ITEMS_COUNT;
					nextListPages = prevListPages;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("indexSet", indexSet);
					session.setAttribute("listIndexSet", listIndexSet);
					session.setAttribute("orderPageSelected", orderPageSelected);
				}
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			hashProvinces = (Hashtable<String, ProvinceDTO>) session
					.getAttribute("hashProvinces");
			if (hashProvinces == null) {
				listProvinces = productService.getAllProvinces();
				Hashtable<String, ProvinceDTO> hashProvinces = new Hashtable<String, ProvinceDTO>();
				for (ProvinceDTO prov : listProvinces) {
					hashProvinces.put(prov.getCode(), prov);
				}
				session.setAttribute("hashProvinces", hashProvinces);
			}
			if (code != null && !code.equals("") && listOrdersDTO != null) {
				ProvinceDTO provinceDTO = hashProvinces.get(code);
				if (provinceDTO != null) {
					clientProvince = provinceDTO.getCode();
				}
			}// else listCities=new ArrayList<CityDTO>();
			if (listOrdersDTO != null && indexOrder != -1) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit != null) {
					orderToEdit.setClientProvince(code);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				}
			}

			/*------------------------------- Refresh listOrdersDTO------------------------------------
						Refresh listOrders before generation of invoiced orders XLS file 
				 ------------------------------------------------------------------------------------------*/
			invoicedOrdersRefresh = (Long) session
					.getAttribute("invoicedOrdersRefresh");
			if (invoicedOrdersRefresh != null && invoicedOrdersRefresh != 0L) {
				listIndexColumn = (ArrayList<Integer>) session
						.getAttribute("listIndexColumn");
				if (listIndexColumn == null)
					listIndexColumn = getNewListIndexColumn();
				lsOrderId = lsOrderId.toUpperCase();
				
				//Old Searching Functionality				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween,orderDTOObj,listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				//New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				indexSet = 0;
				session.setAttribute("indexSet", indexSet);
				nextListPages = 0;
				session.setAttribute("nextListPages", nextListPages);
				session.setAttribute("selectedStatus", selectedStatus);
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("invoicedOrdersRefresh", 0L);
				return SUCCESS;
			}

			/*------------ When Admin click on the Button "Delete Order" in The OrderDtailPop --------------
								show other pop to confirm Order Delete
			  ----------------------------------------------------------------------------------------------*/
			if (deleteOrderSignal != null && deleteOrderSignal != 0L) {
				message = "Attention! if you click on \"Delete Order\" you can not restore it.";
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (confirmDeleteSignal != null && confirmDeleteSignal == 0L) { // Delete
																				// Order
																				// Request
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "display:block;visibility:visible;";
				} else if (confirmDeleteSignal == 1L) { // Delete Order
														// Confirmed
					orderService.deleteOrderByLsOrderId(orderToEdit);
					// Save this operation in table operation
					OperationsDTO operationDTO = new OperationsDTO();
					User userAdmin = (User) session.getAttribute("userAdmin");
					if (userAdmin != null)
						operationDTO.setUserId(userAdmin.getId());
					operationDTO.setOperationDate(new Date());
					operationDTO.setOperationType("Delete Order");
					String dataBefore = "[PARTNER NAME:"
							+ orderToEdit.getUserLogin() + "];";
					dataBefore += " [LS_ORDER_ID:" + orderToEdit.getLsOrderId()
							+ "];";
					dataBefore += " [PRODUCT_ORDER_NUMBER:"
							+ orderToEdit.getProductOrderNumber() + "];";
					dataBefore += " [CLIENT_FIRST_NAME:"
							+ orderToEdit.getClientFirstName() + "];";
					dataBefore += " [CLIENT_LAST_NAME:"
							+ orderToEdit.getClientLastName() + "];";
					dataBefore += " [CLIENT_POSTAL_CODE:"
							+ orderToEdit.getClientPostalCode() + "];";
					dataBefore += " [LS_PRODUCT_ID:"
							+ orderToEdit.getLsProductID() + "];";
					dataBefore += " [UNIT_PRICE:" + orderToEdit.getUnitPrice()
							+ "];";
					dataBefore += " [STATUS:" + orderToEdit.getStatus() + "];";
					operationDTO.setDataBefore(dataBefore);
					operationDTO.setDataBefore(operationDTO.getDataBefore());
					operationDTO.setDataAfter("");
					operationsService.insertOperation(operationDTO);
					// Remove order from the list orders
					listOrdersDTO.remove(orderToEdit);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					showOrderDetailPop = "visibility:hidden;display:none;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
					// initialize index orders
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				} else { // Cancel Order Delete
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
				}
				return SUCCESS;
			}

			/*------ When Admin click the "Edit link" in the Order Table for Edit NOTE -----
							show only field Edit Note
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showOnlyEditNote != null && showOnlyEditNote != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowOnlyEditNote(0L);
					order.setCssRow("");
				}
				orderToEdit.setShowOnlyEditNote(1L);
				orderToEdit.setCssRow("background-color:#FF9966;");
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (ArrayList<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save Edit Note in the Orders Table" ----------
													save Only  notes
			  -------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOnlyNoteSignal != null && saveOnlyNoteSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						orderToEdit.setNotes(notes);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						orderToEdit.setCssRow("");
						// Save Note
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click the "Edit link" in the Order Table -------------
								show fields to edit shipping parameters
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showRowShipping != null && showRowShipping != 0L) {

				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowRowShipping(0L);
					order.setCssRow("");
				}
				// only Admins who has Active = true of action name='All' can
				// change shipping settings
				// of orders shipped or invoiced
				if (usersPrivChangeShippedStatus == null
						&& orderToEdit.getStatus() != null
						&& (orderToEdit.getStatus().equals("shipped") || orderToEdit
								.getStatus().equals("invoiced"))) {
					showRowShipping = 0L;
					return SUCCESS;
				}

				if (orderToEdit != null) {
					orderToEdit.setShowRowShipping(1L);
					orderToEdit.setShowOnlyEditNote(1L);
					orderToEdit.setCssRow("background-color:#FF9966;");
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (ArrayList<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				if (orderToEdit.getStatus().equals("open")) {
					statusId = 0L;
				} else if (orderToEdit.getStatus().equals("progress")) {
					statusId = 1L;
				} else if (orderToEdit.getStatus().equals("shipped")) {
					statusId = 2L;
				} else if (orderToEdit.getStatus().equals("invoiced")) {
					statusId = 3L;
				} else if (orderToEdit.getStatus().equals("canceled")) {
					statusId = 4L;
				}
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save in the Orders Table" ----------
							save all shipping parameters and notes
			 ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveShippingSignal != null && saveShippingSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						Date shippedDateToEdit = null;
						frm = new SimpleDateFormat("dd/MM/yyyy");
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))) {
							strShippedDate = strShippedDate.replaceAll(" ", "");
							try {
								Date date = frm.parse(strShippedDate);
								shippedDateToEdit = date;
							} catch (Exception pe) {
								shippedDateToEdit = null;
							}
						}
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))
								&& strShippedDate.length() <= 8)
							shippedDateToEdit = orderToEdit.getShippedDate();
						Double shippingPrice = null;
						// Double currencyShippingPrice=null;
						if (strShippingPrice != null
								&& !strShippingPrice.equals("")) {
							strShippingPrice = strShippingPrice.replaceAll(" ",
									"");
							int index = strShippingPrice.indexOf(",");
							if (index >= 0) {
								String strUnitPrice1 = strShippingPrice
										.substring(0, index);
								String strUnitPrice2 = strShippingPrice
										.substring(index + 1,
												strShippingPrice.length());
								strShippingPrice = strUnitPrice1 + "."
										+ strUnitPrice2;
							}

							try {
								shippingPrice = Double
										.parseDouble(strShippingPrice);
								/*
								 * if(shippingPrice!=null &&
								 * orderToEdit.getCurrencyId()!=null &&
								 * orderToEdit.getCurrencyId()!=1 &&
								 * orderToEdit.getCurrencyRate()!=null) {
								 * currencyShippingPrice = shippingPrice *
								 * orderToEdit.getCurrencyRate();
								 * currencyShippingPrice = (double)
								 * Math.round(currencyShippingPrice*100)/100; }
								 */
							} catch (Exception pe) {
								shippingPrice = null;
							}
						}

						if (trakingNumber != null)
							trakingNumber = trakingNumber.replaceAll(
									"^ +| +$|( )+", "$1");
						if (shippingCompany != null)
							shippingCompany = shippingCompany.replaceAll(
									"^ +| +$|( )+", "$1");
						orderToEdit.setShippingPrice(shippingPrice);
						// orderToEdit.setCurrencyShippingPrice(currencyShippingPrice);
						// orderToEdit.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
						orderToEdit.setShippedDate(shippedDateToEdit);
						orderToEdit.setNotes(notes);
						if (newStatus != null && !newStatus.equals(""))
							orderToEdit.setStatus(newStatus);
						orderToEdit.setShippingCompany(shippingCompany);
						orderToEdit.setTrackingNumber(trakingNumber);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						OrdersRows row = orderToEdit.getRowsList().get(0);
						row.setShippingPrice(shippingPrice);
						row.setShippingCompany(shippingCompany);
						row.setTrackingNumber(trakingNumber);
						orderToEdit.setCssRow("");

						if (newStatus != null && !newStatus.equals("")) { // if
																			// admin
																			// click
																			// on
																			// the
																			// save
																			// behind
																			// status
							orderService.updateStatusByLsOrderId(
									orderToEdit.getLsOrderId(), newStatus);
							orderToEdit.setStatus(newStatus);
							if (!newStatus.equals("shipped")
									&& !newStatus.equals("invoiced")
									&& !newStatus.equals("canceled")) {
								orderToEdit.setShippingPrice(null);
								orderToEdit.setTrackingNumber(null);
								orderToEdit.setShippedDate(null);
							}

						} else {// if admin click on the save other than Status
							if (orderToEdit.getShippedDate() != null
									&& orderToEdit.getTrackingNumber() != null
									&& !orderToEdit.getTrackingNumber().equals(
											"")
									&& orderToEdit.getShippingCompany() != null
									&& !orderToEdit.getShippingCompany()
											.equals("")
									&& orderToEdit.getShippingPrice() != null
									&& orderToEdit.getStatus() != null) {
								if (orderToEdit.getStatus().equals("open")
										|| orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"shipped");
									orderToEdit.setStatus("shipped");
								}
							} else {
								if (usersPrivChangeShippedStatus != null
										&& !orderToEdit.getStatus().equals(
												"open")
										&& !orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"progress");
									orderToEdit.setStatus("progress");
								}
							}
						}
						// if admin click on the save other then status(save
						// notes, save shipping company ...)
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click on icon findOrders.png ----------
								check user and complete infos client
			 ----------------------------------------------------------------*/
			if (findOrdersSignal != null
					&& findOrdersSignal != 0L
					|| (pageIndexSignal != null && pageIndexSignal != 0L)
					|| (nextListPagesSignal != null && nextListPagesSignal != 0L)
					|| (prevListPagesSignal != null && prevListPagesSignal != 0L)) {
				// session.setAttribute("allOrdersSelectedSignal",0L);
				// if admin click on search icon initialize checkBoxItem to
				// false
				if (findOrdersSignal != null && findOrdersSignal != 0L) {
					session.setAttribute("allOrdersSelectedSignal", 0L);
					checkBoxItem = false;
					session.setAttribute("checkBoxItem", checkBoxItem);
					indexSet = 0;
					session.setAttribute("indexSet", indexSet);
					nextListPages = 0;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("selectedStatus", selectedStatus);

				}
				// if admin navigate on pages keep the previous sorting
				if (((pageIndexSignal != null && pageIndexSignal != 0L)
						|| (nextListPagesSignal != null && nextListPagesSignal != 0L) || (prevListPagesSignal != null && prevListPagesSignal != 0L))) {
					listIndexColumn = (ArrayList<Integer>) session
							.getAttribute("listIndexColumn");
					if (listIndexColumn == null)
						listIndexColumn = getNewListIndexColumn();
				} else { // prepare new sorting
					listIndexColumn = getNewListIndexColumn();
				}

				lsOrderId = lsOrderId.toUpperCase();
				// if(findOrdersSignal!=null &&
				// findOrdersSignal!=0L)initalizeListIndexSet(session,orderService
				// );
				
				
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
//				//New Searching Functionality
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, orderDTOObj, listIndexColumn,
//						PAGE_ITEMS_COUNT, indexSet);
				
				
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);

				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("sizeResult", sizeResult);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				return SUCCESS;
			}

			/*------------ When Admin click on the icon sorting of column ----------
							seach result with option of sorting list
			 -----------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& sortingOrdersSignal != null && sortingOrdersSignal != 0L) {
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				asc = (asc == 1 ? -1 : 1);
				int nextElement = listIndexColumn.get(0);
				fieldForSorting = asc * fieldForSorting;
				listIndexColumn.set(0, fieldForSorting);
				for (int i = 1; i < listIndexColumn.size(); i++) {
					int element = listIndexColumn.get(i);
					listIndexColumn.set(i, nextElement);
					nextElement = element;
				}
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				// New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, orderDTOObj, listIndexColumn,
						PAGE_ITEMS_COUNT, indexSet);
				
				int balance = 0;
				int OrderIndex = 0;
				for (OrdersDTO orDTO : listOrdersDTO) {
					balance = (balance == 1 ? 0 : 1);
					if (balance == 1) {
						orDTO.setCssStyle("background-color: rgb(245,249,252);border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					} else {
						orDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					}
					orDTO.setIndex(OrderIndex);
					OrderIndex++;
				}
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("asc", asc);
				return SUCCESS;
			}

			/*------ when Admin click on the lsOrder link in table -----------
					show popup detail and allow admin to update Order
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& editOrderSignal != null && editOrderSignal != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit == null)
					orderToEdit = new OrdersDTO();
				if (orderToEdit.getProductOrderDate() == null)
					strProductOrderDate = "";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*--- when Admin click on the cancel Button of orderDetailPop ---
					we mast just hide popup OrderDetail
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& cancelSignal != null && cancelSignal != 0L) {
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}

			/*-------------------- When Admin left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& checkProductPriceSignal != null
					&& checkProductPriceSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToUpadate = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				UserProductPriceDTO userProductPrice = productService
						.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if (userProductPrice == null) {
					orderRowToUpadate.setCss("background-color:red;");
					orderRowToUpadate.setProductDescription("");
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				} else {
					Double usrPrice = orderRowToUpadate.getUnitPrice();
					if (usrPrice == null)
						usrPrice = 0D;
					if (usrPrice < userProductPrice.getPriceNum()) {
						orderRowToUpadate.setCssPrice("background-color:red;");
					}
					orderRowToUpadate.setProductDescription(userProductPrice
							.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice
							.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice
							.getLsProductId());
					orderRowToUpadate
							.setLsPrice(userProductPrice.getPriceNum());
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = orderDTOToUpdate;
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*----------------- When Admin check on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveTemporaryRowSignal != null
					&& saveTemporaryRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToSaveMemory = orderDTOToUpdate
						.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if (orderRowToSaveMemory != null) {
					orderRowToSaveMemory.setQuantity(quantity);
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory
							.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory
							.setCssPrice("background-color:#FF6666;");
					orderRowToSaveMemory
							.setCssQuantity("background-color:#FF6666;");
					if (quantity != null && quantity > 0D)
						orderRowToSaveMemory.setCssQuantity("");
					if (unitPrice != null
							&& orderRowToSaveMemory.getLsPrice() != null
							&& unitPrice >= orderRowToSaveMemory.getLsPrice())
						orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trakingNumber);
					if (orderRowToSaveMemory.getCurrencyId() != null
							&& orderRowToSaveMemory.getCurrencyId() != 1
							&& orderRowToSaveMemory.getCurrencyRate() != null) {
						if (unitPrice != null) {
							orderRowToSaveMemory
									.setCurrencyUnitPrice(unitPrice);
							unitPrice = unitPrice
									/ orderRowToSaveMemory.getCurrencyRate();
							unitPrice = (double) Math.round(unitPrice * 100) / 100;
							orderRowToSaveMemory.setUnitPrice(unitPrice);
						}
						/*
						 * if(shippingFee!=null) {
						 * orderRowToSaveMemory.setCurrencyShippingPrice
						 * (shippingFee); shippingFee =
						 * shippingFee/orderRowToSaveMemory.getCurrencyRate();
						 * shippingFee = (double)
						 * Math.round(shippingFee*100)/100;
						 * orderRowToSaveMemory.setShippingPrice(shippingFee); }
						 */
					}
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				// Change totalPrice also
				if (orderToEdit.getRowsList().get(0) != null
						&& orderToEdit.getRowsList().get(0).getQuantity() != null
						&& orderToEdit.getRowsList().get(0)
								.getQuantityToSplit() != null
						&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
					Double priceTotal = orderToEdit.getRowsList().get(0)
							.getUnitPrice()
							* orderToEdit.getRowsList().get(0)
									.getQuantityToSplit();
					priceTotal = (double) Math.round(priceTotal * 100) / 100;
					orderToEdit.setTotalPrice(priceTotal);
				}
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------- When Admin click on addSimilarRow Icon on the OrderDetailPop --------
								Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& addSimilarRowSignal != null && addSimilarRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				// generate lsOrderId to new order
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				if (orderRowToClone != null) {
					if (!orderRowToClone.getIcon().equals(
							"images/orders/itemValidated.png")) {
						orderRowToClone.setQuantity(quantity);
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone
								.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trakingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd = DTOFactory
							.getOrderRowClone(orderRowToClone);
					orderRowToAdd.setId(-1L);
					// Add currencyId
					if (orderRowToClone.getCurrencyId() != null)
						orderRowToAdd.setCurrencyId(orderRowToClone
								.getCurrencyId());

					orderDTOToUpdate.getRowsList().add(indexRow + 1,
							orderRowToAdd);
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------- When Admin click on Delete Row Icon of orderDetail Popup-----------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& deleteRowSignal != null && deleteRowSignal != 0L) {
				OrdersDTO orderDTO = listOrdersDTO.get(indexOrder);
				orderDTO = fillDataOrderDTO(orderDTO);
				int nb = orderService.nbOrderRowsNotDeleted(orderDTO
						.getRowsList());
				if (orderDTO != null && orderDTO.getRowsList().size() > 1) {
					for (int i = 0; i < orderDTO.getRowsList().size(); i++) {
						if (i == indexRow && nb > 1) {
							orderDTO.getRowsList().get(i).setToDelete(1);
							break;
						}
					}
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ when Admin click on the button save of orderDetail ------------------
					 save order and hide pup  
			  ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOrdersSignal != null && saveOrdersSignal != 0L) {
				session.setAttribute("orderNotSavedAtFirst", null);
				orderToEdit = listOrdersDTO.get(indexOrder);
				orderToEdit = fillDataOrderDTO(orderToEdit);

				// add special handling shipping
				User user = null;
				if (orderToEdit.getUserLogin() != null)
					user = userService.getUserByLogin(orderToEdit
							.getUserLogin());
				if (user != null) {
					Double totalPrice = null;
					orderToEdit.setSpecialHandlingName(user
							.getSpecialHandlingName());
					orderToEdit.setSpecialHandlingFee(user
							.getSpecialHandlingFee());
					if (orderToEdit.getRowsList().get(0).getQuantity() != null
							&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
						totalPrice = orderToEdit.getRowsList().get(0)
								.getQuantity()
								* orderToEdit.getRowsList().get(0)
										.getUnitPrice();
						totalPrice = (double) Math.round(totalPrice * 100) / 100;
					}

					orderToEdit.setTotalPrice(totalPrice);
				}

				orderService.updateOrderByLsOrderId(orderToEdit);
				for (OrdersRows row : orderToEdit.getRowsList()) {
					if (row.getId() == -1)
						row.setId(0L);
				}
				OrdersRows row = orderToEdit.getRowsList().get(0);
				if (row != null) {
					orderToEdit.getShippedDate();
					orderToEdit.setLsPrice(row.getLsPrice());
					orderToEdit.setLsProductID(row.getLsProductID());
					orderToEdit.setProductDescription(row
							.getProductDescription());
					orderToEdit.setQuantity(row.getQuantity());
				}
				orderToEdit = DTOFactory.getOrderDTOConsideredMissingInfo(
						orderToEdit, hashProvinces);
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				// New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, orderDTOObj, listIndexColumn,
						PAGE_ITEMS_COUNT, indexSet);
				
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				message = "Saving has completed successfuly";
				showSaveSuccessPop = "display:block;visibility:visible;";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ When user change Quantity to split in orderDetailPop -----------
					 prepare order to split from two other orders witch
				 	 one must have a lsOrder with underscore 
			 ------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& quantityToChangeSignal != null
					&& quantityToChangeSignal != 0L) {
				OrdersDTO orderToChangeQt = listOrdersDTO.get(indexOrder);
				OrdersRows orderRow = orderToChangeQt.getRowsList().get(
						indexRow);
				orderToChangeQt = fillDataOrderDTO(orderToChangeQt);
				if (quantityToChange < orderRow.getQuantity())
					orderRow.setQuantityToSplit(quantityToChange);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- Duplicate Order ----------------------------------------
							Create order in just in memory
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& duplicateOrderSignal != null
					&& duplicateOrderSignal != 0L) {
				OrdersDTO orderToClone = listOrdersDTO.get(indexOrder);
				orderToClone = fillDataOrderDTO(orderToClone);
				hashOrders = new Hashtable<String, OrdersDTO>();
				for (OrdersDTO ord : listOrdersDTO) {
					hashOrders.put(ord.getLsOrderId(), ord);
				}
				OrdersDTO orderClone = DTOFactory
						.getOrderDTOSplitted(orderToClone);
				if (orderClone != null) {
					orderClone.setDuplicate(true);
					String lsOrder = orderClone.getLsOrderId();
					String strlsOrder = orderService.generateLsOrderId(lsOrder,
							hashOrders);
					orderClone.setLsOrderId(strlsOrder);// rgb(116,180,209)
					orderClone
							.setCssStyle("background-color:#FFFF99;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					orderToEdit = orderClone;
					orderToEdit.setBackgroundColor("background-color:#FFFF99;");
					listOrdersDTO.add(indexOrder + 1, orderClone);
					indexOrder = 0;
					for (OrdersDTO ord : listOrdersDTO) {
						ord.setIndex(indexOrder);
						indexOrder++;
					}
					orderService.updateOrderByLsOrderId(orderToClone);
					orderService.insertOrderWithRows(orderClone);
					orderClone.setDuplicate(false);
					for (OrdersRows row : orderClone.getRowsList()) {
						if (row.getId() < 0L)
							row.setId(0L);
					}
					if (listOrdersDTO.size() > 0) {
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				} else
					orderToEdit = orderToClone;
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& okSaveSuccessPopSignal != null
					&& okSaveSuccessPopSignal != 0L) {
				showSaveSuccessPop = "visibility:hidden;display:none;";
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}

	/*
	 * ==========================================================================
	 * =============== fill all fields of order without rows
	 * ====================
	 * =====================================================================
	 */
	public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO) {
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		orderDTO.setClientLastName(clientLastName);
		orderDTO.setClientFirstName(clientFirstName);
		orderDTO.setClientOtherNames(clientOtherNames);
		orderDTO.setClientStreet(clientStreet);
		orderDTO.setClientOtherStreet(clientOtherStreet);
		orderDTO.setClientCity(clientCity);
		orderDTO.setClientProvince(code);
		orderDTO.setClientPostalCode(clientPostalCode);
		orderDTO.setClientPhone(clientPhone);
		orderDTO.setClientEmail(clientEmail);
		orderDTO.setProductOrderNumber(productOrderNumberSearch);
		orderDTO.setCompanyHeader(companyHeader);
		if (((strProductOrderDate) != null)
				&& (!"".equals(strProductOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strProductOrderDate);
				orderDTO.setProductOrderDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strCreationOrderDate) != null)
				&& (!"".equals(strCreationOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strCreationOrderDate);
				orderDTO.setCreationDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strRequiredDate) != null) && (!"".equals(strRequiredDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strRequiredDate);
				orderDTO.setRequiredDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}
		return orderDTO;
	}

	/*
	 * ==========================================================================
	 * =============== initialize ListIndexSet
	 * ==================================
	 * =======================================================
	 */
	public void initalizeListIndexSet(HttpSession session,
			OrdersService orderService) throws ServiceException {
		listIndexSet = new ArrayList<OrdersDTO>();
		totalOrders = orderService.getCountOrders(creationDateStartArg,
				creationDateEndArg, reportDateBetween, userLogin, lsOrderId,
				status);
		String strcount = totalOrders.toString();
		Integer sizeList = Integer.parseInt(strcount) / PAGE_ITEMS_COUNT;
		nextListPages = 1;
		session.setAttribute("nextListPages", nextListPages);
		for (int i = 1; i <= sizeList + 1 && i <= 11; i++) {
			OrdersDTO ord = new OrdersDTO();
			ord.setCssStyle("");
			ord.setIndex(i);
			listIndexSet.add(ord);
		}
		indexSet = 0;
		session.setAttribute("indexSet", indexSet);
		session.setAttribute("totalOrders", totalOrders);
		session.setAttribute("listIndexSet", listIndexSet);

	}

	/*
	 * ==========================================================================
	 * =============== initialize listIndexColumn
	 * ================================
	 * =========================================================
	 */
	List<Integer> getNewListIndexColumn() {
		List<Integer> reult = new ArrayList<Integer>();
		for (int i = 0; i <= 34; i++) {
			if (i != 2 && i <= 13) {
				reult.add(i);
				if (i != 0)
					reult.add(-i);
			}
			if (i == 30 || i == 31 || i == 34) {
				reult.add(i);
				reult.add(-i);
			}
		}
		return reult;
	}

	/*
	 * ==========================================================================
	 * =============== getStatus Selected by Admin for searching
	 * ================
	 * =========================================================================
	 */
	public String getStatusSelected(Integer StatusIndex) {
		String result = "";
		switch (StatusIndex) {
		case 0:
			result = "open";
			break;
		case 1:
			result = "progress";
			break;
		case 2:
			result = "shipped";
			break;
		case 3:
			result = "invoiced";
			break;
		case 4:
			result = "canceled";
			break;
		default:
			result = "";
		}
		return result;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:14.157
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 16 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:14.157
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:14.157
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:14.158
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 16 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:14.158
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.core.resources 4 2 2015-04-01 09:56:14.409
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:759)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)
	at java.lang.Thread.run(Thread.java:722)

!ENTRY org.eclipse.core.resources 4 75 2015-04-01 09:56:14.693
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2015-04-01 09:56:14.693
!MESSAGE Errors running builder 'Java Builder' on project 'loyaltySource_lib'.
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:759)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)
	at java.lang.Thread.run(Thread.java:722)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:56:15.636
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.model;

import java.util.ArrayList;
import java.util.Date;

import lombok.Data;
import lombok.ToString;

@Data @ToString(callSuper=true) 
public class Orders  extends AbstractEntity{
	private Boolean toUpdate;
	private Boolean duplicate=false;
	private Boolean manOrder=false; 
	private Long    toInsert=0L;
	private Long    count;
	private Long    clientProfileId;
	private Long    userId;
	private String  userLogin;
	private String  lsOrderId;
	private String  providedLsProductId; //ls_product_id provided by client
	private String  productOrderNumber;
	private String  clientOrderNumber;
	private String  clientProductNumber;
	private String  clientFirstName;
	private String  clientLastName;
	private String  clientOtherNames;
	private String  clientNumber;
	private String  clientOtherId;
	private String  clientStreet;
	private String  clientOtherStreet;
	private String  clientCity; 
	private String  clientProvince;
	private String  clientPostalCode; 
	private String  clientPhone; 
	private String  clientEmail; 
	private String  orderFileInfo; //for Rideau changed form orderFileName
	private Date    creationDate;
	private Date    productOrderDate;
	private Date    requiredDate;
	private Date    invoicedDate;
	
	//Special Handling
	private String specialHandlingName;
	private Double specialHandlingFee;
	private Double totalPrice;
	
	private String  notes;
	private String  cstProductNumber;
	private Double  unitPrice;
	private String  shippingCompany;
	private String 	companyHeader;
	private Date    shippedDate;
	private String  trackingNumber;
	private Double  shippingPrice;
	private Double  shippingFee;
	private String  billed;
	private Double  quantity;
	private Double  quantityOriginal; 
	private Long    productId;
	private String  status;
	private String  productDescription;
	private Double  stock;
	private String  lsProductID;
	private Double  lsPrice;
	private Long    orderId;
	
	//Currency
	private Long	currencyId;
	private String	currencySymbol;
	private Double	currencyRate;
	private Double 	currencyPrice;
	private Double 	currencyUnitPrice;
	private Double 	currencyTotalPrice;
	private Double 	currencyShippingPrice;
	
	//shipping_insurance_multiplier
	private Double shippingInsuranceMultiplier;
	
	private ArrayList<OrdersRows> rowsList=new ArrayList<OrdersRows>();
	
	//ETA
	private String etaFieldName;
	private String etaFieldValue;
	
	private String secondEtaFieldName;  
	private String secondEtaFieldValue;
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:56:15.637
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:15.637
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:15.637
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:56:15.647
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:56:15.647
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:69)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:131)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:203)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:199)
	at org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:233)
	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:637)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:409)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:57:28.686
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.service.core.dto;

import java.util.ArrayList;
import java.util.Date;

import com.loyauty.model.OrdersRows;

import lombok.Data;
import lombok.ToString;

@Data @ToString(callSuper=true) 
public class OrdersDTO extends  BasicDTO{
	private static final long serialVersionUID = -4362825927629396152L;
	private String 	cssRow="";
	private Long 	showRowShipping=0L;
	private Long 	showOnlyEditNote=0L;
	private Long 	count;
	private Boolean toUpdate=false;
	private Boolean manOrder=false;
	private Boolean duplicate=false;
	private Long 	infoMissing=0L;
	private Long 	saved=0L;
	private Boolean print;
	private String 	cssPrice;
	private String 	cssStyle;
	private String 	backgroundColor="";
	private Integer index=0;
	private Long   	clientProfileId;
	private Long  	userId;
	private String 	userLogin;
	private String 	lsOrderId;
	private String 	companyHeader;
	private String 	productOrderNumber;//poNumber
	private String	 clientOrderNumber;
	private Date 	productOrderDate; //poDate
	private Date 	requiredDate;
	private String	clientNumber;//clientNumber
	private String  clientOtherId;
	private String 	clientProductNumber;// code product given 
	private String 	clientFirstName;//clientFirstName 
	private String 	clientLastName; //clientLastName
	private String 	clientOtherNames;
	private String 	clientStreet; //clientAdress
	private String 	clientOtherStreet;//clientAdressOther
	private String 	clientCity;//clientCity
	private Double  quantityOriginal; // we use this variable to calculate quantities of products duplicated
	private String 	clientPostalCode;//clientPostalCode
	private String 	clientProvince;//clientProvince	
	private Long 	provinceNotFound;//clientProvince	
	private String 	clientPhone;//clientPhone
	private String 	clientEmail;//clientEmail	
	//private String  orderFileName;
	private String  orderFileInfo; //for rideau
	private Date 	creationDate;
	private Date    invoicedDate;
	//Special Handling
	private String specialHandlingName;
	private Double specialHandlingFee;
	private Double totalPrice;

	private ArrayList<OrdersRows> rowsList=new ArrayList<OrdersRows>();

	//rows info
	private String 	notes;
	private String 	cstProductNumber;
	private Double 	unitPrice;
	private String 	shippingCompany;
	private Date 	shippedDate;
	private String 	trackingNumber;
	private Double 	shippingPrice;
	private Double 	shippingFee;
	private String 	billed;
	private Double 	quantity;
	private Long 	productId;
	private String 	status;
	private String 	productDescription;
	private Double 	stock;
	private String 	lsProductID;
	private String  providedLsProductId; //ls_product_id provided by client
	private Double 	lsPrice;
	private Long 	orderId;
	
	//Currency
	private Long	currencyId;
	private String	currencySymbol;
	private Double	currencyRate;
	private Double 	currencyPrice;
	private Double 	currencyUnitPrice;
	private Double 	currencyTotalPrice;
	private Double 	currencyShippingPrice;
	
	//shipping_insurance_multiplier
	private Double shippingInsuranceMultiplier;
	
	private String notation="nothing";
	
	//ETA  secondEtaFieldName  secondEtaFieldValue
	private String etaFieldName;
	private String etaFieldValue;
	
	private String secondEtaFieldName;
	private String secondEtaFieldValue;
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:57:28.687
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:28.687
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:28.687
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:57:28.688
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:28.689
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.core.resources 4 2 2015-04-01 09:57:32.170
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.core.resources 4 75 2015-04-01 09:57:32.566
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2015-04-01 09:57:32.566
!MESSAGE Errors running builder 'Java Builder' on project 'loyaltySource_admin'.
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:57:33.405
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpSession;

import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.web.struts.action.LoyautyAction;
import com.sun.xml.internal.ws.api.ha.StickyFeature;

public class GetOrdersByPOSumit extends LoyautyAction {
	private static final long serialVersionUID = 2352657794009174955L;

	private static OrdersService orderService;
	
	@Getter @Setter
	private Integer sumit;
	
	
	@Getter @Setter
	private List<OrdersDTO> ordersListSumit;
	
	@Getter @Setter
	private OrdersDTO ordersDTO;
	@Getter @Setter
	private String productOrderNumber;
	
	public  GetOrdersByPOSumit() throws ServiceLocatorException {
		super();	
		orderService = getServiceLocator().getOrderService();
		ordersListSumit=new ArrayList<OrdersDTO>();
		ordersDTO=new OrdersDTO();

	}
	/*=========================================================================================
											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		
		System.out.println("I am at GetOrdersByPOSumit Action:Execute Method");

		try {
			ordersDTO.setProductOrderNumber(productOrderNumber);
			ordersListSumit=orderService.getOrdersByProductOrderNumberSumit(ordersDTO);
//			ordersListSumit = orderService.getAllOrders();
			HttpSession session = request.getSession(true);

		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}


}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:57:33.406
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:33.406
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:33.406
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:57:33.407
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:33.407
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:98)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:57:33.409
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class GoToOrders extends LoyautyAction {
	private static final long serialVersionUID = 2352657794009174955L;

	private UserService userService;
	private static ProductService productService;
	private static OrdersService orderService;
	private Date today;
	@Getter @Setter
	private List<OrdersDTO>listOrdersDTO;
	@Getter @Setter
	private List<User> usersList;
	@Getter @Setter
	private Long init;
	@Getter @Setter
	private Date creationDate ;
	@Getter @Setter
	private Date creationDateStart ;
	@Getter @Setter
	List<ProvinceDTO>listProvinces;
	@Getter @Setter
	private Integer reportDateBetween;
	@Getter @Setter
	private Integer invoicingDateBetween;
	@Getter @Setter 
	private String  code;

	private static int USER_TYPE = 2;

	public  GoToOrders() throws ServiceLocatorException {
		super();	
		userService = getServiceLocator().getUserService();
		productService = getServiceLocator().getProductService();
		orderService = getServiceLocator().getOrderService();
		today=new Date();
		usersList=new ArrayList<User>();
		listOrdersDTO=new ArrayList<OrdersDTO>();
	}
	/*=========================================================================================
											method execute
	  =========================================================================================*/
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		
		System.out.println("I am at Handeling Page");

		try {
			HttpSession session = request.getSession(true);
			listProvinces=productService.getAllProvinces();
			session.setAttribute("reportDateBetween",0);
			session.setAttribute("invoicingDateBetween",0);
			session.setAttribute("indexSet",0);  
			session.setAttribute("nextListPages",0);
			session.setAttribute("checkBoxItem",false);
			session.setAttribute("invoicedOrdersRefresh",0L);
			new ReportOrders().initalizeListIndexSet(session, orderService);
			session.setAttribute("totalInvoicedOrders",0L);
			session.setAttribute("totalOrders",0L);
			Hashtable<String, ProvinceDTO> hashProvinces=new Hashtable<String, ProvinceDTO>();
			for(ProvinceDTO prov:listProvinces){
				hashProvinces.put(prov.getCode(), prov);
			}
			session.setAttribute("hashProvinces",hashProvinces);
			//------------------ recovery users list ---------------------------
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession=(List<User>)session.getAttribute("usersListSession");
			if(usersListSession==null){
				List<UserSessionDTO> listAllUsers= userService.getAllUsers(basicUserDTO);
				for(UserSessionDTO userDTO:listAllUsers){
					User user=new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession",usersList);
			}else usersList=usersListSession;
			session.setAttribute("listOrdersDTOMan",null);
			session.setAttribute("listOrdersDTOAuto",null);
			if(init!=null && init!=0){
				int call=Integer.parseInt(init.toString());
				switch (call) {
				case 1:
					SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
					String lsOrderIdFirstPart="Man"+sdf.format(today);
					String manLsOrderId=orderService.generateManLsOrderId(lsOrderIdFirstPart);
					OrdersDTO orderDTO=new OrdersDTO();
					orderDTO.setLsOrderId(manLsOrderId);
					orderDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					OrdersRows orderRow=new OrdersRows();
					orderRow.setIcon("images/orders/itemNotValidated.png");
					orderDTO.getRowsList().add(orderRow);
					listOrdersDTO.add(orderDTO);
					session.setAttribute("listOrdersDTOMan",listOrdersDTO);
					break;
				case 2:
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}


}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-01 09:57:33.410
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:33.410
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:33.410
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-01 09:57:33.411
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	... 17 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-01 09:57:33.411
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.Argument.bind(Argument.java:35)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.bindArguments(AbstractMethodDeclaration.java:83)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:406)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1235)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:540)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:883)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:928)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:189)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:255)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:102)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-01 09:58:00.672
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.loyauty.web.struts.action.orders;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;

import javax.servlet.http.HttpSession;
import lombok.Getter;
import lombok.Setter;

import com.loyauty.exception.ServiceException;
import com.loyauty.exception.ServiceLocatorException;
import com.loyauty.model.OrdersRows;
import com.loyauty.model.User;
import com.loyauty.service.core.DTOFactory;
import com.loyauty.service.core.dto.BasicUserDTO;
import com.loyauty.service.core.dto.OperationsDTO;
import com.loyauty.service.core.dto.OrdersDTO;
import com.loyauty.service.core.dto.ProvinceDTO;
import com.loyauty.service.core.dto.UserProductPriceDTO;
import com.loyauty.service.core.dto.UserSessionDTO;
import com.loyauty.service.core.dto.UsersPrivilegesDTO;
import com.loyauty.service.operations.OperationsService;
import com.loyauty.service.orders.OrdersService;
import com.loyauty.service.product.ProductService;
import com.loyauty.service.user.UserService;
import com.loyauty.web.struts.action.LoyautyAction;

public class ReportOrders extends LoyautyAction {
	private static final long serialVersionUID = -3811760851445730062L;
	private UserService userService;
	private ProductService productService;
	private OrdersService orderService;
	private OperationsService operationsService;
	@Getter
	@Setter
	private String userLogin;
	@Getter
	@Setter
	private List<User> usersList;
	private static int USER_TYPE = 2;
	@Getter
	@Setter
	List<OrdersDTO> listOrdersDTO;
	@Getter
	@Setter
	List<OrdersDTO> listStatus;
	@Getter
	@Setter
	private String lsOrderId;
	@Getter
	@Setter
	Long poYpop;
	@Getter
	@Setter
	Long poXpop;
	@Getter
	@Setter
	private Long pageTop = 0L;
	@Getter
	@Setter
	private Date creationDate;
	@Getter
	@Setter
	private Long findOrdersSignal;
	private String status;
	@Getter
	@Setter
	private Long sizeResult = 0L;
	@Getter
	@Setter
	private Long sorting;
	@Getter
	@Setter
	private Long sortingOrdersSignal;
	@Getter
	@Setter
	private Integer fieldForSorting;
	@Getter
	@Setter
	private Integer asc;
	@Getter
	@Setter
	private Integer scrollDivRowsLeft;
	@Getter
	@Setter
	private Integer scrollPageLeft;
	@Getter
	@Setter
	private Integer scrollDivRowsTop;
	@Getter
	@Setter
	private String strCreationDateStart;
	@Getter
	@Setter
	private String strCreationDateEnd;
	@Getter
	@Setter
	private Date creationDateStart;
	@Getter
	@Setter
	private Date creationDateEnd;
	private Date creationDateStartArg;
	private Date creationDateEndArg;
	@Getter
	@Setter
	private Integer selectedStatus;
	@Getter
	@Setter
	private Long editOrderSignal;
	@Getter
	@Setter
	private Long cancelSignal;
	@Getter
	@Setter
	private Integer indexOrder;
	@Getter
	@Setter
	private OrdersDTO orderToEdit;
	@Getter
	@Setter
	private String strProductOrderDate;
	@Getter
	@Setter
	private String lsProductID;
	@Getter
	@Setter
	Integer indexRow;
	@Getter
	@Setter
	private String showOrderDetailPop;
	@Getter
	@Setter
	private Long userId;
	@Getter
	@Setter
	private Long checkProductPriceSignal;
	@Getter
	@Setter
	private Long saveTemporaryRowSignal;
	@Getter
	@Setter
	private Long addSimilarRowSignal;
	@Getter
	@Setter
	private Long deleteRowSignal;
	@Getter
	@Setter
	private Long saveOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxPrint;

	// recovery Data Order
	@Getter
	@Setter
	private String clientLastName;
	@Getter
	@Setter
	private String clientFirstName;
	@Getter
	@Setter
	private String clientOtherNames;
	@Getter
	@Setter
	private String clientStreet;
	@Getter
	@Setter
	private String clientOtherStreet;
	@Getter
	@Setter
	private String clientCity;
	@Getter
	@Setter
	private String clientProvince;
	@Getter
	@Setter
	private String clientPostalCode;
	@Getter
	@Setter
	private String clientPhone;
	@Getter
	@Setter
	private String clientEmail;
//	@Getter
//	@Setter
//	private String productOrderNumber;
	@Getter
	@Setter
	private String strRequiredDate;

	// recovery data row
	@Getter
	@Setter
	private Double quantity;
	@Getter
	@Setter
	private String notes;
	@Getter
	@Setter
	private Double quantityToChange;
	@Getter
	@Setter
	private Double stock;
	@Getter
	@Setter
	private String productDescription;
	@Getter
	@Setter
	private Double unitPrice;
	@Getter
	@Setter
	private Double shippingFee;
	@Getter
	@Setter
	private String shippingCompany;
	@Getter
	@Setter
	private String companyHeader;

	@Getter
	@Setter
	private Long quantityToChangeSignal;
	@Getter
	@Setter
	private Long duplicateOrderSignal;
	@Getter
	@Setter
	private String strCreationDate;
	@Getter
	@Setter
	private String strCreationOrderDate;
	@Getter
	@Setter
	private User usr;
	@Getter
	@Setter
	private String showSaveSuccessPop;
	// showSaveSuccessPop="display:block;visibility:visible;";
	// showSaveSuccessPop="visibility:hidden;display:none;";
	@Getter
	@Setter
	private String message;
	@Getter
	@Setter
	private Long okSaveSuccessPopSignal;
	@Getter
	@Setter
	private Long showRowShipping;
	@Getter
	@Setter
	private Long showOnlyEditNote;
	@Getter
	@Setter
	private Long saveShippingSignal;
	@Getter
	@Setter
	private Long saveOnlyNoteSignal;
	@Getter
	@Setter
	private String code;
	@Getter
	@Setter
	private Long cityId;
	@Getter
	@Setter
	private List<ProvinceDTO> listProvinces;
	private Hashtable<String, ProvinceDTO> hashProvinces;
	@Getter
	@Setter
	private Boolean orderNotSavedAtFirst;
	@Getter
	@Setter
	private String strShippedDate;
	@Getter
	@Setter
	private String strShippingPrice;
	@Getter
	@Setter
	private String showConfirmDeleteOrderPop;
	@Getter
	@Setter
	private Long deleteOrderSignal;
	@Getter
	@Setter
	private Long confirmDeleteSignal;
	@Getter
	@Setter
	private UsersPrivilegesDTO userPrivileges;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivShippedToInvoiced;
	@Getter
	@Setter
	private UsersPrivilegesDTO usersPrivChangeShippedStatus;
	@Getter
	@Setter
	private HashMap<Integer, String> hashStatus;
	@Getter
	@Setter
	private Long statusId;
	@Getter
	@Setter
	private String strPrint;
	@Getter
	@Setter
	private Integer testSignal;
	@Getter
	@Setter
	private String newStatus;
	Long invoicedOrdersRefresh;
	@Getter
	@Setter
	private Integer reportDateBetween;
	@Getter
	@Setter
	private Long dateBetweenSignal;
	@Getter
	@Setter
	private Long selectAllOrdersSignal;
	@Getter
	@Setter
	private Boolean checkBoxItem;
	// ------Pagination
	@Getter
	@Setter
	Long pageIndexSignal;
	@Getter
	@Setter
	Long prevListPagesSignal;
	@Getter
	@Setter
	Long nextListPagesSignal;
	@Getter
	@Setter
	Long totalOrders;
	@Getter
	@Setter
	Integer nextListPages;
	@Getter
	@Setter
	Integer prevListPages;
	@Getter
	@Setter
	Integer indexSet = 0;
	@Getter
	@Setter
	Integer indexList;
	@Getter
	@Setter
	List<OrdersDTO> listIndexSet;
	@Getter
	@Setter
	Integer PAGE_ITEMS_COUNT = 100;
	
	//New Added Field in the search option as toggle functionality
	@Getter
	@Setter
	private String productOrderNumberSearch;
	@Getter
	@Setter
	private String trakingNumber;
	@Getter
	@Setter
	private String  clientOther;
	@Getter
	@Setter
	private String	 clientOrderNumber;
	//New Added Field in the search option as toggle functionality

	// ------Pagination

	/*
	 * ==========================================================================
	 * =============== Default constructor
	 * ======================================
	 * ===================================================
	 */
	public ReportOrders() throws ServiceLocatorException {
		super();
		userService = getServiceLocator().getUserService();
		orderService = getServiceLocator().getOrderService();
		productService = getServiceLocator().getProductService();
		operationsService = getServiceLocator().getOperationsService();
	}

	/*
	 * ==========================================================================
	 * =============== method execute
	 * ============================================
	 * =============================================
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public String execute() throws Exception {
		System.out.println("Product Order Number: "+ productOrderNumberSearch);
		System.out.println("Tracking Number: "+ trakingNumber);
		System.out.println("Client Order ID: "+ clientOrderNumber);
		System.out.println("Client Other ID: "+ clientOther);
		
		//Create new object or Order to modify the search functinality
		OrdersDTO orderDTOObj=new OrdersDTO();
		orderDTOObj.setLsOrderId(lsOrderId);
		orderDTOObj.setUserLogin(userLogin);
		orderDTOObj.setStatus(status);
		orderDTOObj.setProductOrderNumber(productOrderNumberSearch);
		orderDTOObj.setClientOrderNumber(clientOrderNumber);
		orderDTOObj.setClientOtherId(clientOther);
		
		HttpSession session = request.getSession(true);

		if (showOrderDetailPop == null)
			showOrderDetailPop = "visibility:hidden;display:none;";
		if (showConfirmDeleteOrderPop == null)
			showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
		if (showSaveSuccessPop == null)
			showSaveSuccessPop = "visibility:hidden;display:none;";
		if (poYpop == null)
			poYpop = 100L;
		if (poXpop == null)
			poXpop = 100L;
		Hashtable<String, OrdersDTO> hashOrders;
		if (selectedStatus == null)
			selectedStatus = -1;
		sizeResult = (Long) session.getAttribute("sizeResult");
		totalOrders = (Long) session.getAttribute("totalOrders");
		if (totalOrders == null)
			totalOrders = 0L;
		asc = (Integer) session.getAttribute("asc");
		if (asc == null)
			asc = 0;
		if (sizeResult == null)
			sizeResult = 0L;
		if (indexOrder == null)
			indexOrder = 0;
		userPrivileges = (UsersPrivilegesDTO) session.getAttribute("userPrivileges");
		usersPrivShippedToInvoiced = (UsersPrivilegesDTO) session.getAttribute("usersPrivShippedToInvoiced");
		usersPrivChangeShippedStatus = (UsersPrivilegesDTO) session
				.getAttribute("usersPrivChangeShippedStatus");
		hashStatus = (HashMap<Integer, String>) session
				.getAttribute("hashStatus");
		if (hashStatus == null) {
			hashStatus = new HashMap<Integer, String>();
			hashStatus.put(0, "");
			hashStatus.put(1, "open");
			hashStatus.put(2, "progress");
		}
		List<Integer> listIndexColumn = new ArrayList<Integer>();
		// fill list status
		listStatus = (ArrayList<OrdersDTO>) session.getAttribute("listStatus");
		if (listStatus == null) {
			listStatus = new ArrayList<OrdersDTO>();
			OrdersDTO orderDTOOpen = new OrdersDTO();
			orderDTOOpen.setStatus("open");
			orderDTOOpen.setId(0L);
			listStatus.add(orderDTOOpen);
			OrdersDTO orderDTOProgress = new OrdersDTO();
			orderDTOProgress.setStatus("progress");
			orderDTOProgress.setId(1L);
			listStatus.add(orderDTOProgress);
			if (usersPrivChangeShippedStatus != null) {
				OrdersDTO orderDTOShipped = new OrdersDTO();
				orderDTOShipped.setStatus("shipped");
				orderDTOShipped.setId(2L);
				listStatus.add(orderDTOShipped);
			}

		}

		try {

			/*-------------------- recovery users list -----------------------------------
							Recovery users list in session
			 -----------------------------------------------------------------------------*/
			// recovery provinces
			listProvinces = (List<ProvinceDTO>) session
					.getAttribute("listProvinces");
			if (listProvinces == null)
				listProvinces = productService.getAllProvinces();
			orderNotSavedAtFirst = (Boolean) session
					.getAttribute("listNotSavedAtFirst");
			BasicUserDTO basicUserDTO = new BasicUserDTO();
			basicUserDTO.setTypeId(USER_TYPE);
			List<User> usersListSession = (List<User>) session
					.getAttribute("usersListSession");
			if (usersListSession == null) {
				List<UserSessionDTO> listAllUsers = userService
						.getAllUsers(basicUserDTO);
				usersList = new ArrayList<User>();
				for (UserSessionDTO userDTO : listAllUsers) {
					User user = new User();
					user.setId(userDTO.getId());
					user.setLogin(userDTO.getLogin());
					usersList.add(user);
				}
				session.setAttribute("usersListSession", usersList);
			} else
				usersList = usersListSession;
			listOrdersDTO = (ArrayList<OrdersDTO>) session
					.getAttribute("listOrdersDTOReport");
			reportDateBetween = (Integer) session
					.getAttribute("reportDateBetween");
			if (reportDateBetween == null) {
				reportDateBetween = 0;
				session.setAttribute("reportDateBetween", reportDateBetween);
			}

			/*------ always check if the Admin select all orders ------------
					if The Admin select all orders change checkBoxItem value 
			  ---------------------------------------------------------------*/
			if (selectAllOrdersSignal != null && selectAllOrdersSignal != 0L) {
				if (checkBoxItem != null) {
					session.setAttribute("checkBoxItem", checkBoxItem);
					session.setAttribute("allOrdersSelectedSignal", 0L);
					if (checkBoxItem)
						session.setAttribute("allOrdersSelectedSignal", 1L);
				}
			}
			checkBoxItem = (Boolean) session.getAttribute("checkBoxItem");
			if (checkBoxItem == null)
				checkBoxItem = false;
			/*------ always recovery creationDate from strCreationDate ------
						always keep the user search options
			  ---------------------------------------------------------------*/
			creationDateStart = null;
			SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
			if (((strCreationDateStart) != null)
					&& (!"".equals(strCreationDateStart))) {
				try {
					Date date = frm.parse(strCreationDateStart);
					creationDateStart = date;
					creationDateStartArg = date;
				} catch (Exception pe) {
					creationDateStart = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateStart == null) {
				Date date = frm.parse("01/01/1900");
				creationDateStartArg = date;
			}
			creationDateEnd = null;
			if (((strCreationDateEnd) != null)
					&& (!"".equals(strCreationDateEnd))) {
				frm = new SimpleDateFormat("dd/MM/yyyy");
				try {
					Date date = frm.parse(strCreationDateEnd);
					creationDateEnd = date;
					creationDateEndArg = date;
				} catch (Exception pe) {
					creationDateEnd = null;
					addActionError("Please enter a date in the correct format");
				}
			}
			if (creationDateEnd == null) {
				creationDateEndArg = new Date();
			}

			/*------ always recovery Status from selectedStatus key ------
						always keep the status search options
			  ---------------------------------------------------------------*/
			status = getStatusSelected(selectedStatus);

			/*----------- always initialized listPages if not done ----------
				   		    and check if is there next listPages
			  ---------------------------------------------------------------*/
			nextListPages = (Integer) session.getAttribute("nextListPages");
			if (nextListPages == null)
				nextListPages = 0;
			if (indexSet == null || indexSet == -1) {
				indexSet = (Integer) session.getAttribute("indexSet");
				if (indexSet == null)
					indexSet = 0;
			}
			listIndexSet = (List<OrdersDTO>) session
					.getAttribute("listIndexSet");
			if (listIndexSet == null)
				initalizeListIndexSet(session, orderService);

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/

			if (dateBetweenSignal != null && dateBetweenSignal != 0L) {
				reportDateBetween = ((reportDateBetween == null || reportDateBetween == 0) ? 1
						: 0);
				listOrdersDTO = new ArrayList<OrdersDTO>();
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("reportDateBetween", reportDateBetween);
				return SUCCESS;
			}

			/*----------------- When Admin Click on the pageIndex ----------------------------------
										catch  page index
			 ---------------------------------------------------------------------------------------*/
			if (pageIndexSignal != null && pageIndexSignal != 0L) {
				OrdersDTO orderDTO = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTO != null)
					orderDTO.setCssStyle("");
				OrdersDTO orderPageSelected = listIndexSet.get(indexList);
				orderPageSelected
						.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
				indexSet = orderPageSelected.getIndex() - 1;
				indexSet = indexSet * PAGE_ITEMS_COUNT;
				session.setAttribute("indexSet", indexSet);
				session.setAttribute("listIndexSet", listIndexSet);
				session.setAttribute("orderPageSelected", orderPageSelected);
			}

			/*----------------- When Admin Click on the nextListPages ------------------------------
						recreate listIndexSet started with index>index+10 and indexSet>indexSet+10
			 ---------------------------------------------------------------------------------------*/
			if (nextListPagesSignal != null && nextListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				OrdersDTO orderDTO = listIndexSet.get(listIndexSet.size() - 1);
				if (orderDTO != null)
					nextListPages = orderDTO.getIndex() + 1;
				Long totalOrders = orderService.getCountOrders(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status);
				String strcount = totalOrders.toString();
				Integer sizeList = Integer.parseInt(strcount)
						/ PAGE_ITEMS_COUNT;
				if (nextListPages <= sizeList + 1) {
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = nextListPages; i <= sizeList + 1
							&& i <= nextListPages + 10; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					if (nextListPages <= sizeList + 1) {
						indexSet = nextListPages - 1;
						OrdersDTO orderPageSelected = listIndexSet.get(0);
						orderPageSelected
								.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
						indexSet = indexSet * PAGE_ITEMS_COUNT;
						session.setAttribute("indexSet", indexSet);
						session.setAttribute("nextListPages", nextListPages);
						session.setAttribute("listIndexSet", listIndexSet);
						session.setAttribute("orderPageSelected",
								orderPageSelected);
					}
				}
			}

			/*----------------- When Admin Click on the previousListPages --------------------------
					recreate listIndexSet started with index< index-10 and indexSet<indexSet-10
			 ---------------------------------------------------------------------------------------*/
			if (prevListPagesSignal != null && prevListPagesSignal != 0L
					&& listIndexSet.size() > 0) {
				OrdersDTO orderDTOPrevious = (OrdersDTO) session
						.getAttribute("orderPageSelected");
				if (orderDTOPrevious != null)
					orderDTOPrevious.setCssStyle("");
				nextListPages = (Integer) session.getAttribute("nextListPages");
				if (nextListPages != null && nextListPages >= 11) {
					prevListPages = nextListPages - 11;
					listIndexSet = new ArrayList<OrdersDTO>();
					for (int i = prevListPages; i < nextListPages; i++) {
						OrdersDTO ord = new OrdersDTO();
						ord.setCssStyle("");
						ord.setIndex(i);
						listIndexSet.add(ord);
					}
					indexSet = prevListPages - 1;
					OrdersDTO orderPageSelected = listIndexSet.get(0);
					orderPageSelected
							.setCssStyle("background-color:#FFFF99;border:1px solid #CCCCCC;");
					indexSet = indexSet * PAGE_ITEMS_COUNT;
					nextListPages = prevListPages;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("indexSet", indexSet);
					session.setAttribute("listIndexSet", listIndexSet);
					session.setAttribute("orderPageSelected", orderPageSelected);
				}
			}

			/*----------------- When Admin change province -----------------------------------------
								Check a list off this province
			 ---------------------------------------------------------------------------------------*/
			hashProvinces = (Hashtable<String, ProvinceDTO>) session
					.getAttribute("hashProvinces");
			if (hashProvinces == null) {
				listProvinces = productService.getAllProvinces();
				Hashtable<String, ProvinceDTO> hashProvinces = new Hashtable<String, ProvinceDTO>();
				for (ProvinceDTO prov : listProvinces) {
					hashProvinces.put(prov.getCode(), prov);
				}
				session.setAttribute("hashProvinces", hashProvinces);
			}
			if (code != null && !code.equals("") && listOrdersDTO != null) {
				ProvinceDTO provinceDTO = hashProvinces.get(code);
				if (provinceDTO != null) {
					clientProvince = provinceDTO.getCode();
				}
			}// else listCities=new ArrayList<CityDTO>();
			if (listOrdersDTO != null && indexOrder != -1) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit != null) {
					orderToEdit.setClientProvince(code);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				}
			}

			/*------------------------------- Refresh listOrdersDTO------------------------------------
						Refresh listOrders before generation of invoiced orders XLS file 
				 ------------------------------------------------------------------------------------------*/
			invoicedOrdersRefresh = (Long) session
					.getAttribute("invoicedOrdersRefresh");
			if (invoicedOrdersRefresh != null && invoicedOrdersRefresh != 0L) {
				listIndexColumn = (ArrayList<Integer>) session
						.getAttribute("listIndexColumn");
				if (listIndexColumn == null)
					listIndexColumn = getNewListIndexColumn();
				lsOrderId = lsOrderId.toUpperCase();
				
				//Old Searching Functionality				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween,orderDTOObj,listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				//New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				indexSet = 0;
				session.setAttribute("indexSet", indexSet);
				nextListPages = 0;
				session.setAttribute("nextListPages", nextListPages);
				session.setAttribute("selectedStatus", selectedStatus);
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("invoicedOrdersRefresh", 0L);
				return SUCCESS;
			}

			/*------------ When Admin click on the Button "Delete Order" in The OrderDtailPop --------------
								show other pop to confirm Order Delete
			  ----------------------------------------------------------------------------------------------*/
			if (deleteOrderSignal != null && deleteOrderSignal != 0L) {
				message = "Attention! if you click on \"Delete Order\" you can not restore it.";
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (confirmDeleteSignal != null && confirmDeleteSignal == 0L) { // Delete
																				// Order
																				// Request
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "display:block;visibility:visible;";
				} else if (confirmDeleteSignal == 1L) { // Delete Order
														// Confirmed
					orderService.deleteOrderByLsOrderId(orderToEdit);
					// Save this operation in table operation
					OperationsDTO operationDTO = new OperationsDTO();
					User userAdmin = (User) session.getAttribute("userAdmin");
					if (userAdmin != null)
						operationDTO.setUserId(userAdmin.getId());
					operationDTO.setOperationDate(new Date());
					operationDTO.setOperationType("Delete Order");
					String dataBefore = "[PARTNER NAME:"
							+ orderToEdit.getUserLogin() + "];";
					dataBefore += " [LS_ORDER_ID:" + orderToEdit.getLsOrderId()
							+ "];";
					dataBefore += " [PRODUCT_ORDER_NUMBER:"
							+ orderToEdit.getProductOrderNumber() + "];";
					dataBefore += " [CLIENT_FIRST_NAME:"
							+ orderToEdit.getClientFirstName() + "];";
					dataBefore += " [CLIENT_LAST_NAME:"
							+ orderToEdit.getClientLastName() + "];";
					dataBefore += " [CLIENT_POSTAL_CODE:"
							+ orderToEdit.getClientPostalCode() + "];";
					dataBefore += " [LS_PRODUCT_ID:"
							+ orderToEdit.getLsProductID() + "];";
					dataBefore += " [UNIT_PRICE:" + orderToEdit.getUnitPrice()
							+ "];";
					dataBefore += " [STATUS:" + orderToEdit.getStatus() + "];";
					operationDTO.setDataBefore(dataBefore);
					operationDTO.setDataBefore(operationDTO.getDataBefore());
					operationDTO.setDataAfter("");
					operationsService.insertOperation(operationDTO);
					// Remove order from the list orders
					listOrdersDTO.remove(orderToEdit);
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					showOrderDetailPop = "visibility:hidden;display:none;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
					// initialize index orders
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				} else { // Cancel Order Delete
					showOrderDetailPop = "display:block;visibility:visible;";
					showConfirmDeleteOrderPop = "visibility:hidden;display:none;";
				}
				return SUCCESS;
			}

			/*------ When Admin click the "Edit link" in the Order Table for Edit NOTE -----
							show only field Edit Note
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showOnlyEditNote != null && showOnlyEditNote != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowOnlyEditNote(0L);
					order.setCssRow("");
				}
				orderToEdit.setShowOnlyEditNote(1L);
				orderToEdit.setCssRow("background-color:#FF9966;");
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (ArrayList<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save Edit Note in the Orders Table" ----------
													save Only  notes
			  -------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOnlyNoteSignal != null && saveOnlyNoteSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						orderToEdit.setNotes(notes);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						orderToEdit.setCssRow("");
						// Save Note
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click the "Edit link" in the Order Table -------------
								show fields to edit shipping parameters
			  ------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& showRowShipping != null && showRowShipping != 0L) {

				orderToEdit = listOrdersDTO.get(indexOrder);
				for (OrdersDTO order : listOrdersDTO) {
					order.setShowRowShipping(0L);
					order.setCssRow("");
				}
				// only Admins who has Active = true of action name='All' can
				// change shipping settings
				// of orders shipped or invoiced
				if (usersPrivChangeShippedStatus == null
						&& orderToEdit.getStatus() != null
						&& (orderToEdit.getStatus().equals("shipped") || orderToEdit
								.getStatus().equals("invoiced"))) {
					showRowShipping = 0L;
					return SUCCESS;
				}

				if (orderToEdit != null) {
					orderToEdit.setShowRowShipping(1L);
					orderToEdit.setShowOnlyEditNote(1L);
					orderToEdit.setCssRow("background-color:#FF9966;");
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (ArrayList<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				if (orderToEdit.getStatus().equals("open")) {
					statusId = 0L;
				} else if (orderToEdit.getStatus().equals("progress")) {
					statusId = 1L;
				} else if (orderToEdit.getStatus().equals("shipped")) {
					statusId = 2L;
				} else if (orderToEdit.getStatus().equals("invoiced")) {
					statusId = 3L;
				} else if (orderToEdit.getStatus().equals("canceled")) {
					statusId = 4L;
				}
				return SUCCESS;
			}

			/*------------ When Admin click on link "Save in the Orders Table" ----------
							save all shipping parameters and notes
			 ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveShippingSignal != null && saveShippingSignal != 0L) {
				if (indexOrder != null) {
					orderToEdit = listOrdersDTO.get(indexOrder);
					if (orderToEdit != null) {
						Date shippedDateToEdit = null;
						frm = new SimpleDateFormat("dd/MM/yyyy");
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))) {
							strShippedDate = strShippedDate.replaceAll(" ", "");
							try {
								Date date = frm.parse(strShippedDate);
								shippedDateToEdit = date;
							} catch (Exception pe) {
								shippedDateToEdit = null;
							}
						}
						if (((strShippedDate) != null)
								&& (!"".equals(strShippedDate))
								&& strShippedDate.length() <= 8)
							shippedDateToEdit = orderToEdit.getShippedDate();
						Double shippingPrice = null;
						// Double currencyShippingPrice=null;
						if (strShippingPrice != null
								&& !strShippingPrice.equals("")) {
							strShippingPrice = strShippingPrice.replaceAll(" ",
									"");
							int index = strShippingPrice.indexOf(",");
							if (index >= 0) {
								String strUnitPrice1 = strShippingPrice
										.substring(0, index);
								String strUnitPrice2 = strShippingPrice
										.substring(index + 1,
												strShippingPrice.length());
								strShippingPrice = strUnitPrice1 + "."
										+ strUnitPrice2;
							}

							try {
								shippingPrice = Double
										.parseDouble(strShippingPrice);
								/*
								 * if(shippingPrice!=null &&
								 * orderToEdit.getCurrencyId()!=null &&
								 * orderToEdit.getCurrencyId()!=1 &&
								 * orderToEdit.getCurrencyRate()!=null) {
								 * currencyShippingPrice = shippingPrice *
								 * orderToEdit.getCurrencyRate();
								 * currencyShippingPrice = (double)
								 * Math.round(currencyShippingPrice*100)/100; }
								 */
							} catch (Exception pe) {
								shippingPrice = null;
							}
						}

						if (trakingNumber != null)
							trakingNumber = trakingNumber.replaceAll(
									"^ +| +$|( )+", "$1");
						if (shippingCompany != null)
							shippingCompany = shippingCompany.replaceAll(
									"^ +| +$|( )+", "$1");
						orderToEdit.setShippingPrice(shippingPrice);
						// orderToEdit.setCurrencyShippingPrice(currencyShippingPrice);
						// orderToEdit.getRowsList().get(0).setCurrencyShippingPrice(currencyShippingPrice);
						orderToEdit.setShippedDate(shippedDateToEdit);
						orderToEdit.setNotes(notes);
						if (newStatus != null && !newStatus.equals(""))
							orderToEdit.setStatus(newStatus);
						orderToEdit.setShippingCompany(shippingCompany);
						orderToEdit.setTrackingNumber(trakingNumber);
						orderToEdit.setShowRowShipping(0L);
						orderToEdit.setShowOnlyEditNote(0L);
						OrdersRows row = orderToEdit.getRowsList().get(0);
						row.setShippingPrice(shippingPrice);
						row.setShippingCompany(shippingCompany);
						row.setTrackingNumber(trakingNumber);
						orderToEdit.setCssRow("");

						if (newStatus != null && !newStatus.equals("")) { // if
																			// admin
																			// click
																			// on
																			// the
																			// save
																			// behind
																			// status
							orderService.updateStatusByLsOrderId(
									orderToEdit.getLsOrderId(), newStatus);
							orderToEdit.setStatus(newStatus);
							if (!newStatus.equals("shipped")
									&& !newStatus.equals("invoiced")
									&& !newStatus.equals("canceled")) {
								orderToEdit.setShippingPrice(null);
								orderToEdit.setTrackingNumber(null);
								orderToEdit.setShippedDate(null);
							}

						} else {// if admin click on the save other than Status
							if (orderToEdit.getShippedDate() != null
									&& orderToEdit.getTrackingNumber() != null
									&& !orderToEdit.getTrackingNumber().equals(
											"")
									&& orderToEdit.getShippingCompany() != null
									&& !orderToEdit.getShippingCompany()
											.equals("")
									&& orderToEdit.getShippingPrice() != null
									&& orderToEdit.getStatus() != null) {
								if (orderToEdit.getStatus().equals("open")
										|| orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"shipped");
									orderToEdit.setStatus("shipped");
								}
							} else {
								if (usersPrivChangeShippedStatus != null
										&& !orderToEdit.getStatus().equals(
												"open")
										&& !orderToEdit.getStatus().equals(
												"progress")) {
									orderService.updateStatusByLsOrderId(
											orderToEdit.getLsOrderId(),
											"progress");
									orderToEdit.setStatus("progress");
								}
							}
						}
						// if admin click on the save other then status(save
						// notes, save shipping company ...)
						Boolean sucess = orderService
								.updateShippingOrderElements(orderToEdit);
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				}
				return SUCCESS;
			}

			/*------------ When Admin click on icon findOrders.png ----------
								check user and complete infos client
			 ----------------------------------------------------------------*/
			if (findOrdersSignal != null
					&& findOrdersSignal != 0L
					|| (pageIndexSignal != null && pageIndexSignal != 0L)
					|| (nextListPagesSignal != null && nextListPagesSignal != 0L)
					|| (prevListPagesSignal != null && prevListPagesSignal != 0L)) {
				// session.setAttribute("allOrdersSelectedSignal",0L);
				// if admin click on search icon initialize checkBoxItem to
				// false
				if (findOrdersSignal != null && findOrdersSignal != 0L) {
					session.setAttribute("allOrdersSelectedSignal", 0L);
					checkBoxItem = false;
					session.setAttribute("checkBoxItem", checkBoxItem);
					indexSet = 0;
					session.setAttribute("indexSet", indexSet);
					nextListPages = 0;
					session.setAttribute("nextListPages", nextListPages);
					session.setAttribute("selectedStatus", selectedStatus);

				}
				// if admin navigate on pages keep the previous sorting
				if (((pageIndexSignal != null && pageIndexSignal != 0L)
						|| (nextListPagesSignal != null && nextListPagesSignal != 0L) || (prevListPagesSignal != null && prevListPagesSignal != 0L))) {
					listIndexColumn = (ArrayList<Integer>) session
							.getAttribute("listIndexColumn");
					if (listIndexColumn == null)
						listIndexColumn = getNewListIndexColumn();
				} else { // prepare new sorting
					listIndexColumn = getNewListIndexColumn();
				}

				lsOrderId = lsOrderId.toUpperCase();
				// if(findOrdersSignal!=null &&
				// findOrdersSignal!=0L)initalizeListIndexSet(session,orderService
				// );
				
				
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, userLogin, lsOrderId, status,
						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
//				//New Searching Functionality
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, orderDTOObj, listIndexColumn,
//						PAGE_ITEMS_COUNT, indexSet);
				
				
				// Color in RED rows containing a GroupItems
				for (OrdersDTO orderDTO : listOrdersDTO) {
					if (orderDTO != null && orderDTO.getStatus() != null
							&& orderDTO.getStatus().equals("shipped")) {
						Long count = productService.isGroupProductID(orderDTO
								.getProductId());
						if (count != null && count >= 1) {
							orderDTO.setCssStyle("background-color: rgb(248,150,140); border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
						}
					}
				}

				// keep search parameters to use in other
				// classes(PrintOrdersToPDF, ...)
				session.setAttribute("creationDateStartArg",
						creationDateStartArg);
				session.setAttribute("creationDateEndArg", creationDateEndArg);
				session.setAttribute("reportDateBetween", reportDateBetween);
				session.setAttribute("lsOrderId", lsOrderId);
				session.setAttribute("userLogin", userLogin);
				session.setAttribute("status", status);

				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("sizeResult", sizeResult);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				if (findOrdersSignal != null && findOrdersSignal != 0L)
					initalizeListIndexSet(session, orderService);
				return SUCCESS;
			}

			/*------------ When Admin click on the icon sorting of column ----------
							seach result with option of sorting list
			 -----------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& sortingOrdersSignal != null && sortingOrdersSignal != 0L) {
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				asc = (asc == 1 ? -1 : 1);
				int nextElement = listIndexColumn.get(0);
				fieldForSorting = asc * fieldForSorting;
				listIndexColumn.set(0, fieldForSorting);
				for (int i = 1; i < listIndexColumn.size(); i++) {
					int element = listIndexColumn.get(i);
					listIndexColumn.set(i, nextElement);
					nextElement = element;
				}
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				// New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, orderDTOObj, listIndexColumn,
						PAGE_ITEMS_COUNT, indexSet);
				
				int balance = 0;
				int OrderIndex = 0;
				for (OrdersDTO orDTO : listOrdersDTO) {
					balance = (balance == 1 ? 0 : 1);
					if (balance == 1) {
						orDTO.setCssStyle("background-color: rgb(245,249,252);border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					} else {
						orDTO.setCssStyle("background-color: color:white;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:1px solid #CCCCCC;");
					}
					orDTO.setIndex(OrderIndex);
					OrderIndex++;
				}
				session.setAttribute("listIndexColumn", listIndexColumn);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				session.setAttribute("asc", asc);
				return SUCCESS;
			}

			/*------ when Admin click on the lsOrder link in table -----------
					show popup detail and allow admin to update Order
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& editOrderSignal != null && editOrderSignal != 0L) {
				orderToEdit = listOrdersDTO.get(indexOrder);
				if (orderToEdit == null)
					orderToEdit = new OrdersDTO();
				if (orderToEdit.getProductOrderDate() == null)
					strProductOrderDate = "";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*--- when Admin click on the cancel Button of orderDetailPop ---
					we mast just hide popup OrderDetail
			  ---------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& cancelSignal != null && cancelSignal != 0L) {
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}

			/*-------------------- When Admin left lsProduct TextField -------------
								check userPrice in DB, and write it in web view
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& checkProductPriceSignal != null
					&& checkProductPriceSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToUpadate = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				UserProductPriceDTO userProductPrice = productService
						.getUsrPPriceByLsproductId(userId, lsProductID);
				orderRowToUpadate.setCss("");
				orderRowToUpadate.setCssPrice("");
				if (userProductPrice == null) {
					orderRowToUpadate.setCss("background-color:red;");
					orderRowToUpadate.setProductDescription("");
					orderRowToUpadate.setStock(null);
					orderRowToUpadate.setProductId(null);
					orderRowToUpadate.setLsProductID(lsProductID);
					orderRowToUpadate.setLsPrice(null);
				} else {
					Double usrPrice = orderRowToUpadate.getUnitPrice();
					if (usrPrice == null)
						usrPrice = 0D;
					if (usrPrice < userProductPrice.getPriceNum()) {
						orderRowToUpadate.setCssPrice("background-color:red;");
					}
					orderRowToUpadate.setProductDescription(userProductPrice
							.getProductTitle());
					orderRowToUpadate.setStock(userProductPrice.getStock());
					orderRowToUpadate.setProductId(userProductPrice
							.getProductId());
					orderRowToUpadate.setLsProductID(userProductPrice
							.getLsProductId());
					orderRowToUpadate
							.setLsPrice(userProductPrice.getPriceNum());
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = orderDTOToUpdate;
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*----------------- When Admin check on saveTemporaryRow Icon --------------------------
					we must first obtained the object that contains the list of rows,
					after we accede to the row by index recovered by web view and change it
			 ---------------------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveTemporaryRowSignal != null
					&& saveTemporaryRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToSaveMemory = orderDTOToUpdate
						.getRowsList().get(indexRow);
				orderRowToSaveMemory.setIcon("images/orders/itemValidated.png");
				if (orderRowToSaveMemory != null) {
					orderRowToSaveMemory.setQuantity(quantity);
					orderRowToSaveMemory.setLsProductID(lsProductID);
					orderRowToSaveMemory
							.setProductDescription(productDescription);
					orderRowToSaveMemory.setUnitPrice(unitPrice);
					orderRowToSaveMemory
							.setCssPrice("background-color:#FF6666;");
					orderRowToSaveMemory
							.setCssQuantity("background-color:#FF6666;");
					if (quantity != null && quantity > 0D)
						orderRowToSaveMemory.setCssQuantity("");
					if (unitPrice != null
							&& orderRowToSaveMemory.getLsPrice() != null
							&& unitPrice >= orderRowToSaveMemory.getLsPrice())
						orderRowToSaveMemory.setCssPrice("");
					orderRowToSaveMemory.setShippingFee(shippingFee);
					orderRowToSaveMemory.setShippingPrice(shippingFee);
					orderRowToSaveMemory.setShippingCompany(shippingCompany);
					orderRowToSaveMemory.setTrackingNumber(trakingNumber);
					if (orderRowToSaveMemory.getCurrencyId() != null
							&& orderRowToSaveMemory.getCurrencyId() != 1
							&& orderRowToSaveMemory.getCurrencyRate() != null) {
						if (unitPrice != null) {
							orderRowToSaveMemory
									.setCurrencyUnitPrice(unitPrice);
							unitPrice = unitPrice
									/ orderRowToSaveMemory.getCurrencyRate();
							unitPrice = (double) Math.round(unitPrice * 100) / 100;
							orderRowToSaveMemory.setUnitPrice(unitPrice);
						}
						/*
						 * if(shippingFee!=null) {
						 * orderRowToSaveMemory.setCurrencyShippingPrice
						 * (shippingFee); shippingFee =
						 * shippingFee/orderRowToSaveMemory.getCurrencyRate();
						 * shippingFee = (double)
						 * Math.round(shippingFee*100)/100;
						 * orderRowToSaveMemory.setShippingPrice(shippingFee); }
						 */
					}
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				// Change totalPrice also
				if (orderToEdit.getRowsList().get(0) != null
						&& orderToEdit.getRowsList().get(0).getQuantity() != null
						&& orderToEdit.getRowsList().get(0)
								.getQuantityToSplit() != null
						&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
					Double priceTotal = orderToEdit.getRowsList().get(0)
							.getUnitPrice()
							* orderToEdit.getRowsList().get(0)
									.getQuantityToSplit();
					priceTotal = (double) Math.round(priceTotal * 100) / 100;
					orderToEdit.setTotalPrice(priceTotal);
				}
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------- When Admin click on addSimilarRow Icon on the OrderDetailPop --------
								Add one Row Similar at the previews
			  -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& addSimilarRowSignal != null && addSimilarRowSignal != 0L) {
				OrdersDTO orderDTOToUpdate = listOrdersDTO.get(indexOrder);
				// generate lsOrderId to new order
				orderDTOToUpdate = fillDataOrderDTO(orderDTOToUpdate);
				OrdersRows orderRowToClone = orderDTOToUpdate.getRowsList()
						.get(indexRow);
				if (orderRowToClone != null) {
					if (!orderRowToClone.getIcon().equals(
							"images/orders/itemValidated.png")) {
						orderRowToClone.setQuantity(quantity);
						orderRowToClone.setLsProductID(lsProductID);
						orderRowToClone.setStock(stock);
						orderRowToClone
								.setProductDescription(productDescription);
						orderRowToClone.setUnitPrice(unitPrice);
						orderRowToClone.setShippingFee(shippingFee);
						orderRowToClone.setShippingCompany(shippingCompany);
						orderRowToClone.setTrackingNumber(trakingNumber);
					}
					orderRowToClone.setIcon("images/orders/itemValidated.png");
					OrdersRows orderRowToAdd = DTOFactory
							.getOrderRowClone(orderRowToClone);
					orderRowToAdd.setId(-1L);
					// Add currencyId
					if (orderRowToClone.getCurrencyId() != null)
						orderRowToAdd.setCurrencyId(orderRowToClone
								.getCurrencyId());

					orderDTOToUpdate.getRowsList().add(indexRow + 1,
							orderRowToAdd);
					int indexOrder = 0;
					int indexRow = 0;
					for (OrdersDTO orderDTO : listOrdersDTO) {
						orderDTO.setIndex(indexOrder);
						indexOrder++;
						indexRow = 0;
						for (OrdersRows orderRows : orderDTO.getRowsList()) {
							orderRows.setIndex(indexRow);
							indexRow++;
						}
					}
					session.setAttribute("listOrdersDTOReport", listOrdersDTO);
					listOrdersDTO = (List<OrdersDTO>) session
							.getAttribute("listOrdersDTOReport");
				}
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------- When Admin click on Delete Row Icon of orderDetail Popup-----------
									Delete this row using index
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& deleteRowSignal != null && deleteRowSignal != 0L) {
				OrdersDTO orderDTO = listOrdersDTO.get(indexOrder);
				orderDTO = fillDataOrderDTO(orderDTO);
				int nb = orderService.nbOrderRowsNotDeleted(orderDTO
						.getRowsList());
				if (orderDTO != null && orderDTO.getRowsList().size() > 1) {
					for (int i = 0; i < orderDTO.getRowsList().size(); i++) {
						if (i == indexRow && nb > 1) {
							orderDTO.getRowsList().get(i).setToDelete(1);
							break;
						}
					}
				}
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ when Admin click on the button save of orderDetail ------------------
					 save order and hide pup  
			  ----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& saveOrdersSignal != null && saveOrdersSignal != 0L) {
				session.setAttribute("orderNotSavedAtFirst", null);
				orderToEdit = listOrdersDTO.get(indexOrder);
				orderToEdit = fillDataOrderDTO(orderToEdit);

				// add special handling shipping
				User user = null;
				if (orderToEdit.getUserLogin() != null)
					user = userService.getUserByLogin(orderToEdit
							.getUserLogin());
				if (user != null) {
					Double totalPrice = null;
					orderToEdit.setSpecialHandlingName(user
							.getSpecialHandlingName());
					orderToEdit.setSpecialHandlingFee(user
							.getSpecialHandlingFee());
					if (orderToEdit.getRowsList().get(0).getQuantity() != null
							&& orderToEdit.getRowsList().get(0).getUnitPrice() != null) {
						totalPrice = orderToEdit.getRowsList().get(0)
								.getQuantity()
								* orderToEdit.getRowsList().get(0)
										.getUnitPrice();
						totalPrice = (double) Math.round(totalPrice * 100) / 100;
					}

					orderToEdit.setTotalPrice(totalPrice);
				}

				orderService.updateOrderByLsOrderId(orderToEdit);
				for (OrdersRows row : orderToEdit.getRowsList()) {
					if (row.getId() == -1)
						row.setId(0L);
				}
				OrdersRows row = orderToEdit.getRowsList().get(0);
				if (row != null) {
					orderToEdit.getShippedDate();
					orderToEdit.setLsPrice(row.getLsPrice());
					orderToEdit.setLsProductID(row.getLsProductID());
					orderToEdit.setProductDescription(row
							.getProductDescription());
					orderToEdit.setQuantity(row.getQuantity());
				}
				orderToEdit = DTOFactory.getOrderDTOConsideredMissingInfo(
						orderToEdit, hashProvinces);
				listIndexColumn = (List<Integer>) session
						.getAttribute("listIndexColumn");
				
//				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
//						creationDateStartArg, creationDateEndArg,
//						reportDateBetween, userLogin, lsOrderId, status,
//						listIndexColumn, PAGE_ITEMS_COUNT, indexSet);
				
				// New Searching Functionality
				listOrdersDTO = orderService.searchOrdersWithOptionsAndSorting(
						creationDateStartArg, creationDateEndArg,
						reportDateBetween, orderDTOObj, listIndexColumn,
						PAGE_ITEMS_COUNT, indexSet);
				
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				message = "Saving has completed successfuly";
				showSaveSuccessPop = "display:block;visibility:visible;";
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*------ When user change Quantity to split in orderDetailPop -----------
					 prepare order to split from two other orders witch
				 	 one must have a lsOrder with underscore 
			 ------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& quantityToChangeSignal != null
					&& quantityToChangeSignal != 0L) {
				OrdersDTO orderToChangeQt = listOrdersDTO.get(indexOrder);
				OrdersRows orderRow = orderToChangeQt.getRowsList().get(
						indexRow);
				orderToChangeQt = fillDataOrderDTO(orderToChangeQt);
				if (quantityToChange < orderRow.getQuantity())
					orderRow.setQuantityToSplit(quantityToChange);
				session.setAttribute("listOrdersDTOReport", listOrdersDTO);
				listOrdersDTO = (List<OrdersDTO>) session
						.getAttribute("listOrdersDTOReport");
				orderToEdit = listOrdersDTO.get(indexOrder);
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- Duplicate Order ----------------------------------------
							Create order in just in memory
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& duplicateOrderSignal != null
					&& duplicateOrderSignal != 0L) {
				OrdersDTO orderToClone = listOrdersDTO.get(indexOrder);
				orderToClone = fillDataOrderDTO(orderToClone);
				hashOrders = new Hashtable<String, OrdersDTO>();
				for (OrdersDTO ord : listOrdersDTO) {
					hashOrders.put(ord.getLsOrderId(), ord);
				}
				OrdersDTO orderClone = DTOFactory
						.getOrderDTOSplitted(orderToClone);
				if (orderClone != null) {
					orderClone.setDuplicate(true);
					String lsOrder = orderClone.getLsOrderId();
					String strlsOrder = orderService.generateLsOrderId(lsOrder,
							hashOrders);
					orderClone.setLsOrderId(strlsOrder);// rgb(116,180,209)
					orderClone
							.setCssStyle("background-color:#FFFF99;border-right: 1px solid #CCCCCC;border-left:1px solid #CCCCCC;border-top:  1px solid #CCCCCC;");
					orderToEdit = orderClone;
					orderToEdit.setBackgroundColor("background-color:#FFFF99;");
					listOrdersDTO.add(indexOrder + 1, orderClone);
					indexOrder = 0;
					for (OrdersDTO ord : listOrdersDTO) {
						ord.setIndex(indexOrder);
						indexOrder++;
					}
					orderService.updateOrderByLsOrderId(orderToClone);
					orderService.insertOrderWithRows(orderClone);
					orderClone.setDuplicate(false);
					for (OrdersRows row : orderClone.getRowsList()) {
						if (row.getId() < 0L)
							row.setId(0L);
					}
					if (listOrdersDTO.size() > 0) {
						session.setAttribute("listOrdersDTOReport",
								listOrdersDTO);
					}
				} else
					orderToEdit = orderToClone;
				showOrderDetailPop = "display:block;visibility:visible;";
				return SUCCESS;
			}

			/*-------------------- When user check print item -----------------------------
					Add or remove this element from the orders to print
			 -----------------------------------------------------------------------------*/
			if (listOrdersDTO != null && listOrdersDTO.size() > 0
					&& okSaveSuccessPopSignal != null
					&& okSaveSuccessPopSignal != 0L) {
				showSaveSuccessPop = "visibility:hidden;display:none;";
				showOrderDetailPop = "visibility:hidden;display:none;";
				return SUCCESS;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return "input";
		}
		return SUCCESS;
	}

	/*
	 * ==========================================================================
	 * =============== fill all fields of order without rows
	 * ====================
	 * =====================================================================
	 */
	public OrdersDTO fillDataOrderDTO(OrdersDTO orderDTO) {
		SimpleDateFormat frm = new SimpleDateFormat("dd/MM/yyyy");
		orderDTO.setClientLastName(clientLastName);
		orderDTO.setClientFirstName(clientFirstName);
		orderDTO.setClientOtherNames(clientOtherNames);
		orderDTO.setClientStreet(clientStreet);
		orderDTO.setClientOtherStreet(clientOtherStreet);
		orderDTO.setClientCity(clientCity);
		orderDTO.setClientProvince(code);
		orderDTO.setClientPostalCode(clientPostalCode);
		orderDTO.setClientPhone(clientPhone);
		orderDTO.setClientEmail(clientEmail);
		orderDTO.setProductOrderNumber(productOrderNumberSearch);
		orderDTO.setCompanyHeader(companyHeader);
		if (((strProductOrderDate) != null)
				&& (!"".equals(strProductOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strProductOrderDate);
				orderDTO.setProductOrderDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strCreationOrderDate) != null)
				&& (!"".equals(strCreationOrderDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strCreationOrderDate);
				orderDTO.setCreationDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}

		if (((strRequiredDate) != null) && (!"".equals(strRequiredDate))) {
			frm = new SimpleDateFormat("dd/MM/yyyy");
			try {
				Date date = frm.parse(strRequiredDate);
				orderDTO.setRequiredDate(date);
			} catch (Exception pe) {
				addActionError("Please enter a date in the correct format");
			}
		}
		return orderDTO;
	}

	/*
	 * ==========================================================================
	 * =============== initialize ListIndexSet
	 * ==================================
	 * =======================================================
	 */
	public void initalizeListIndexSet(HttpSession session,
			OrdersService orderService) throws ServiceException {
		listIndexSet = new ArrayList<OrdersDTO>();
		totalOrders = orderService.getCountOrders(creationDateStartArg,
				creationDateEndArg, reportDateBetween, userLogin, lsOrderId,
				status);
		String strcount = totalOrders.toString();
		Integer sizeList = Integer.parseInt(strcount) / PAGE_ITEMS_COUNT;
		nextListPages = 1;
		session.setAttribute("nextListPages", nextListPages);
		for (int i = 1; i <= sizeList + 1 && i <= 11; i++) {
			OrdersDTO ord = new OrdersDTO();
			ord.setCssStyle("");
			ord.setIndex(i);
			listIndexSet.add(ord);
		}
		indexSet = 0;
		session.setAttribute("indexSet", indexSet);
		session.setAttribute("totalOrders", totalOrders);
		session.setAttribute("listIndexSet", listIndexSet);

	}

	/*
	 * ==========================================================================
	 * =============== initialize listIndexColumn
	 * ================================
	 * =========================================================
	 */
	List<Integer> getNewListIndexColumn() {
		List<Integer> reult = new ArrayList<Integer>();
		for (int i = 0; i <= 34; i++) {
			if (i != 2 && i <= 13) {
				reult.add(i);
				if (i != 0)
					reult.add(-i);
			}
			if (i == 30 || i == 31 || i == 34) {
				reult.add(i);
				reult.add(-i);
			}
		}
		return reult;
	}

	/*
	 * ==========================================================================
	 * =============== getStatus Selected by Admin for searching
	 * ================
	 * =========================================================================
	 */
	public String getStatusSelected(Integer StatusIndex) {
		String result = "";
		switch (StatusIndex) {
		case 0:
			result = "open";
			break;
		case 1:
			result = "progress";
			break;
		case 2:
			result = "shipped";
			break;
		case 3:
			result = "invoiced";
			break;
		case 4:
			result = "canceled";
			break;
		default:
			result = "";
		}
		return result;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
